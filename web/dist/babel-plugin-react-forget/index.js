/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */

"use no memo";
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var t$a = require("@babel/types");
var require$$0 = require("os");
var require$$1 = require("tty");
function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(
          n,
          k,
          d.get
            ? d
            : {
                enumerable: true,
                get: function () {
                  return e[k];
                },
              },
        );
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var t__namespace = _interopNamespaceDefault(t$a);
function assertExhaustive(_, errorMsg) {
  throw new Error(errorMsg);
}
function retainWhere(array, predicate) {
  let writeIndex = 0;
  for (let readIndex = 0; readIndex < array.length; readIndex++) {
    const item = array[readIndex];
    if (predicate(item) === true) {
      array[writeIndex++] = item;
    }
  }
  array.length = writeIndex;
}
function getOrInsertDefault(m, key, defaultValue) {
  if (m.has(key)) {
    return m.get(key);
  } else {
    m.set(key, defaultValue);
    return defaultValue;
  }
}
function hasNode(input) {
  return input.node != null;
}
exports.ErrorSeverity = void 0;
(function (ErrorSeverity) {
  ErrorSeverity["InvalidJS"] = "InvalidJS";
  ErrorSeverity["InvalidReact"] = "InvalidReact";
  ErrorSeverity["InvalidConfig"] = "InvalidConfig";
  ErrorSeverity["CannotPreserveMemoization"] = "CannotPreserveMemoization";
  ErrorSeverity["Todo"] = "Todo";
  ErrorSeverity["Invariant"] = "Invariant";
})(exports.ErrorSeverity || (exports.ErrorSeverity = {}));
exports.CompilerSuggestionOperation = void 0;
(function (CompilerSuggestionOperation) {
  CompilerSuggestionOperation[
    (CompilerSuggestionOperation["InsertBefore"] = 0)
  ] = "InsertBefore";
  CompilerSuggestionOperation[
    (CompilerSuggestionOperation["InsertAfter"] = 1)
  ] = "InsertAfter";
  CompilerSuggestionOperation[(CompilerSuggestionOperation["Remove"] = 2)] =
    "Remove";
  CompilerSuggestionOperation[(CompilerSuggestionOperation["Replace"] = 3)] =
    "Replace";
})(
  exports.CompilerSuggestionOperation ||
    (exports.CompilerSuggestionOperation = {}),
);
class CompilerErrorDetail {
  constructor(options) {
    this.options = options;
  }
  get reason() {
    return this.options.reason;
  }
  get description() {
    return this.options.description;
  }
  get severity() {
    return this.options.severity;
  }
  get loc() {
    return this.options.loc;
  }
  get suggestions() {
    return this.options.suggestions;
  }
  printErrorMessage() {
    const buffer = [`${this.severity}: ${this.reason}`];
    if (this.description != null) {
      buffer.push(`. ${this.description}`);
    }
    if (this.loc != null && typeof this.loc !== "symbol") {
      buffer.push(` (${this.loc.start.line}:${this.loc.end.line})`);
    }
    return buffer.join("");
  }
  toString() {
    return this.printErrorMessage();
  }
}
class CompilerError extends Error {
  static invariant(condition, options) {
    if (!condition) {
      const errors = new CompilerError();
      errors.pushErrorDetail(
        new CompilerErrorDetail(
          Object.assign(Object.assign({}, options), {
            severity: exports.ErrorSeverity.Invariant,
          }),
        ),
      );
      throw errors;
    }
  }
  static throwTodo(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: exports.ErrorSeverity.Todo,
        }),
      ),
    );
    throw errors;
  }
  static throwInvalidJS(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: exports.ErrorSeverity.InvalidJS,
        }),
      ),
    );
    throw errors;
  }
  static throwInvalidReact(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: exports.ErrorSeverity.InvalidReact,
        }),
      ),
    );
    throw errors;
  }
  static throwInvalidConfig(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: exports.ErrorSeverity.InvalidConfig,
        }),
      ),
    );
    throw errors;
  }
  static throw(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(new CompilerErrorDetail(options));
    throw errors;
  }
  constructor(...args) {
    super(...args);
    this.details = [];
    this.name = "ReactCompilerError";
  }
  get message() {
    return this.toString();
  }
  set message(_message) {}
  toString() {
    return this.details.map((detail) => detail.toString()).join("\n\n");
  }
  push(options) {
    var _a;
    const detail = new CompilerErrorDetail({
      reason: options.reason,
      description:
        (_a = options.description) !== null && _a !== void 0 ? _a : null,
      severity: options.severity,
      suggestions: options.suggestions,
      loc: typeof options.loc === "symbol" ? null : options.loc,
    });
    return this.pushErrorDetail(detail);
  }
  pushErrorDetail(detail) {
    this.details.push(detail);
    return detail;
  }
  hasErrors() {
    return this.details.length > 0;
  }
  isCritical() {
    return this.details.some((detail) => {
      switch (detail.severity) {
        case exports.ErrorSeverity.Invariant:
        case exports.ErrorSeverity.InvalidJS:
        case exports.ErrorSeverity.InvalidReact:
        case exports.ErrorSeverity.InvalidConfig:
          return true;
        case exports.ErrorSeverity.CannotPreserveMemoization:
        case exports.ErrorSeverity.Todo:
          return false;
        default:
          assertExhaustive(detail.severity, "Unhandled error severity");
      }
    });
  }
}
function insertGatedFunctionDeclaration(fnPath, compiled, gating) {
  const gatingExpression = t__namespace.conditionalExpression(
    t__namespace.callExpression(
      t__namespace.identifier(gating.importSpecifierName),
      [],
    ),
    buildFunctionExpression(compiled),
    buildFunctionExpression(fnPath.node),
  );
  let compiledFn;
  if (
    fnPath.parentPath.node.type !== "ExportDefaultDeclaration" &&
    fnPath.node.type === "FunctionDeclaration" &&
    fnPath.node.id != null
  ) {
    compiledFn = fnPath.replaceWith(
      t__namespace.variableDeclaration("const", [
        t__namespace.variableDeclarator(fnPath.node.id, gatingExpression),
      ]),
    )[0];
  } else {
    compiledFn = fnPath.replaceWith(gatingExpression)[0];
  }
  return compiledFn;
}
function buildFunctionExpression(node) {
  var _a, _b;
  if (
    node.type === "ArrowFunctionExpression" ||
    node.type === "FunctionExpression"
  ) {
    return node;
  } else {
    const fn = {
      type: "FunctionExpression",
      async: node.async,
      generator: node.generator,
      loc: (_a = node.loc) !== null && _a !== void 0 ? _a : null,
      id: (_b = node.id) !== null && _b !== void 0 ? _b : null,
      params: node.params,
      body: node.body,
    };
    return fn;
  }
}
function makeTypeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
let typeCounter = 0;
function makeType() {
  return { kind: "Type", id: makeTypeId(typeCounter++) };
}
function typeEquals(tA, tB) {
  if (tA.kind !== tB.kind) return false;
  return (
    typeVarEquals(tA, tB) ||
    funcTypeEquals(tA, tB) ||
    objectTypeEquals(tA, tB) ||
    primitiveTypeEquals(tA, tB) ||
    polyTypeEquals(tA, tB) ||
    phiTypeEquals(tA, tB) ||
    propTypeEquals(tA, tB) ||
    objectMethodTypeEquals(tA, tB)
  );
}
function typeVarEquals(tA, tB) {
  if (tA.kind === "Type" && tB.kind === "Type") {
    return tA.id === tB.id;
  }
  return false;
}
function typeKindCheck(tA, tb, type) {
  return tA.kind === type && tb.kind === type;
}
function objectMethodTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "ObjectMethod");
}
function propTypeEquals(tA, tB) {
  if (tA.kind === "Property" && tB.kind === "Property") {
    if (!typeEquals(tA.object, tB.object)) {
      return false;
    }
    return tA.propertyName === tB.propertyName;
  }
  return false;
}
function primitiveTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Primitive");
}
function polyTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Poly");
}
function objectTypeEquals(tA, tB) {
  if (tA.kind === "Object" && tB.kind == "Object") {
    return tA.shapeId === tB.shapeId;
  }
  return false;
}
function funcTypeEquals(tA, tB) {
  if (tA.kind !== "Function" || tB.kind !== "Function") {
    return false;
  }
  return typeEquals(tA.return, tB.return);
}
function phiTypeEquals(tA, tB) {
  if (tA.kind === "Phi" && tB.kind === "Phi") {
    if (tA.operands.length !== tB.operands.length) {
      return false;
    }
    let operands = new Set(tA.operands);
    for (let i = 0; i < tB.operands.length; i++) {
      if (!operands.has(tB.operands[i])) {
        return false;
      }
    }
  }
  return false;
}
const GeneratedSource = Symbol();
var GotoVariant;
(function (GotoVariant) {
  GotoVariant["Break"] = "Break";
  GotoVariant["Continue"] = "Continue";
  GotoVariant["Try"] = "Try";
})(GotoVariant || (GotoVariant = {}));
var InstructionKind;
(function (InstructionKind) {
  InstructionKind["Const"] = "Const";
  InstructionKind["Let"] = "Let";
  InstructionKind["Reassign"] = "Reassign";
  InstructionKind["Catch"] = "Catch";
  InstructionKind["HoistedConst"] = "HoistedConst";
})(InstructionKind || (InstructionKind = {}));
function makeIdentifierName(name) {
  CompilerError.invariant(t__namespace.isValidIdentifier(name), {
    reason: `Expected a valid identifier name`,
    loc: GeneratedSource,
    description: `'${name}' is not a valid JavaScript identifier`,
    suggestions: null,
  });
  return { kind: "named", value: name };
}
function promoteTemporary(identifier) {
  CompilerError.invariant(identifier.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, '${identifier.name}'`,
    suggestions: null,
  });
  identifier.name = { kind: "promoted", value: `#t${identifier.id}` };
}
function isPromotedTemporary(name) {
  return name.startsWith("#t");
}
function promoteTemporaryJsxTag(identifier) {
  CompilerError.invariant(identifier.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, '${identifier.name}'`,
    suggestions: null,
  });
  identifier.name = { kind: "promoted", value: `#T${identifier.id}` };
}
function isPromotedJsxTemporary(name) {
  return name.startsWith("#T");
}
var ValueReason;
(function (ValueReason) {
  ValueReason["Global"] = "global";
  ValueReason["JsxCaptured"] = "jsx-captured";
  ValueReason["KnownReturnSignature"] = "known-return-signature";
  ValueReason["Context"] = "context";
  ValueReason["State"] = "state";
  ValueReason["ReactiveFunctionArgument"] = "reactive-function-argument";
  ValueReason["Other"] = "other";
})(ValueReason || (ValueReason = {}));
exports.ValueKind = void 0;
(function (ValueKind) {
  ValueKind["MaybeFrozen"] = "maybefrozen";
  ValueKind["Frozen"] = "frozen";
  ValueKind["Immutable"] = "immutable";
  ValueKind["Mutable"] = "mutable";
  ValueKind["Context"] = "context";
})(exports.ValueKind || (exports.ValueKind = {}));
exports.Effect = void 0;
(function (Effect) {
  Effect["Unknown"] = "<unknown>";
  Effect["Freeze"] = "freeze";
  Effect["Read"] = "read";
  Effect["Capture"] = "capture";
  Effect["ConditionallyMutate"] = "mutate?";
  Effect["Mutate"] = "mutate";
  Effect["Store"] = "store";
})(exports.Effect || (exports.Effect = {}));
function isMutableEffect(effect, location) {
  switch (effect) {
    case exports.Effect.Capture:
    case exports.Effect.Store:
    case exports.Effect.ConditionallyMutate:
    case exports.Effect.Mutate: {
      return true;
    }
    case exports.Effect.Unknown: {
      CompilerError.invariant(false, {
        reason: "Unexpected unknown effect",
        description: null,
        loc: location,
        suggestions: null,
      });
    }
    case exports.Effect.Read:
    case exports.Effect.Freeze: {
      return false;
    }
    default: {
      assertExhaustive(effect, `Unexpected effect '${effect}'`);
    }
  }
}
function makeBlockId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeScopeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeIdentifierId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected identifier id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeInstructionId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function isObjectMethodType(id) {
  return id.type.kind == "ObjectMethod";
}
function isObjectType(id) {
  return id.type.kind === "Object";
}
function isPrimitiveType(id) {
  return id.type.kind === "Primitive";
}
function isRefValueType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInRefValue";
}
function isUseRefType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseRefId";
}
function isSetStateType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInSetState";
}
function isUseEffectHookType(id) {
  return (
    id.type.kind === "Function" && id.type.shapeId === "BuiltInUseEffectHook"
  );
}
function isUseLayoutEffectHookType(id) {
  return (
    id.type.kind === "Function" &&
    id.type.shapeId === "BuiltInUseLayoutEffectHook"
  );
}
function isUseInsertionEffectHookType(id) {
  return (
    id.type.kind === "Function" &&
    id.type.shapeId === "BuiltInUseInsertionEffectHook"
  );
}
function getHookKind(env, id) {
  return getHookKindForType(env, id.type);
}
function isUseOperator(id) {
  return (
    id.type.kind === "Function" && id.type.shapeId === "BuiltInUseOperator"
  );
}
function getHookKindForType(env, type) {
  var _a;
  if (type.kind === "Function") {
    const signature = env.getFunctionSignature(type);
    return (_a =
      signature === null || signature === void 0
        ? void 0
        : signature.hookKind) !== null && _a !== void 0
      ? _a
      : null;
  }
  return null;
}
var commonjsGlobal =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
      ? window
      : typeof global !== "undefined"
        ? global
        : typeof self !== "undefined"
          ? self
          : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default")
    ? x["default"]
    : x;
}
var lib = {};
var sourceMap$1 = {};
var sourceMap = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      "",
    );
  base64.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  base64.decode = function (charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base64 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util$2 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$2;
  hasRequiredUtil = 1;
  (function (exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp =
      /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5],
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined =
        aPath.charAt(0) === "/"
          ? aPath
          : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = (function () {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (
        s.charCodeAt(length - 1) !== 95 ||
        s.charCodeAt(length - 2) !== 95 ||
        s.charCodeAt(length - 3) !== 111 ||
        s.charCodeAt(length - 4) !== 116 ||
        s.charCodeAt(length - 5) !== 111 ||
        s.charCodeAt(length - 6) !== 114 ||
        s.charCodeAt(length - 7) !== 112 ||
        s.charCodeAt(length - 8) !== 95 ||
        s.charCodeAt(length - 9) !== 95
      ) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(
      mappingA,
      mappingB,
      onlyCompareOriginal,
    ) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(
      mappingA,
      mappingB,
      onlyCompareGenerated,
    ) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated =
      compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated =
      compareByGeneratedPositionsInflated;
  })(util$2);
  return util$2;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap
      ? this._set.size
      : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return (
      lineB > lineA ||
      (lineB == lineA && columnB >= columnA) ||
      util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
    );
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(
    aCallback,
    aThisArg,
  ) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
    aSourceMapConsumer,
  ) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot,
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn,
        },
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn,
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name,
      });
    };
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(
      aSourceMapConsumer,
      aSourceFile,
      aSourceMapPath,
    ) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
              'or the source map\'s "file" property. Both were omitted.',
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn,
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(
      aGenerated,
      aOriginal,
      aSource,
      aName,
    ) {
      if (
        aOriginal &&
        typeof aOriginal.line !== "number" &&
        typeof aOriginal.column !== "number"
      ) {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit " +
            "the original mapping entirely and only map the generated position. If so, pass " +
            "null for the original mapping instead of an object with empty or null values.",
        );
      }
      if (
        aGenerated &&
        "line" in aGenerated &&
        "column" in aGenerated &&
        aGenerated.line > 0 &&
        aGenerated.column >= 0 &&
        !aOriginal &&
        !aSource &&
        !aName
      ) {
        return;
      } else if (
        aGenerated &&
        "line" in aGenerated &&
        "column" in aGenerated &&
        aOriginal &&
        "line" in aOriginal &&
        "column" in aOriginal &&
        aGenerated.line > 0 &&
        aGenerated.column >= 0 &&
        aOriginal.line > 0 &&
        aOriginal.column >= 0 &&
        aSource
      ) {
        return;
      } else {
        throw new Error(
          "Invalid mapping: " +
            JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName,
            }),
        );
      }
    };
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (
              !util.compareByGeneratedPositionsInflated(
                mapping,
                mappings[i - 1],
              )
            ) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(
          mapping.generatedColumn - previousGeneratedColumn,
        );
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(
            mapping.originalLine - 1 - previousOriginalLine,
          );
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(
            mapping.originalColumn - previousOriginalColumn,
          );
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings(),
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(
        map.sources,
        map.sourceRoot,
      );
    }
    return map;
  };
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapConsumer = {};
var binarySearch = {};
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function (exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(
            mid,
            aHigh,
            aNeedle,
            aHaystack,
            aCompare,
            aBias,
          );
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(
            aLow,
            mid,
            aNeedle,
            aHaystack,
            aCompare,
            aBias,
          );
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND,
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  })(binarySearch);
  return binarySearch;
}
var quickSort = {};
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  quickSort.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util = requireUtil();
  var binarySearch = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }
  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    },
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    },
  });
  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings
        .map(function (mapping) {
          var source =
            mapping.source === null ? null : this._sources.at(mapping.source);
          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name),
          };
        }, this)
        .forEach(aCallback, context);
    };
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0),
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND,
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (
            mapping &&
            mapping.originalLine === line &&
            mapping.originalColumn == originalColumn
          ) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    sources = sources
      .map(String)
      .map(util.normalize)
      .map(function (source) {
        return sourceRoot &&
          util.isAbsolute(sourceRoot) &&
          util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = (smc._names = ArraySet.fromArray(
        aSourceMap._names.toArray(),
        true,
      ));
      var sources = (smc._sources = ArraySet.fromArray(
        aSourceMap._sources.toArray(),
        true,
      ));
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot,
      );
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = (smc.__generatedMappings = []);
      var destOriginalMappings = (smc.__originalMappings = []);
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    },
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(
      aNeedle,
      aMappings,
      aLineName,
      aColumnName,
      aComparator,
      aBias,
    ) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError(
          "Line must be greater than or equal to 1, got " + aNeedle[aLineName],
        );
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError(
          "Column must be greater than or equal to 0, got " +
            aNeedle[aColumnName],
        );
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column"),
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name: name,
          };
        }
      }
      return { source: null, line: null, column: null, name: null };
    };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return (
        this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) {
          return sc == null;
        })
      );
    };
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if (
          (!url.path || url.path == "/") &&
          this._sources.has("/" + aSource)
        ) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return { line: null, column: null, lastColumn: null };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column"),
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
          };
        }
      }
      return { line: null, column: null, lastColumn: null };
    };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = { line: -1, column: 0 };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (
        offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
      ) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1,
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map")),
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(
    SourceMapConsumer.prototype,
  );
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    },
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column"),
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function (needle, section) {
          var cmp =
            needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return (
            needle.generatedColumn - section.generatedOffset.generatedColumn
          );
        },
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return { source: null, line: null, column: null, name: null };
      }
      return section.consumer.originalPositionFor({
        line:
          needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column:
          needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
        bias: aArgs.bias,
      });
    };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (
          section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1
        ) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line:
              generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column:
              generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
                ? section.generatedOffset.generatedColumn - 1
                : 0),
          };
          return ret;
        }
      }
      return { line: null, column: null };
    };
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source: source,
            generatedLine:
              mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn:
              mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
                ? section.generatedOffset.generatedColumn - 1
                : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name,
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(
        this.__generatedMappings,
        util.compareByGeneratedPositionsDeflated,
      );
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}
var sourceNode = {};
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util = requireUtil();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(
      aGeneratedCode,
      aSourceMapConsumer,
      aRelativePath,
    ) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function () {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length
            ? remainingLines[remainingLinesIndex++]
            : undefined;
        }
      };
      var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(
              0,
              mapping.generatedColumn - lastGeneratedColumn,
            );
            remainingLines[remainingLinesIndex] = nextLine.substr(
              mapping.generatedColumn - lastGeneratedColumn,
            );
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(
            mapping.generatedColumn,
          );
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(
            new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name,
            ),
          );
        }
      }
    };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
          aChunk,
      );
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
          aChunk,
      );
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name,
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
    aPattern,
    aReplacement,
  ) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(
        aPattern,
        aReplacement,
      );
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
    aSourceFile,
    aSourceContent,
  ) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap =
    function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = { code: "", line: 1, column: 0 };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function (chunk, original) {
        generated.code += chunk;
        if (
          original.source !== null &&
          original.line !== null &&
          original.column !== null
        ) {
          if (
            lastOriginalSource !== original.source ||
            lastOriginalLine !== original.line ||
            lastOriginalColumn !== original.column ||
            lastOriginalName !== original.name
          ) {
            map.addMapping({
              source: original.source,
              original: { line: original.line, column: original.column },
              generated: { line: generated.line, column: generated.column },
              name: original.name,
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: { line: generated.line, column: generated.column },
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: { line: original.line, column: original.column },
                generated: { line: generated.line, column: generated.column },
                name: original.name,
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map };
    };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}
Object.defineProperty(sourceMap$1, "__esModule", { value: true });
sourceMap$1.default = void 0;
function _sourceMap$1() {
  const data = _interopRequireDefault$7(requireSourceMap());
  _sourceMap$1 = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
class SourceMap {
  constructor(opts, code) {
    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }
  get() {
    if (!this._cachedMap) {
      const map = (this._cachedMap =
        new (_sourceMap$1().default.SourceMapGenerator)({
          sourceRoot: this._opts.sourceRoot,
        }));
      const code = this._code;
      if (typeof code === "string") {
        map.setSourceContent(this._opts.sourceFileName, code);
      } else if (typeof code === "object") {
        Object.keys(code).forEach((sourceFileName) => {
          map.setSourceContent(sourceFileName, code[sourceFileName]);
        });
      }
      this._rawMappings.forEach(map.addMapping, map);
    }
    return this._cachedMap.toJSON();
  }
  getRawMappings() {
    return this._rawMappings.slice();
  }
  mark(
    generatedLine,
    generatedColumn,
    line,
    column,
    identifierName,
    filename,
    force,
  ) {
    if (this._lastGenLine !== generatedLine && line === null) return;
    if (
      !force &&
      this._lastGenLine === generatedLine &&
      this._lastSourceLine === line &&
      this._lastSourceColumn === column
    ) {
      return;
    }
    this._cachedMap = null;
    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;
    this._rawMappings.push({
      name: identifierName || undefined,
      generated: { line: generatedLine, column: generatedColumn },
      source: line == null ? undefined : filename || this._opts.sourceFileName,
      original: line == null ? undefined : { line: line, column: column },
    });
  }
}
sourceMap$1.default = SourceMap;
var printer$1 = {};
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "")
      : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal =
    typeof commonjsGlobal == "object" &&
    commonjsGlobal &&
    commonjsGlobal.Object === Object &&
    commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf =
    typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol = root.Symbol;
  _Symbol = Symbol;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol = require_Symbol(),
    getRawTag = require_getRawTag(),
    objectToString = require_objectToString();
  var nullTag = "[object Null]",
    undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
      ? getRawTag(value)
      : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(),
    isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return (
      typeof value == "symbol" ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag)
    );
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(),
    isObject = requireIsObject(),
    isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
        ? NAN
        : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0,
    MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var isInteger_1;
var hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger) return isInteger_1;
  hasRequiredIsInteger = 1;
  var toInteger = requireToInteger();
  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }
  isInteger_1 = isInteger;
  return isInteger_1;
}
var _baseRepeat;
var hasRequired_baseRepeat;
function require_baseRepeat() {
  if (hasRequired_baseRepeat) return _baseRepeat;
  hasRequired_baseRepeat = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var nativeFloor = Math.floor;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }
  _baseRepeat = baseRepeat;
  return _baseRepeat;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  eq_1 = eq;
  return eq_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(),
    isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]",
    funcTag = "[object Function]",
    genTag = "[object GeneratorFunction]",
    proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return (
      tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
    );
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return (
      typeof value == "number" &&
      value > -1 &&
      value % 1 == 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(),
    isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return (
      !!length &&
      (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(),
    isArrayLike = requireIsArrayLike(),
    isIndex = require_isIndex(),
    isObject = requireIsObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (
      type == "number"
        ? isArrayLike(object) && isIndex(index, object.length)
        : type == "string" && index in object
    ) {
      return eq(object[index], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol = require_Symbol(),
    arrayMap = require_arrayMap(),
    isArray = requireIsArray(),
    isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}
var repeat_1;
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat) return repeat_1;
  hasRequiredRepeat = 1;
  var baseRepeat = require_baseRepeat(),
    isIterateeCall = require_isIterateeCall(),
    toInteger = requireToInteger(),
    toString = requireToString();
  function repeat(string, n, guard) {
    if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
  }
  repeat_1 = repeat;
  return repeat_1;
}
var buffer = {};
var trimRight;
var hasRequiredTrimRight;
function requireTrimRight() {
  if (hasRequiredTrimRight) return trimRight;
  hasRequiredTrimRight = 1;
  trimRight = function (str) {
    var tail = str.length;
    while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
      tail--;
    }
    return str.slice(0, tail);
  };
  return trimRight;
}
Object.defineProperty(buffer, "__esModule", { value: true });
buffer.default = void 0;
function _trimRight() {
  const data = _interopRequireDefault$6(requireTrimRight());
  _trimRight = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const SPACES_RE = /^[ \t]+$/;
let Buffer$1 = class Buffer {
  constructor(map) {
    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = { line: 1, column: 0 };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null,
    };
    this._disallowedPop = null;
    this._map = map;
  }
  get() {
    this._flush();
    const map = this._map;
    const result = {
      code: (0, _trimRight().default)(this._buf.join("")),
      map: null,
      rawMappings: map && map.getRawMappings(),
    };
    if (map) {
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,
        get() {
          return (this.map = map.get());
        },
        set(value) {
          Object.defineProperty(this, "map", { value: value, writable: true });
        },
      });
    }
    return result;
  }
  append(str) {
    this._flush();
    const {
      line: line,
      column: column,
      filename: filename,
      identifierName: identifierName,
      force: force,
    } = this._sourcePosition;
    this._append(str, line, column, identifierName, filename, force);
  }
  queue(str) {
    if (str === "\n") {
      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
        this._queue.shift();
      }
    }
    const {
      line: line,
      column: column,
      filename: filename,
      identifierName: identifierName,
      force: force,
    } = this._sourcePosition;
    this._queue.unshift([str, line, column, identifierName, filename, force]);
  }
  _flush() {
    let item;
    while ((item = this._queue.pop())) this._append(...item);
  }
  _append(str, line, column, identifierName, filename, force) {
    if (this._map && str[0] !== "\n") {
      this._map.mark(
        this._position.line,
        this._position.column,
        line,
        column,
        identifierName,
        filename,
        force,
      );
    }
    this._buf.push(str);
    this._last = str[str.length - 1];
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  }
  removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
      this._queue.shift();
    }
  }
  removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ";") {
      this._queue.shift();
    }
  }
  endsWith(suffix) {
    if (suffix.length === 1) {
      let last;
      if (this._queue.length > 0) {
        const str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }
      return last === suffix;
    }
    const end =
      this._last + this._queue.reduce((acc, item) => item[0] + acc, "");
    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }
    return false;
  }
  hasContent() {
    return this._queue.length > 0 || !!this._last;
  }
  exactSource(loc, cb) {
    this.source("start", loc, true);
    cb();
    this.source("end", loc);
    this._disallowPop("start", loc);
  }
  source(prop, loc, force) {
    if (prop && !loc) return;
    this._normalizePosition(prop, loc, this._sourcePosition, force);
  }
  withSource(prop, loc, cb) {
    if (!this._map) return cb();
    const originalLine = this._sourcePosition.line;
    const originalColumn = this._sourcePosition.column;
    const originalFilename = this._sourcePosition.filename;
    const originalIdentifierName = this._sourcePosition.identifierName;
    this.source(prop, loc);
    cb();
    if (
      (!this._sourcePosition.force ||
        this._sourcePosition.line !== originalLine ||
        this._sourcePosition.column !== originalColumn ||
        this._sourcePosition.filename !== originalFilename) &&
      (!this._disallowedPop ||
        this._disallowedPop.line !== originalLine ||
        this._disallowedPop.column !== originalColumn ||
        this._disallowedPop.filename !== originalFilename)
    ) {
      this._sourcePosition.line = originalLine;
      this._sourcePosition.column = originalColumn;
      this._sourcePosition.filename = originalFilename;
      this._sourcePosition.identifierName = originalIdentifierName;
      this._sourcePosition.force = false;
      this._disallowedPop = null;
    }
  }
  _disallowPop(prop, loc) {
    if (prop && !loc) return;
    this._disallowedPop = this._normalizePosition(prop, loc);
  }
  _normalizePosition(prop, loc, targetObj, force) {
    const pos = loc ? loc[prop] : null;
    if (targetObj === undefined) {
      targetObj = {
        identifierName: null,
        line: null,
        column: null,
        filename: null,
        force: false,
      };
    }
    const origLine = targetObj.line;
    const origColumn = targetObj.column;
    const origFilename = targetObj.filename;
    targetObj.identifierName =
      (prop === "start" && loc && loc.identifierName) || null;
    targetObj.line = pos ? pos.line : null;
    targetObj.column = pos ? pos.column : null;
    targetObj.filename = (loc && loc.filename) || null;
    if (
      force ||
      targetObj.line !== origLine ||
      targetObj.column !== origColumn ||
      targetObj.filename !== origFilename
    ) {
      targetObj.force = force;
    }
    return targetObj;
  }
  getCurrentColumn() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    const lastIndex = extra.lastIndexOf("\n");
    return lastIndex === -1
      ? this._position.column + extra.length
      : extra.length - 1 - lastIndex;
  }
  getCurrentLine() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    let count = 0;
    for (let i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }
    return this._position.line + count;
  }
};
buffer.default = Buffer$1;
var node = {};
var whitespace$1 = {};
Object.defineProperty(whitespace$1, "__esModule", { value: true });
whitespace$1.list = whitespace$1.nodes = void 0;
function t$9() {
  const data = _interopRequireWildcard$a(t$a);
  t$9 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$a(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function crawl(node, state = {}) {
  if (t$9().isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t$9().isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t$9().isFunction(node)) {
    state.hasFunction = true;
  } else if (t$9().isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }
  return state;
}
function isHelper(node) {
  if (t$9().isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t$9().isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t$9().isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
    return (
      (t$9().isIdentifier(node.left) && isHelper(node.left)) ||
      isHelper(node.right)
    );
  } else {
    return false;
  }
}
function isType(node) {
  return (
    t$9().isLiteral(node) ||
    t$9().isObjectExpression(node) ||
    t$9().isArrayExpression(node) ||
    t$9().isIdentifier(node) ||
    t$9().isMemberExpression(node)
  );
}
const nodes = {
  AssignmentExpression(node) {
    const state = crawl(node.right);
    if ((state.hasCall && state.hasHelper) || state.hasFunction) {
      return { before: state.hasFunction, after: true };
    }
  },
  SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node,
      after:
        !node.consequent.length &&
        parent.cases[parent.cases.length - 1] === node,
    };
  },
  LogicalExpression(node) {
    if (t$9().isFunction(node.left) || t$9().isFunction(node.right)) {
      return { after: true };
    }
  },
  Literal(node) {
    if (node.value === "use strict") {
      return { after: true };
    }
  },
  CallExpression(node) {
    if (t$9().isFunction(node.callee) || isHelper(node)) {
      return { before: true, after: true };
    }
  },
  VariableDeclaration(node) {
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      let enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled) {
        const state = crawl(declar.init);
        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;
      }
      if (enabled) {
        return { before: true, after: true };
      }
    }
  },
  IfStatement(node) {
    if (t$9().isBlockStatement(node.consequent)) {
      return { before: true, after: true };
    }
  },
};
whitespace$1.nodes = nodes;
nodes.ObjectProperty =
  nodes.ObjectTypeProperty =
  nodes.ObjectMethod =
    function (node, parent) {
      if (parent.properties[0] === node) {
        return { before: true };
      }
    };
nodes.ObjectTypeCallProperty = function (node, parent) {
  if (
    parent.callProperties[0] === node &&
    (!parent.properties || !parent.properties.length)
  ) {
    return { before: true };
  }
};
nodes.ObjectTypeIndexer = function (node, parent) {
  if (
    parent.indexers[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length)
  ) {
    return { before: true };
  }
};
nodes.ObjectTypeInternalSlot = function (node, parent) {
  if (
    parent.internalSlots[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length) &&
    (!parent.indexers || !parent.indexers.length)
  ) {
    return { before: true };
  }
};
const list = {
  VariableDeclaration(node) {
    return node.declarations.map((decl) => decl.init);
  },
  ArrayExpression(node) {
    return node.elements;
  },
  ObjectExpression(node) {
    return node.properties;
  },
};
whitespace$1.list = list;
[
  ["Function", true],
  ["Class", true],
  ["Loop", true],
  ["LabeledStatement", true],
  ["SwitchStatement", true],
  ["TryStatement", true],
].forEach(function ([type, amounts]) {
  if (typeof amounts === "boolean") {
    amounts = { after: amounts, before: amounts };
  }
  [type].concat(t$9().FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    nodes[type] = function () {
      return amounts;
    };
  });
});
var parentheses = {};
Object.defineProperty(parentheses, "__esModule", { value: true });
parentheses.FunctionTypeAnnotation = parentheses.NullableTypeAnnotation =
  NullableTypeAnnotation;
parentheses.UpdateExpression = UpdateExpression$1;
parentheses.ObjectExpression = ObjectExpression$1;
parentheses.DoExpression = DoExpression$1;
parentheses.Binary = Binary;
parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation =
  UnionTypeAnnotation;
parentheses.TSAsExpression = TSAsExpression$1;
parentheses.TSTypeAssertion = TSTypeAssertion$1;
parentheses.BinaryExpression = BinaryExpression;
parentheses.SequenceExpression = SequenceExpression$1;
parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression$1;
parentheses.ClassExpression = ClassExpression;
parentheses.UnaryLike = UnaryLike;
parentheses.FunctionExpression = FunctionExpression$1;
parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1;
parentheses.ConditionalExpression = ConditionalExpression$1;
parentheses.OptionalMemberExpression = OptionalMemberExpression$1;
parentheses.AssignmentExpression = AssignmentExpression$1;
parentheses.NewExpression = NewExpression$1;
function t$8() {
  const data = _interopRequireWildcard$9(t$a);
  t$8 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$9(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
const PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10,
};
const isClassExtendsClause = (node, parent) =>
  (t$8().isClassDeclaration(parent) || t$8().isClassExpression(parent)) &&
  parent.superClass === node;
function NullableTypeAnnotation(node, parent) {
  return t$8().isArrayTypeAnnotation(parent);
}
function UpdateExpression$1(node, parent) {
  return (
    t$8().isMemberExpression(parent, { object: node }) ||
    t$8().isCallExpression(parent, { callee: node }) ||
    t$8().isNewExpression(parent, { callee: node }) ||
    isClassExtendsClause(node, parent)
  );
}
function ObjectExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerArrow: true });
}
function DoExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack);
}
function Binary(node, parent) {
  if (
    node.operator === "**" &&
    t$8().isBinaryExpression(parent, { operator: "**" })
  ) {
    return parent.left === node;
  }
  if (isClassExtendsClause(node, parent)) {
    return true;
  }
  if (
    ((t$8().isCallExpression(parent) || t$8().isNewExpression(parent)) &&
      parent.callee === node) ||
    t$8().isUnaryLike(parent) ||
    (t$8().isMemberExpression(parent) && parent.object === node) ||
    t$8().isAwaitExpression(parent)
  ) {
    return true;
  }
  if (t$8().isBinary(parent)) {
    const parentOp = parent.operator;
    const parentPos = PRECEDENCE[parentOp];
    const nodeOp = node.operator;
    const nodePos = PRECEDENCE[nodeOp];
    if (
      (parentPos === nodePos &&
        parent.right === node &&
        !t$8().isLogicalExpression(parent)) ||
      parentPos > nodePos
    ) {
      return true;
    }
  }
  return false;
}
function UnionTypeAnnotation(node, parent) {
  return (
    t$8().isArrayTypeAnnotation(parent) ||
    t$8().isNullableTypeAnnotation(parent) ||
    t$8().isIntersectionTypeAnnotation(parent) ||
    t$8().isUnionTypeAnnotation(parent)
  );
}
function TSAsExpression$1() {
  return true;
}
function TSTypeAssertion$1() {
  return true;
}
function BinaryExpression(node, parent) {
  return (
    node.operator === "in" &&
    (t$8().isVariableDeclarator(parent) || t$8().isFor(parent))
  );
}
function SequenceExpression$1(node, parent) {
  if (
    t$8().isForStatement(parent) ||
    t$8().isThrowStatement(parent) ||
    t$8().isReturnStatement(parent) ||
    (t$8().isIfStatement(parent) && parent.test === node) ||
    (t$8().isWhileStatement(parent) && parent.test === node) ||
    (t$8().isForInStatement(parent) && parent.right === node) ||
    (t$8().isSwitchStatement(parent) && parent.discriminant === node) ||
    (t$8().isExpressionStatement(parent) && parent.expression === node)
  ) {
    return false;
  }
  return true;
}
function YieldExpression$1(node, parent) {
  return (
    t$8().isBinary(parent) ||
    t$8().isUnaryLike(parent) ||
    t$8().isCallExpression(parent) ||
    t$8().isMemberExpression(parent) ||
    t$8().isNewExpression(parent) ||
    (t$8().isAwaitExpression(parent) && t$8().isYieldExpression(node)) ||
    (t$8().isConditionalExpression(parent) && node === parent.test) ||
    isClassExtendsClause(node, parent)
  );
}
function ClassExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
function UnaryLike(node, parent) {
  return (
    t$8().isMemberExpression(parent, { object: node }) ||
    t$8().isCallExpression(parent, { callee: node }) ||
    t$8().isNewExpression(parent, { callee: node }) ||
    t$8().isBinaryExpression(parent, { operator: "**", left: node }) ||
    isClassExtendsClause(node, parent)
  );
}
function FunctionExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
function ArrowFunctionExpression$1(node, parent) {
  return (
    t$8().isExportDeclaration(parent) || ConditionalExpression$1(node, parent)
  );
}
function ConditionalExpression$1(node, parent) {
  if (
    t$8().isUnaryLike(parent) ||
    t$8().isBinary(parent) ||
    t$8().isConditionalExpression(parent, { test: node }) ||
    t$8().isAwaitExpression(parent) ||
    t$8().isOptionalMemberExpression(parent) ||
    t$8().isTaggedTemplateExpression(parent) ||
    t$8().isTSTypeAssertion(parent) ||
    t$8().isTSAsExpression(parent)
  ) {
    return true;
  }
  return UnaryLike(node, parent);
}
function OptionalMemberExpression$1(node, parent) {
  return t$8().isCallExpression(parent) || t$8().isMemberExpression(parent);
}
function AssignmentExpression$1(node) {
  if (t$8().isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression$1(...arguments);
  }
}
function NewExpression$1(node, parent) {
  return isClassExtendsClause(node, parent);
}
function isFirstInStatement(
  printStack,
  {
    considerArrow: considerArrow = false,
    considerDefaultExports: considerDefaultExports = false,
  } = {},
) {
  let i = printStack.length - 1;
  let node = printStack[i];
  i--;
  let parent = printStack[i];
  while (i > 0) {
    if (
      t$8().isExpressionStatement(parent, { expression: node }) ||
      t$8().isTaggedTemplateExpression(parent) ||
      (considerDefaultExports &&
        t$8().isExportDefaultDeclaration(parent, { declaration: node })) ||
      (considerArrow && t$8().isArrowFunctionExpression(parent, { body: node }))
    ) {
      return true;
    }
    if (
      t$8().isCallExpression(parent, { callee: node }) ||
      (t$8().isSequenceExpression(parent) && parent.expressions[0] === node) ||
      t$8().isMemberExpression(parent, { object: node }) ||
      t$8().isConditional(parent, { test: node }) ||
      t$8().isBinary(parent, { left: node }) ||
      t$8().isAssignmentExpression(parent, { left: node })
    ) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }
  return false;
}
Object.defineProperty(node, "__esModule", { value: true });
node.needsWhitespace = needsWhitespace;
node.needsWhitespaceBefore = needsWhitespaceBefore;
node.needsWhitespaceAfter = needsWhitespaceAfter;
node.needsParens = needsParens;
var whitespace = _interopRequireWildcard$8(whitespace$1);
var parens = _interopRequireWildcard$8(parentheses);
function t$7() {
  const data = _interopRequireWildcard$8(t$a);
  t$7 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$8(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function expandAliases(obj) {
  const newObj = {};
  function add(type, func) {
    const fn = newObj[type];
    newObj[type] = fn
      ? function (node, parent, stack) {
          const result = fn(node, parent, stack);
          return result == null ? func(node, parent, stack) : result;
        }
      : func;
  }
  for (const type of Object.keys(obj)) {
    const aliases = t$7().FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (const alias of aliases) {
        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }
  return newObj;
}
const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
const expandedWhitespaceList = expandAliases(whitespace.list);
function find(obj, node, parent, printStack) {
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}
function isOrHasCallExpression(node) {
  if (t$7().isCallExpression(node)) {
    return true;
  }
  if (t$7().isMemberExpression(node)) {
    return (
      isOrHasCallExpression(node.object) ||
      (!node.computed && isOrHasCallExpression(node.property))
    );
  } else {
    return false;
  }
}
function needsWhitespace(node, parent, type) {
  if (!node) return 0;
  if (t$7().isExpressionStatement(node)) {
    node = node.expression;
  }
  let linesInfo = find(expandedWhitespaceNodes, node, parent);
  if (!linesInfo) {
    const items = find(expandedWhitespaceList, node, parent);
    if (items) {
      for (let i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }
  if (typeof linesInfo === "object" && linesInfo !== null) {
    return linesInfo[type] || 0;
  }
  return 0;
}
function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}
function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}
function needsParens(node, parent, printStack) {
  if (!parent) return false;
  if (t$7().isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }
  return find(expandedParens, node, parent, printStack);
}
var generators = {};
var templateLiterals = {};
Object.defineProperty(templateLiterals, "__esModule", { value: true });
templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
templateLiterals.TemplateElement = TemplateElement;
templateLiterals.TemplateLiteral = TemplateLiteral;
function TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.typeParameters, node);
  this.print(node.quasi, node);
}
function TemplateElement(node, parent) {
  const isFirst = parent.quasis[0] === node;
  const isLast = parent.quasis[parent.quasis.length - 1] === node;
  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
  this.token(value);
}
function TemplateLiteral(node) {
  const quasis = node.quasis;
  for (let i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);
    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}
var expressions = {};
Object.defineProperty(expressions, "__esModule", { value: true });
expressions.UnaryExpression = UnaryExpression;
expressions.DoExpression = DoExpression;
expressions.ParenthesizedExpression = ParenthesizedExpression;
expressions.UpdateExpression = UpdateExpression;
expressions.ConditionalExpression = ConditionalExpression;
expressions.NewExpression = NewExpression;
expressions.SequenceExpression = SequenceExpression;
expressions.ThisExpression = ThisExpression;
expressions.Super = Super;
expressions.Decorator = Decorator;
expressions.OptionalMemberExpression = OptionalMemberExpression;
expressions.OptionalCallExpression = OptionalCallExpression;
expressions.CallExpression = CallExpression;
expressions.Import = Import;
expressions.EmptyStatement = EmptyStatement;
expressions.ExpressionStatement = ExpressionStatement;
expressions.AssignmentPattern = AssignmentPattern;
expressions.LogicalExpression =
  expressions.BinaryExpression =
  expressions.AssignmentExpression =
    AssignmentExpression;
expressions.BindExpression = BindExpression;
expressions.MemberExpression = MemberExpression;
expressions.MetaProperty = MetaProperty;
expressions.PrivateName = PrivateName;
expressions.AwaitExpression = expressions.YieldExpression = void 0;
function t$6() {
  const data = _interopRequireWildcard$7(t$a);
  t$6 = function () {
    return data;
  };
  return data;
}
var n$1 = _interopRequireWildcard$7(node);
function _interopRequireWildcard$7(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function UnaryExpression(node) {
  if (
    node.operator === "void" ||
    node.operator === "delete" ||
    node.operator === "typeof" ||
    node.operator === "throw"
  ) {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }
  this.print(node.argument, node);
}
function DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}
function ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}
function UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.startTerminatorless(true);
    this.print(node.argument, node);
    this.endTerminatorless();
    this.token(node.operator);
  }
}
function ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}
function NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);
  if (
    this.format.minified &&
    node.arguments.length === 0 &&
    !node.optional &&
    !t$6().isCallExpression(parent, { callee: node }) &&
    !t$6().isMemberExpression(parent) &&
    !t$6().isNewExpression(parent)
  ) {
    return;
  }
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function SequenceExpression(node) {
  this.printList(node.expressions, node);
}
function ThisExpression() {
  this.word("this");
}
function Super() {
  this.word("super");
}
function Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}
function OptionalMemberExpression(node) {
  this.print(node.object, node);
  if (!node.computed && t$6().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (
    t$6().isLiteral(node.property) &&
    typeof node.property.value === "number"
  ) {
    computed = true;
  }
  if (node.optional) {
    this.token("?.");
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    if (!node.optional) {
      this.token(".");
    }
    this.print(node.property, node);
  }
}
function OptionalCallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function CallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function Import() {
  this.word("import");
}
function buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);
    if (node.delegate) {
      this.token("*");
    }
    if (node.argument) {
      this.space();
      const terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}
const YieldExpression = buildYieldAwait("yield");
expressions.YieldExpression = YieldExpression;
const AwaitExpression = buildYieldAwait("await");
expressions.AwaitExpression = AwaitExpression;
function EmptyStatement() {
  this.semicolon(true);
}
function ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}
function AssignmentPattern(node) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}
function AssignmentExpression(node, parent) {
  const parens =
    this.inForStatementInitCounter &&
    node.operator === "in" &&
    !n$1.needsParens(node, parent);
  if (parens) {
    this.token("(");
  }
  this.print(node.left, node);
  this.space();
  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }
  this.space();
  this.print(node.right, node);
  if (parens) {
    this.token(")");
  }
}
function BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}
function MemberExpression(node) {
  this.print(node.object, node);
  if (!node.computed && t$6().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (
    t$6().isLiteral(node.property) &&
    typeof node.property.value === "number"
  ) {
    computed = true;
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}
function MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}
function PrivateName(node) {
  this.token("#");
  this.print(node.id, node);
}
var statements = {};
Object.defineProperty(statements, "__esModule", { value: true });
statements.WithStatement = WithStatement;
statements.IfStatement = IfStatement;
statements.ForStatement = ForStatement;
statements.WhileStatement = WhileStatement;
statements.DoWhileStatement = DoWhileStatement;
statements.LabeledStatement = LabeledStatement;
statements.TryStatement = TryStatement;
statements.CatchClause = CatchClause;
statements.SwitchStatement = SwitchStatement;
statements.SwitchCase = SwitchCase;
statements.DebuggerStatement = DebuggerStatement;
statements.VariableDeclaration = VariableDeclaration;
statements.VariableDeclarator = VariableDeclarator;
statements.ThrowStatement =
  statements.BreakStatement =
  statements.ReturnStatement =
  statements.ContinueStatement =
  statements.ForOfStatement =
  statements.ForInStatement =
    void 0;
function t$5() {
  const data = _interopRequireWildcard$6(t$a);
  t$5 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$6(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}
function IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();
  const needsBlock =
    node.alternate && t$5().isIfStatement(getLastStatement(node.consequent));
  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }
  this.printAndIndentOnComments(node.consequent, node);
  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }
  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}
function getLastStatement(statement) {
  if (!t$5().isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}
function ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");
  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");
  if (node.test) {
    this.space();
    this.print(node.test, node);
  }
  this.token(";");
  if (node.update) {
    this.space();
    this.print(node.update, node);
  }
  this.token(")");
  this.printBlock(node);
}
function WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}
const buildForXStatement = function (op) {
  return function (node) {
    this.word("for");
    this.space();
    if (op === "of" && node.await) {
      this.word("await");
      this.space();
    }
    this.token("(");
    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};
const ForInStatement = buildForXStatement("in");
statements.ForInStatement = ForInStatement;
const ForOfStatement = buildForXStatement("of");
statements.ForOfStatement = ForOfStatement;
function DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}
function buildLabelStatement(prefix, key = "label") {
  return function (node) {
    this.word(prefix);
    const label = node[key];
    if (label) {
      this.space();
      const isLabel = key == "label";
      const terminatorState = this.startTerminatorless(isLabel);
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }
    this.semicolon();
  };
}
const ContinueStatement = buildLabelStatement("continue");
statements.ContinueStatement = ContinueStatement;
const ReturnStatement = buildLabelStatement("return", "argument");
statements.ReturnStatement = ReturnStatement;
const BreakStatement = buildLabelStatement("break");
statements.BreakStatement = BreakStatement;
const ThrowStatement = buildLabelStatement("throw", "argument");
statements.ThrowStatement = ThrowStatement;
function LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}
function TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();
  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }
  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}
function CatchClause(node) {
  this.word("catch");
  this.space();
  if (node.param) {
    this.token("(");
    this.print(node.param, node);
    this.token(")");
    this.space();
  }
  this.print(node.body, node);
}
function SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");
  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    },
  });
  this.token("}");
}
function SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }
  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, { indent: true });
  }
}
function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}
function variableDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
}
function constDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
}
function VariableDeclaration(node, parent) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  this.word(node.kind);
  this.space();
  let hasInits = false;
  if (!t$5().isFor(parent)) {
    for (const declar of node.declarations) {
      if (declar.init) {
        hasInits = true;
      }
    }
  }
  let separator;
  if (hasInits) {
    separator =
      node.kind === "const"
        ? constDeclarationIndent
        : variableDeclarationIndent;
  }
  this.printList(node.declarations, node, { separator: separator });
  if (t$5().isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }
  this.semicolon();
}
function VariableDeclarator(node) {
  this.print(node.id, node);
  if (node.definite) this.token("!");
  this.print(node.id.typeAnnotation, node);
  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}
var classes = {};
Object.defineProperty(classes, "__esModule", { value: true });
classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
classes.ClassBody = ClassBody;
classes.ClassProperty = ClassProperty;
classes.ClassPrivateProperty = ClassPrivateProperty;
classes.ClassMethod = ClassMethod;
classes.ClassPrivateMethod = ClassPrivateMethod;
classes._classMethodHead = _classMethodHead;
function t$4() {
  const data = _interopRequireWildcard$5(t$a);
  t$4 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$5(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function ClassDeclaration(node, parent) {
  if (
    !this.format.decoratorsBeforeExport ||
    (!t$4().isExportDefaultDeclaration(parent) &&
      !t$4().isExportNamedDeclaration(parent))
  ) {
    this.printJoin(node.decorators, node);
  }
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  this.word("class");
  if (node.id) {
    this.space();
    this.print(node.id, node);
  }
  this.print(node.typeParameters, node);
  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }
  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }
  this.space();
  this.print(node.body, node);
}
function ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();
    this.indent();
    this.printSequence(node.body, node);
    this.dedent();
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  }
}
function ClassProperty(node) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  if (node.readonly) {
    this.word("readonly");
    this.space();
  }
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);
    this.print(node.key, node);
  }
  if (node.optional) {
    this.token("?");
  }
  if (node.definite) {
    this.token("!");
  }
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
function ClassPrivateProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.key, node);
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
function ClassMethod(node) {
  this._classMethodHead(node);
  this.space();
  this.print(node.body, node);
}
function ClassPrivateMethod(node) {
  this._classMethodHead(node);
  this.space();
  this.print(node.body, node);
}
function _classMethodHead(node) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._methodHead(node);
}
var methods = {};
Object.defineProperty(methods, "__esModule", { value: true });
methods._params = _params;
methods._parameters = _parameters;
methods._param = _param;
methods._methodHead = _methodHead;
methods._predicate = _predicate;
methods._functionHead = _functionHead;
methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
methods.ArrowFunctionExpression = ArrowFunctionExpression;
function t$3() {
  const data = _interopRequireWildcard$4(t$a);
  t$3 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$4(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _params(node) {
  this.print(node.typeParameters, node);
  this.token("(");
  this._parameters(node.params, node);
  this.token(")");
  this.print(node.returnType, node);
}
function _parameters(parameters, parent) {
  for (let i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent);
    if (i < parameters.length - 1) {
      this.token(",");
      this.space();
    }
  }
}
function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter);
  this.print(parameter, parent);
  if (parameter.optional) this.token("?");
  this.print(parameter.typeAnnotation, parameter);
}
function _methodHead(node) {
  const kind = node.kind;
  const key = node.key;
  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }
  if (node.async) {
    this.word("async");
    this.space();
  }
  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }
  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }
  if (node.optional) {
    this.token("?");
  }
  this._params(node);
}
function _predicate(node) {
  if (node.predicate) {
    if (!node.returnType) {
      this.token(":");
    }
    this.space();
    this.print(node.predicate, node);
  }
}
function _functionHead(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  this.word("function");
  if (node.generator) this.token("*");
  this.space();
  if (node.id) {
    this.print(node.id, node);
  }
  this._params(node);
  this._predicate(node);
}
function FunctionExpression(node) {
  this._functionHead(node);
  this.space();
  this.print(node.body, node);
}
function ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  const firstParam = node.params[0];
  if (
    node.params.length === 1 &&
    t$3().isIdentifier(firstParam) &&
    !hasTypes(node, firstParam)
  ) {
    if (
      this.format.retainLines &&
      node.loc &&
      node.body.loc &&
      node.loc.start.line < node.body.loc.start.line
    ) {
      this.token("(");
      if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
        this.indent();
        this.print(firstParam, node);
        this.dedent();
        this._catchUp("start", node.body.loc);
      } else {
        this.print(firstParam, node);
      }
      this.token(")");
    } else {
      this.print(firstParam, node);
    }
  } else {
    this._params(node);
  }
  this._predicate(node);
  this.space();
  this.token("=>");
  this.space();
  this.print(node.body, node);
}
function hasTypes(node, param) {
  return (
    node.typeParameters ||
    node.returnType ||
    param.typeAnnotation ||
    param.optional ||
    param.trailingComments
  );
}
var modules = {};
Object.defineProperty(modules, "__esModule", { value: true });
modules.ImportSpecifier = ImportSpecifier;
modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
modules.ExportSpecifier = ExportSpecifier;
modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
modules.ExportAllDeclaration = ExportAllDeclaration;
modules.ExportNamedDeclaration = ExportNamedDeclaration;
modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
modules.ImportDeclaration = ImportDeclaration;
modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
function t$2() {
  const data = _interopRequireWildcard$3(t$a);
  t$2 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$3(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function ImportSpecifier(node) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  this.print(node.imported, node);
  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}
function ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}
function ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}
function ExportSpecifier(node) {
  this.print(node.local, node);
  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}
function ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}
function ExportAllDeclaration(node) {
  this.word("export");
  this.space();
  if (node.exportKind === "type") {
    this.word("type");
    this.space();
  }
  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}
function ExportNamedDeclaration(node) {
  if (
    this.format.decoratorsBeforeExport &&
    t$2().isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
function ExportDefaultDeclaration(node) {
  if (
    this.format.decoratorsBeforeExport &&
    t$2().isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
function ExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t$2().isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    const specifiers = node.specifiers.slice(0);
    let hasSpecial = false;
    while (true) {
      const first = specifiers[0];
      if (
        t$2().isExportDefaultSpecifier(first) ||
        t$2().isExportNamespaceSpecifier(first)
      ) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length || (!specifiers.length && !hasSpecial)) {
      this.token("{");
      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }
      this.token("}");
    }
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }
    this.semicolon();
  }
}
function ImportDeclaration(node) {
  this.word("import");
  this.space();
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  const specifiers = node.specifiers.slice(0);
  if (specifiers && specifiers.length) {
    while (true) {
      const first = specifiers[0];
      if (
        t$2().isImportDefaultSpecifier(first) ||
        t$2().isImportNamespaceSpecifier(first)
      ) {
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }
    this.space();
    this.word("from");
    this.space();
  }
  this.print(node.source, node);
  this.semicolon();
}
function ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}
var types = {};
var jsesc_1;
var hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object = {};
  const hasOwnProperty = object.hasOwnProperty;
  const forOwn = (object, callback) => {
    for (const key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };
  const extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };
  const forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  const toString = object.toString;
  const isArray = Array.isArray;
  const isBuffer = Buffer.isBuffer;
  const isObject = (value) => toString.call(value) == "[object Object]";
  const isString = (value) =>
    typeof value == "string" || toString.call(value) == "[object String]";
  const isNumber = (value) =>
    typeof value == "number" || toString.call(value) == "[object Number]";
  const isFunction = (value) => typeof value == "function";
  const isMap = (value) => toString.call(value) == "[object Map]";
  const isSet = (value) => toString.call(value) == "[object Set]";
  const singleEscapes = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
  };
  const regexSingleEscape = /["'\\\b\f\n\r\t]/;
  const regexDigit = /[0-9]/;
  const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
  const jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    const defaults = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: "single",
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: "decimal",
      indent: "\t",
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false,
    };
    const json = options && options.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (
      options.quotes != "single" &&
      options.quotes != "double" &&
      options.quotes != "backtick"
    ) {
      options.quotes = "single";
    }
    const quote =
      options.quotes == "double"
        ? '"'
        : options.quotes == "backtick"
          ? "`"
          : "'";
    const compact = options.compact;
    const lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel);
    let oldIndent = "";
    const inline1 = options.__inline1__;
    const inline2 = options.__inline2__;
    const newLine = compact ? "" : "\n";
    let result;
    let isEmpty = true;
    const useBinNumbers = options.numbers == "binary";
    const useOctNumbers = options.numbers == "octal";
    const useDecNumbers = options.numbers == "decimal";
    const useHexNumbers = options.numbers == "hexadecimal";
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value) => {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push(
            (compact || inline2 ? "" : indent) + jsesc(value, options),
          );
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return (
          "[" +
          newLine +
          result.join("," + newLine) +
          newLine +
          (compact ? "" : oldIndent) +
          "]"
        );
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }
        if (useDecNumbers) {
          return String(argument);
        }
        if (useHexNumbers) {
          let hexadecimal = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }
          return "0x" + hexadecimal;
        }
        if (useBinNumbers) {
          return "0b" + argument.toString(2);
        }
        if (useOctNumbers) {
          return "0o" + argument.toString(8);
        }
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push(
            (compact ? "" : indent) +
              jsesc(key, options) +
              ":" +
              (compact ? "" : " ") +
              jsesc(value, options),
          );
        });
        if (isEmpty) {
          return "{}";
        }
        return (
          "{" +
          newLine +
          result.join("," + newLine) +
          newLine +
          (compact ? "" : oldIndent) +
          "}"
        );
      }
    }
    const string = argument;
    let index = -1;
    const length = string.length;
    result = "";
    while (++index < length) {
      const character = string.charAt(index);
      if (options.es6) {
        const first = string.charCodeAt(index);
        if (first >= 55296 && first <= 56319 && length > index + 1) {
          const second = string.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            let hexadecimal = codePoint.toString(16);
            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }
            result += "\\u{" + hexadecimal + "}";
            ++index;
            continue;
          }
        }
      }
      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }
        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }
        if (character == "`") {
          result += quote == character ? "\\`" : character;
          continue;
        }
        if (character == "'") {
          result += quote == character ? "\\'" : character;
          continue;
        }
      }
      if (
        character == "\0" &&
        !json &&
        !regexDigit.test(string.charAt(index + 1))
      ) {
        result += "\\0";
        continue;
      }
      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }
      const charCode = character.charCodeAt(0);
      if (options.minimal && charCode != 8232 && charCode != 8233) {
        result += character;
        continue;
      }
      let hexadecimal = charCode.toString(16);
      if (!lowercaseHex) {
        hexadecimal = hexadecimal.toUpperCase();
      }
      const longhand = hexadecimal.length > 2 || json;
      const escaped =
        "\\" +
        (longhand ? "u" : "x") +
        ("0000" + hexadecimal).slice(longhand ? -4 : -2);
      result += escaped;
      continue;
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options.isScriptContext) {
      return result
        .replace(/<\/(script|style)/gi, "<\\/$1")
        .replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    return result;
  };
  jsesc.version = "2.5.2";
  jsesc_1 = jsesc;
  return jsesc_1;
}
Object.defineProperty(types, "__esModule", { value: true });
types.Identifier = Identifier;
types.SpreadElement = types.RestElement = RestElement;
types.ObjectPattern = types.ObjectExpression = ObjectExpression;
types.ObjectMethod = ObjectMethod;
types.ObjectProperty = ObjectProperty;
types.ArrayPattern = types.ArrayExpression = ArrayExpression;
types.RegExpLiteral = RegExpLiteral;
types.BooleanLiteral = BooleanLiteral;
types.NullLiteral = NullLiteral;
types.NumericLiteral = NumericLiteral;
types.StringLiteral = StringLiteral;
types.BigIntLiteral = BigIntLiteral;
function t$1() {
  const data = _interopRequireWildcard$2(t$a);
  t$1 = function () {
    return data;
  };
  return data;
}
function _jsesc() {
  const data = _interopRequireDefault$5(requireJsesc());
  _jsesc = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _interopRequireWildcard$2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function Identifier(node) {
  this.exactSource(node.loc, () => {
    this.word(node.name);
  });
}
function RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}
function ObjectExpression(node) {
  const props = node.properties;
  this.token("{");
  this.printInnerComments(node);
  if (props.length) {
    this.space();
    this.printList(props, node, { indent: true, statement: true });
    this.space();
  }
  this.token("}");
}
function ObjectMethod(node) {
  this.printJoin(node.decorators, node);
  this._methodHead(node);
  this.space();
  this.print(node.body, node);
}
function ObjectProperty(node) {
  this.printJoin(node.decorators, node);
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (
      t$1().isAssignmentPattern(node.value) &&
      t$1().isIdentifier(node.key) &&
      node.key.name === node.value.left.name
    ) {
      this.print(node.value, node);
      return;
    }
    this.print(node.key, node);
    if (
      node.shorthand &&
      t$1().isIdentifier(node.key) &&
      t$1().isIdentifier(node.value) &&
      node.key.name === node.value.name
    ) {
      return;
    }
  }
  this.token(":");
  this.space();
  this.print(node.value, node);
}
function ArrayExpression(node) {
  const elems = node.elements;
  const len = elems.length;
  this.token("[");
  this.printInnerComments(node);
  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i];
    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }
  this.token("]");
}
function RegExpLiteral(node) {
  this.word(`/${node.pattern}/${node.flags}`);
}
function BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}
function NullLiteral() {
  this.word("null");
}
function NumericLiteral(node) {
  const raw = this.getPossibleRaw(node);
  const value = node.value + "";
  if (raw == null) {
    this.number(value);
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}
function StringLiteral(node) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  const opts = this.format.jsescOption;
  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }
  const val = (0, _jsesc().default)(node.value, opts);
  return this.token(val);
}
function BigIntLiteral(node) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  this.token(node.value);
}
var flow = {};
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnyTypeAnnotation = AnyTypeAnnotation;
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
  exports.DeclareClass = DeclareClass;
  exports.DeclareFunction = DeclareFunction;
  exports.InferredPredicate = InferredPredicate;
  exports.DeclaredPredicate = DeclaredPredicate;
  exports.DeclareInterface = DeclareInterface;
  exports.DeclareModule = DeclareModule;
  exports.DeclareModuleExports = DeclareModuleExports;
  exports.DeclareTypeAlias = DeclareTypeAlias;
  exports.DeclareOpaqueType = DeclareOpaqueType;
  exports.DeclareVariable = DeclareVariable;
  exports.DeclareExportDeclaration = DeclareExportDeclaration;
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.FunctionTypeParam = FunctionTypeParam;
  exports.GenericTypeAnnotation =
    exports.ClassImplements =
    exports.InterfaceExtends =
      InterfaceExtends;
  exports._interfaceish = _interfaceish;
  exports._variance = _variance;
  exports.InterfaceDeclaration = InterfaceDeclaration;
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
  exports.MixedTypeAnnotation = MixedTypeAnnotation;
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  exports.NumberTypeAnnotation = NumberTypeAnnotation;
  exports.StringTypeAnnotation = StringTypeAnnotation;
  exports.ThisTypeAnnotation = ThisTypeAnnotation;
  exports.TupleTypeAnnotation = TupleTypeAnnotation;
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
  exports.TypeAlias = TypeAlias;
  exports.TypeAnnotation = TypeAnnotation;
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation =
    TypeParameterInstantiation;
  exports.TypeParameter = TypeParameter;
  exports.OpaqueType = OpaqueType;
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
  exports.ObjectTypeIndexer = ObjectTypeIndexer;
  exports.ObjectTypeProperty = ObjectTypeProperty;
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
  exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.TypeCastExpression = TypeCastExpression;
  exports.Variance = Variance;
  exports.VoidTypeAnnotation = VoidTypeAnnotation;
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.NumericLiteral;
    },
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.StringLiteral;
    },
  });
  function t() {
    const data = _interopRequireWildcard(t$a);
    t = function () {
      return data;
    };
    return data;
  }
  var _modules = modules;
  var _types2 = types;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc =
              Object.defineProperty && Object.getOwnPropertyDescriptor
                ? Object.getOwnPropertyDescriptor(obj, key)
                : {};
            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("class");
    this.space();
    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);
    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }
    this.semicolon();
  }
  function InferredPredicate() {
    this.token("%");
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();
    if (node.default) {
      this.word("default");
      this.space();
    }
    FlowExportDeclaration.apply(this, arguments);
  }
  function DeclareExportAllDeclaration() {
    this.word("declare");
    this.space();
    _modules.ExportAllDeclaration.apply(this, arguments);
  }
  function FlowExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node);
      if (!t().isStatement(declar)) this.semicolon();
    } else {
      this.token("{");
      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }
      this.token("}");
      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }
      this.semicolon();
    }
  }
  function ExistsTypeAnnotation() {
    this.token("*");
  }
  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.params, node);
    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }
      this.token("...");
      this.print(node.rest, node);
    }
    this.token(")");
    if (
      parent.type === "ObjectTypeCallProperty" ||
      parent.type === "DeclareFunction" ||
      (parent.type === "ObjectTypeProperty" && parent.method)
    ) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }
    this.space();
    this.print(node.returnType, node);
  }
  function FunctionTypeParam(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");
    if (node.name) {
      this.token(":");
      this.space();
    }
    this.print(node.typeAnnotation, node);
  }
  function InterfaceExtends(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }
  function _interfaceish(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    if (node.extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }
    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }
    if (node.implements && node.implements.length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements, node);
    }
    this.space();
    this.print(node.body, node);
  }
  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();
    this._interfaceish(node);
  }
  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }
  function InterfaceTypeAnnotation(node) {
    this.word("interface");
    if (node.extends && node.extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }
    this.space();
    this.print(node.body, node);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, node, { separator: andSeparator });
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }
  function TypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TypeParameter(node) {
    this._variance(node);
    this.word(node.name);
    if (node.bound) {
      this.print(node.bound, node);
    }
    if (node.default) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.default, node);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }
    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }
    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }
    const props = node.properties.concat(
      node.callProperties || [],
      node.indexers || [],
      node.internalSlots || [],
    );
    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },
        indent: true,
        statement: true,
        iterator: () => {
          if (props.length !== 1) {
            this.token(",");
            this.space();
          }
        },
      });
      this.space();
    }
    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");
    if (!node.method) {
      this.token(":");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeCallProperty(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeIndexer(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.token("[");
    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }
    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }
    if (node.static) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.print(node.key, node);
    if (node.optional) this.token("?");
    if (!node.method) {
      this.token(":");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }
  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }
  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, node, { separator: orSeparator });
  }
  function TypeCastExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }
})(flow);
var base = {};
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.File = File;
  exports.Program = Program;
  exports.BlockStatement = BlockStatement;
  exports.Noop = Noop;
  exports.Directive = Directive;
  exports.InterpreterDirective = InterpreterDirective;
  Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function () {
      return _types.StringLiteral;
    },
  });
  var _types = types;
  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }
    this.print(node.program, node);
  }
  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
  function BlockStatement(node) {
    this.token("{");
    this.printInnerComments(node);
    const hasDirectives = node.directives && node.directives.length;
    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, { indent: true });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, { indent: true });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }
  function Noop() {}
  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }
  function InterpreterDirective(node) {
    this.token(`#!${node.value}\n`);
  }
})(base);
var jsx = {};
Object.defineProperty(jsx, "__esModule", { value: true });
jsx.JSXAttribute = JSXAttribute;
jsx.JSXIdentifier = JSXIdentifier;
jsx.JSXNamespacedName = JSXNamespacedName;
jsx.JSXMemberExpression = JSXMemberExpression;
jsx.JSXSpreadAttribute = JSXSpreadAttribute;
jsx.JSXExpressionContainer = JSXExpressionContainer;
jsx.JSXSpreadChild = JSXSpreadChild;
jsx.JSXText = JSXText;
jsx.JSXElement = JSXElement;
jsx.JSXOpeningElement = JSXOpeningElement;
jsx.JSXClosingElement = JSXClosingElement;
jsx.JSXEmptyExpression = JSXEmptyExpression;
jsx.JSXFragment = JSXFragment;
jsx.JSXOpeningFragment = JSXOpeningFragment;
jsx.JSXClosingFragment = JSXClosingFragment;
function JSXAttribute(node) {
  this.print(node.name, node);
  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}
function JSXIdentifier(node) {
  this.word(node.name);
}
function JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}
function JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}
function JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}
function JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}
function JSXSpreadChild(node) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}
function JSXText(node) {
  const raw = this.getPossibleRaw(node);
  if (raw != null) {
    this.token(raw);
  } else {
    this.token(node.value);
  }
}
function JSXElement(node) {
  const open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;
  this.indent();
  for (const child of node.children) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingElement, node);
}
function spaceSeparator() {
  this.space();
}
function JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  this.print(node.typeParameters, node);
  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, { separator: spaceSeparator });
  }
  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}
function JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}
function JSXEmptyExpression(node) {
  this.printInnerComments(node);
}
function JSXFragment(node) {
  this.print(node.openingFragment, node);
  this.indent();
  for (const child of node.children) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingFragment, node);
}
function JSXOpeningFragment() {
  this.token("<");
  this.token(">");
}
function JSXClosingFragment() {
  this.token("</");
  this.token(">");
}
var typescript = {};
Object.defineProperty(typescript, "__esModule", { value: true });
typescript.TSTypeAnnotation = TSTypeAnnotation;
typescript.TSTypeParameterDeclaration =
  typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
typescript.TSTypeParameter = TSTypeParameter;
typescript.TSParameterProperty = TSParameterProperty;
typescript.TSDeclareFunction = TSDeclareFunction;
typescript.TSDeclareMethod = TSDeclareMethod;
typescript.TSQualifiedName = TSQualifiedName;
typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
typescript.TSPropertySignature = TSPropertySignature;
typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
typescript.TSMethodSignature = TSMethodSignature;
typescript.TSIndexSignature = TSIndexSignature;
typescript.TSAnyKeyword = TSAnyKeyword;
typescript.TSUnknownKeyword = TSUnknownKeyword;
typescript.TSNumberKeyword = TSNumberKeyword;
typescript.TSObjectKeyword = TSObjectKeyword;
typescript.TSBooleanKeyword = TSBooleanKeyword;
typescript.TSStringKeyword = TSStringKeyword;
typescript.TSSymbolKeyword = TSSymbolKeyword;
typescript.TSVoidKeyword = TSVoidKeyword;
typescript.TSUndefinedKeyword = TSUndefinedKeyword;
typescript.TSNullKeyword = TSNullKeyword;
typescript.TSNeverKeyword = TSNeverKeyword;
typescript.TSThisType = TSThisType;
typescript.TSFunctionType = TSFunctionType;
typescript.TSConstructorType = TSConstructorType;
typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
typescript.TSTypeReference = TSTypeReference;
typescript.TSTypePredicate = TSTypePredicate;
typescript.TSTypeQuery = TSTypeQuery;
typescript.TSTypeLiteral = TSTypeLiteral;
typescript.tsPrintTypeLiteralOrInterfaceBody =
  tsPrintTypeLiteralOrInterfaceBody;
typescript.tsPrintBraced = tsPrintBraced;
typescript.TSArrayType = TSArrayType;
typescript.TSTupleType = TSTupleType;
typescript.TSOptionalType = TSOptionalType;
typescript.TSRestType = TSRestType;
typescript.TSUnionType = TSUnionType;
typescript.TSIntersectionType = TSIntersectionType;
typescript.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
typescript.TSConditionalType = TSConditionalType;
typescript.TSInferType = TSInferType;
typescript.TSParenthesizedType = TSParenthesizedType;
typescript.TSTypeOperator = TSTypeOperator;
typescript.TSIndexedAccessType = TSIndexedAccessType;
typescript.TSMappedType = TSMappedType;
typescript.TSLiteralType = TSLiteralType;
typescript.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
typescript.TSInterfaceBody = TSInterfaceBody;
typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
typescript.TSAsExpression = TSAsExpression;
typescript.TSTypeAssertion = TSTypeAssertion;
typescript.TSEnumDeclaration = TSEnumDeclaration;
typescript.TSEnumMember = TSEnumMember;
typescript.TSModuleDeclaration = TSModuleDeclaration;
typescript.TSModuleBlock = TSModuleBlock;
typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
typescript.TSExternalModuleReference = TSExternalModuleReference;
typescript.TSNonNullExpression = TSNonNullExpression;
typescript.TSExportAssignment = TSExportAssignment;
typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
function TSTypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}
function TSTypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}
function TSTypeParameter(node) {
  this.word(node.name);
  if (node.constraint) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.constraint, node);
  }
  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}
function TSParameterProperty(node) {
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.readonly) {
    this.word("readonly");
    this.space();
  }
  this._param(node.parameter);
}
function TSDeclareFunction(node) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  this._functionHead(node);
  this.token(";");
}
function TSDeclareMethod(node) {
  this._classMethodHead(node);
  this.token(";");
}
function TSQualifiedName(node) {
  this.print(node.left, node);
  this.token(".");
  this.print(node.right, node);
}
function TSCallSignatureDeclaration(node) {
  this.tsPrintSignatureDeclarationBase(node);
}
function TSConstructSignatureDeclaration(node) {
  this.word("new");
  this.space();
  this.tsPrintSignatureDeclarationBase(node);
}
function TSPropertySignature(node) {
  const { readonly: readonly, initializer: initializer } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.tsPrintPropertyOrMethodName(node);
  this.print(node.typeAnnotation, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(";");
}
function tsPrintPropertyOrMethodName(node) {
  if (node.computed) {
    this.token("[");
  }
  this.print(node.key, node);
  if (node.computed) {
    this.token("]");
  }
  if (node.optional) {
    this.token("?");
  }
}
function TSMethodSignature(node) {
  this.tsPrintPropertyOrMethodName(node);
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}
function TSIndexSignature(node) {
  const { readonly: readonly } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this._parameters(node.parameters, node);
  this.token("]");
  this.print(node.typeAnnotation, node);
  this.token(";");
}
function TSAnyKeyword() {
  this.word("any");
}
function TSUnknownKeyword() {
  this.word("unknown");
}
function TSNumberKeyword() {
  this.word("number");
}
function TSObjectKeyword() {
  this.word("object");
}
function TSBooleanKeyword() {
  this.word("boolean");
}
function TSStringKeyword() {
  this.word("string");
}
function TSSymbolKeyword() {
  this.word("symbol");
}
function TSVoidKeyword() {
  this.word("void");
}
function TSUndefinedKeyword() {
  this.word("undefined");
}
function TSNullKeyword() {
  this.word("null");
}
function TSNeverKeyword() {
  this.word("never");
}
function TSThisType() {
  this.word("this");
}
function TSFunctionType(node) {
  this.tsPrintFunctionOrConstructorType(node);
}
function TSConstructorType(node) {
  this.word("new");
  this.space();
  this.tsPrintFunctionOrConstructorType(node);
}
function tsPrintFunctionOrConstructorType(node) {
  const { typeParameters: typeParameters, parameters: parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.space();
  this.token("=>");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation, node);
}
function TSTypeReference(node) {
  this.print(node.typeName, node);
  this.print(node.typeParameters, node);
}
function TSTypePredicate(node) {
  this.print(node.parameterName);
  this.space();
  this.word("is");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation);
}
function TSTypeQuery(node) {
  this.word("typeof");
  this.space();
  this.print(node.exprName);
}
function TSTypeLiteral(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
}
function tsPrintTypeLiteralOrInterfaceBody(members, node) {
  this.tsPrintBraced(members, node);
}
function tsPrintBraced(members, node) {
  this.token("{");
  if (members.length) {
    this.indent();
    this.newline();
    for (const member of members) {
      this.print(member, node);
      this.newline();
    }
    this.dedent();
    this.rightBrace();
  } else {
    this.token("}");
  }
}
function TSArrayType(node) {
  this.print(node.elementType);
  this.token("[]");
}
function TSTupleType(node) {
  this.token("[");
  this.printList(node.elementTypes, node);
  this.token("]");
}
function TSOptionalType(node) {
  this.print(node.typeAnnotation, node);
  this.token("?");
}
function TSRestType(node) {
  this.token("...");
  this.print(node.typeAnnotation, node);
}
function TSUnionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "|");
}
function TSIntersectionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "&");
}
function tsPrintUnionOrIntersectionType(node, sep) {
  this.printJoin(node.types, node, {
    separator() {
      this.space();
      this.token(sep);
      this.space();
    },
  });
}
function TSConditionalType(node) {
  this.print(node.checkType);
  this.space();
  this.word("extends");
  this.space();
  this.print(node.extendsType);
  this.space();
  this.token("?");
  this.space();
  this.print(node.trueType);
  this.space();
  this.token(":");
  this.space();
  this.print(node.falseType);
}
function TSInferType(node) {
  this.token("infer");
  this.space();
  this.print(node.typeParameter);
}
function TSParenthesizedType(node) {
  this.token("(");
  this.print(node.typeAnnotation, node);
  this.token(")");
}
function TSTypeOperator(node) {
  this.token(node.operator);
  this.space();
  this.print(node.typeAnnotation, node);
}
function TSIndexedAccessType(node) {
  this.print(node.objectType, node);
  this.token("[");
  this.print(node.indexType, node);
  this.token("]");
}
function TSMappedType(node) {
  const {
    readonly: readonly,
    typeParameter: typeParameter,
    optional: optional,
  } = node;
  this.token("{");
  this.space();
  if (readonly) {
    tokenIfPlusMinus(this, readonly);
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this.word(typeParameter.name);
  this.space();
  this.word("in");
  this.space();
  this.print(typeParameter.constraint, typeParameter);
  this.token("]");
  if (optional) {
    tokenIfPlusMinus(this, optional);
    this.token("?");
  }
  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
  this.space();
  this.token("}");
}
function tokenIfPlusMinus(self, tok) {
  if (tok !== true) {
    self.token(tok);
  }
}
function TSLiteralType(node) {
  this.print(node.literal, node);
}
function TSExpressionWithTypeArguments(node) {
  this.print(node.expression, node);
  this.print(node.typeParameters, node);
}
function TSInterfaceDeclaration(node) {
  const {
    declare: declare,
    id: id,
    typeParameters: typeParameters,
    extends: extendz,
    body: body,
  } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("interface");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  if (extendz) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(extendz, node);
  }
  this.space();
  this.print(body, node);
}
function TSInterfaceBody(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
}
function TSTypeAliasDeclaration(node) {
  const {
    declare: declare,
    id: id,
    typeParameters: typeParameters,
    typeAnnotation: typeAnnotation,
  } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("type");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(typeAnnotation, node);
  this.token(";");
}
function TSAsExpression(node) {
  const { expression: expression, typeAnnotation: typeAnnotation } = node;
  this.print(expression, node);
  this.space();
  this.word("as");
  this.space();
  this.print(typeAnnotation, node);
}
function TSTypeAssertion(node) {
  const { typeAnnotation: typeAnnotation, expression: expression } = node;
  this.token("<");
  this.print(typeAnnotation, node);
  this.token(">");
  this.space();
  this.print(expression, node);
}
function TSEnumDeclaration(node) {
  const { declare: declare, const: isConst, id: id, members: members } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (isConst) {
    this.word("const");
    this.space();
  }
  this.word("enum");
  this.space();
  this.print(id, node);
  this.space();
  this.tsPrintBraced(members, node);
}
function TSEnumMember(node) {
  const { id: id, initializer: initializer } = node;
  this.print(id, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(",");
}
function TSModuleDeclaration(node) {
  const { declare: declare, id: id } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (!node.global) {
    this.word(id.type === "Identifier" ? "namespace" : "module");
    this.space();
  }
  this.print(id, node);
  if (!node.body) {
    this.token(";");
    return;
  }
  let body = node.body;
  while (body.type === "TSModuleDeclaration") {
    this.token(".");
    this.print(body.id, body);
    body = body.body;
  }
  this.space();
  this.print(body, node);
}
function TSModuleBlock(node) {
  this.tsPrintBraced(node.body, node);
}
function TSImportEqualsDeclaration(node) {
  const { isExport: isExport, id: id, moduleReference: moduleReference } = node;
  if (isExport) {
    this.word("export");
    this.space();
  }
  this.word("import");
  this.space();
  this.print(id, node);
  this.space();
  this.token("=");
  this.space();
  this.print(moduleReference, node);
  this.token(";");
}
function TSExternalModuleReference(node) {
  this.token("require(");
  this.print(node.expression, node);
  this.token(")");
}
function TSNonNullExpression(node) {
  this.print(node.expression, node);
  this.token("!");
}
function TSExportAssignment(node) {
  this.word("export");
  this.space();
  this.token("=");
  this.space();
  this.print(node.expression, node);
  this.token(";");
}
function TSNamespaceExportDeclaration(node) {
  this.word("export");
  this.space();
  this.word("as");
  this.space();
  this.word("namespace");
  this.space();
  this.print(node.id, node);
}
function tsPrintSignatureDeclarationBase(node) {
  const { typeParameters: typeParameters, parameters: parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.print(node.typeAnnotation, node);
}
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var _templateLiterals = templateLiterals;
  Object.keys(_templateLiterals).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _templateLiterals[key];
      },
    });
  });
  var _expressions = expressions;
  Object.keys(_expressions).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _expressions[key];
      },
    });
  });
  var _statements = statements;
  Object.keys(_statements).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _statements[key];
      },
    });
  });
  var _classes = classes;
  Object.keys(_classes).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _classes[key];
      },
    });
  });
  var _methods = methods;
  Object.keys(_methods).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _methods[key];
      },
    });
  });
  var _modules = modules;
  Object.keys(_modules).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _modules[key];
      },
    });
  });
  var _types = types;
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      },
    });
  });
  var _flow = flow;
  Object.keys(_flow).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _flow[key];
      },
    });
  });
  var _base = base;
  Object.keys(_base).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _base[key];
      },
    });
  });
  var _jsx = jsx;
  Object.keys(_jsx).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _jsx[key];
      },
    });
  });
  var _typescript = typescript;
  Object.keys(_typescript).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _typescript[key];
      },
    });
  });
})(generators);
Object.defineProperty(printer$1, "__esModule", { value: true });
printer$1.default = void 0;
function _isInteger() {
  const data = _interopRequireDefault$4(requireIsInteger());
  _isInteger = function () {
    return data;
  };
  return data;
}
function _repeat() {
  const data = _interopRequireDefault$4(requireRepeat());
  _repeat = function () {
    return data;
  };
  return data;
}
var _buffer = _interopRequireDefault$4(buffer);
var n = _interopRequireWildcard$1(node);
function t() {
  const data = _interopRequireWildcard$1(t$a);
  t = function () {
    return data;
  };
  return data;
}
var generatorFunctions = _interopRequireWildcard$1(generators);
function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const SCIENTIFIC_NOTATION = /e/i;
const ZERO_DECIMAL_INTEGER = /\.0+$/;
const NON_DECIMAL_LITERAL = /^0[box]/;
class Printer {
  constructor(format, map) {
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new WeakSet();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this.format = format || {};
    this._buf = new _buffer.default(map);
  }
  generate(ast) {
    this.print(ast);
    this._maybeAddAuxComment();
    return this._buf.get();
  }
  indent() {
    if (this.format.compact || this.format.concise) return;
    this._indent++;
  }
  dedent() {
    if (this.format.compact || this.format.concise) return;
    this._indent--;
  }
  semicolon(force = false) {
    this._maybeAddAuxComment();
    this._append(";", !force);
  }
  rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }
    this.token("}");
  }
  space(force = false) {
    if (this.format.compact) return;
    if (
      (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n")) ||
      force
    ) {
      this._space();
    }
  }
  word(str) {
    if (this._endsWithWord || (this.endsWith("/") && str.indexOf("/") === 0)) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
    this._endsWithWord = true;
  }
  number(str) {
    this.word(str);
    this._endsWithInteger =
      (0, _isInteger().default)(+str) &&
      !NON_DECIMAL_LITERAL.test(str) &&
      !SCIENTIFIC_NOTATION.test(str) &&
      !ZERO_DECIMAL_INTEGER.test(str) &&
      str[str.length - 1] !== ".";
  }
  token(str) {
    if (
      (str === "--" && this.endsWith("!")) ||
      (str[0] === "+" && this.endsWith("+")) ||
      (str[0] === "-" && this.endsWith("-")) ||
      (str[0] === "." && this._endsWithInteger)
    ) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
  }
  newline(i) {
    if (this.format.retainLines || this.format.compact) return;
    if (this.format.concise) {
      this.space();
      return;
    }
    if (this.endsWith("\n\n")) return;
    if (typeof i !== "number") i = 1;
    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;
    for (let j = 0; j < i; j++) {
      this._newline();
    }
  }
  endsWith(str) {
    return this._buf.endsWith(str);
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }
  exactSource(loc, cb) {
    this._catchUp("start", loc);
    this._buf.exactSource(loc, cb);
  }
  source(prop, loc) {
    this._catchUp(prop, loc);
    this._buf.source(prop, loc);
  }
  withSource(prop, loc, cb) {
    this._catchUp(prop, loc);
    this._buf.withSource(prop, loc, cb);
  }
  _space() {
    this._append(" ", true);
  }
  _newline() {
    this._append("\n", true);
  }
  _append(str, queue = false) {
    this._maybeAddParen(str);
    this._maybeIndent(str);
    if (queue) this._buf.queue(str);
    else this._buf.append(str);
    this._endsWithWord = false;
    this._endsWithInteger = false;
  }
  _maybeIndent(str) {
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  }
  _maybeAddParen(str) {
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;
    let i;
    for (i = 0; i < str.length && str[i] === " "; i++) continue;
    if (i === str.length) return;
    const cha = str[i];
    if (cha !== "\n") {
      if (cha !== "/") return;
      if (i + 1 === str.length) return;
      const chaPost = str[i + 1];
      if (chaPost !== "/" && chaPost !== "*") return;
    }
    this.token("(");
    this.indent();
    parenPushNewlineState.printed = true;
  }
  _catchUp(prop, loc) {
    if (!this.format.retainLines) return;
    const pos = loc ? loc[prop] : null;
    if (pos && pos.line !== null) {
      const count = pos.line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
  }
  _getIndent() {
    return (0, _repeat().default)(this.format.indent.style, this._indent);
  }
  startTerminatorless(isLabel = false) {
    if (isLabel) {
      this._noLineTerminator = true;
      return null;
    } else {
      return (this._parenPushNewlineState = { printed: false });
    }
  }
  endTerminatorless(state) {
    this._noLineTerminator = false;
    if (state && state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  }
  print(node, parent) {
    if (!node) return;
    const oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }
    const printMethod = this[node.type];
    if (!printMethod) {
      throw new ReferenceError(
        `unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node && node.constructor.name)}`,
      );
    }
    this._printStack.push(node);
    const oldInAux = this._insideAux;
    this._insideAux = !node.loc;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);
    let needsParens = n.needsParens(node, parent, this._printStack);
    if (
      this.format.retainFunctionParens &&
      node.type === "FunctionExpression" &&
      node.extra &&
      node.extra.parenthesized
    ) {
      needsParens = true;
    }
    if (needsParens) this.token("(");
    this._printLeadingComments(node);
    const loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
    this.withSource("start", loc, () => {
      this[node.type](node, parent);
    });
    this._printTrailingComments(node);
    if (needsParens) this.token(")");
    this._printStack.pop();
    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  }
  _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;
    const comment = this.format.auxiliaryCommentBefore;
    if (comment) {
      this._printComment({ type: "CommentBlock", value: comment });
    }
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;
    const comment = this.format.auxiliaryCommentAfter;
    if (comment) {
      this._printComment({ type: "CommentBlock", value: comment });
    }
  }
  getPossibleRaw(node) {
    const extra = node.extra;
    if (
      extra &&
      extra.raw != null &&
      extra.rawValue != null &&
      node.value === extra.rawValue
    ) {
      return extra.raw;
    }
  }
  printJoin(nodes, parent, opts = {}) {
    if (!nodes || !nodes.length) return;
    if (opts.indent) this.indent();
    const newlineOpts = { addNewlines: opts.addNewlines };
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
      this.print(node, parent);
      if (opts.iterator) {
        opts.iterator(node, i);
      }
      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }
      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }
    if (opts.indent) this.dedent();
  }
  printAndIndentOnComments(node, parent) {
    const indent = node.leadingComments && node.leadingComments.length > 0;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  }
  printBlock(parent) {
    const node = parent.body;
    if (!t().isEmptyStatement(node)) {
      this.space();
    }
    this.print(node, parent);
  }
  _printTrailingComments(node) {
    this._printComments(this._getComments(false, node));
  }
  _printLeadingComments(node) {
    this._printComments(this._getComments(true, node));
  }
  printInnerComments(node, indent = true) {
    if (!node.innerComments || !node.innerComments.length) return;
    if (indent) this.indent();
    this._printComments(node.innerComments);
    if (indent) this.dedent();
  }
  printSequence(nodes, parent, opts = {}) {
    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  }
  printList(items, parent, opts = {}) {
    if (opts.separator == null) {
      opts.separator = commaSeparator;
    }
    return this.printJoin(items, parent, opts);
  }
  _printNewline(leading, node, parent, opts) {
    if (this.format.retainLines || this.format.compact) return;
    if (this.format.concise) {
      this.space();
      return;
    }
    let lines = 0;
    if (this._buf.hasContent()) {
      if (!leading) lines++;
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
      if (needs(node, parent)) lines++;
    }
    this.newline(lines);
  }
  _getComments(leading, node) {
    return (
      (node && (leading ? node.leadingComments : node.trailingComments)) || []
    );
  }
  _printComment(comment) {
    if (!this.format.shouldPrintComment(comment.value)) return;
    if (comment.ignore) return;
    if (this._printedComments.has(comment)) return;
    this._printedComments.add(comment);
    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }
    const isBlockComment = comment.type === "CommentBlock";
    this.newline(
      this._buf.hasContent() && !this._noLineTerminator && isBlockComment
        ? 1
        : 0,
    );
    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
    let val =
      !isBlockComment && !this._noLineTerminator
        ? `//${comment.value}\n`
        : `/*${comment.value}*/`;
    if (isBlockComment && this.format.indent.adjustMultilineComment) {
      const offset = comment.loc && comment.loc.start.column;
      if (offset) {
        const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }
      const indentSize = Math.max(
        this._getIndent().length,
        this._buf.getCurrentColumn(),
      );
      val = val.replace(
        /\n(?!$)/g,
        `\n${(0, _repeat().default)(" ", indentSize)}`,
      );
    }
    if (this.endsWith("/")) this._space();
    this.withSource("start", comment.loc, () => {
      this._append(val);
    });
    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
  }
  _printComments(comments) {
    if (!comments || !comments.length) return;
    for (const comment of comments) {
      this._printComment(comment);
    }
  }
}
printer$1.default = Printer;
Object.assign(Printer.prototype, generatorFunctions);
function commaSeparator() {
  this.token(",");
  this.space();
}
Object.defineProperty(lib, "__esModule", { value: true });
var default_1 = (lib.default = _default$7);
lib.CodeGenerator = void 0;
var _sourceMap = _interopRequireDefault$3(sourceMap$1);
var _printer = _interopRequireDefault$3(printer$1);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
class Generator extends _printer.default {
  constructor(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    super(format, map);
    this.ast = ast;
  }
  generate() {
    return super.generate(this.ast);
  }
}
function normalizeOptions(code, opts) {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: { adjustMultilineComment: true, style: "  ", base: 0 },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: Object.assign(
      { quotes: "double", wrap: true },
      opts.jsescOption,
    ),
  };
  if (format.minified) {
    format.compact = true;
    format.shouldPrintComment =
      format.shouldPrintComment || (() => format.comments);
  } else {
    format.shouldPrintComment =
      format.shouldPrintComment ||
      ((value) =>
        format.comments ||
        value.indexOf("@license") >= 0 ||
        value.indexOf("@preserve") >= 0);
  }
  if (format.compact === "auto") {
    format.compact = code.length > 5e5;
    if (format.compact) {
      console.error(
        "[BABEL] Note: The code generator has deoptimised the styling of " +
          `${opts.filename} as it exceeds the max of ${"500KB"}.`,
      );
    }
  }
  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }
  return format;
}
class CodeGenerator {
  constructor(ast, opts, code) {
    this._generator = new Generator(ast, opts, code);
  }
  generate() {
    return this._generator.generate();
  }
}
lib.CodeGenerator = CodeGenerator;
function _default$7(ast, opts, code) {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    );
  return kind === "m"
    ? f
    : kind === "a"
      ? f.call(receiver)
      : f
        ? f.value
        : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    );
  return (
    kind === "a"
      ? f.call(receiver, value)
      : f
        ? (f.value = value)
        : state.set(receiver, value),
    value
  );
}
var _Writer_out, _Writer_line, _Writer_depth;
function printReactiveFunction(fn) {
  const writer = new Writer();
  writer.writeLine(`function ${fn.id !== null ? fn.id : "<unknown>"}(`);
  writer.indented(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        writer.writeLine(`${printPlace(param)},`);
      } else {
        writer.writeLine(`...${printPlace(param.place)},`);
      }
    }
  });
  writer.writeLine(") {");
  writeReactiveInstructions(writer, fn.body);
  writer.writeLine("}");
  return writer.complete();
}
function printReactiveScopeSummary(scope) {
  const items = [];
  items.push("scope");
  items.push(`@${scope.id}`);
  items.push(`[${scope.range.start}:${scope.range.end}]`);
  items.push(
    `dependencies=[${Array.from(scope.dependencies)
      .map((dep) => printDependency(dep))
      .join(", ")}]`,
  );
  items.push(
    `declarations=[${Array.from(scope.declarations)
      .map(([, decl]) =>
        printIdentifier(
          Object.assign(Object.assign({}, decl.identifier), {
            scope: decl.scope,
          }),
        ),
      )
      .join(", ")}]`,
  );
  items.push(
    `reassignments=[${Array.from(scope.reassignments).map((reassign) => printIdentifier(reassign))}]`,
  );
  if (scope.earlyReturnValue !== null) {
    items.push(
      `earlyReturn={id: ${printIdentifier(scope.earlyReturnValue.value)}, label: ${scope.earlyReturnValue.label}}}`,
    );
  }
  return items.join(" ");
}
function writeReactiveBlock(writer, block) {
  writer.writeLine(`${printReactiveScopeSummary(block.scope)} {`);
  writeReactiveInstructions(writer, block.instructions);
  writer.writeLine("}");
}
function printDependency(dependency) {
  const identifier =
    printIdentifier(dependency.identifier) +
    printType(dependency.identifier.type);
  return `${identifier}${dependency.path.map((prop) => `.${prop}`).join("")}`;
}
function writeReactiveInstructions(writer, instructions) {
  writer.indented(() => {
    for (const instr of instructions) {
      writeReactiveInstruction(writer, instr);
    }
  });
}
function writeReactiveInstruction(writer, instr) {
  switch (instr.kind) {
    case "instruction": {
      const { instruction: instruction } = instr;
      const id = `[${instruction.id}]`;
      if (instruction.lvalue !== null) {
        writer.write(`${id} ${printPlace(instruction.lvalue)} = `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      } else {
        writer.write(`${id} `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      }
      break;
    }
    case "scope": {
      writeReactiveBlock(writer, instr);
      break;
    }
    case "terminal": {
      if (instr.label !== null) {
        writer.write(`bb${instr.label.id}: `);
      }
      writeTerminal(writer, instr.terminal);
      break;
    }
    default: {
      assertExhaustive(instr, `Unexpected terminal kind '${instr.kind}'`);
    }
  }
}
function writeReactiveValue(writer, value) {
  switch (value.kind) {
    case "ConditionalExpression": {
      writer.writeLine(`Ternary `);
      writer.indented(() => {
        writeReactiveValue(writer, value.test);
        writer.writeLine(`? `);
        writer.indented(() => {
          writeReactiveValue(writer, value.consequent);
        });
        writer.writeLine(`: `);
        writer.indented(() => {
          writeReactiveValue(writer, value.alternate);
        });
      });
      writer.newline();
      break;
    }
    case "LogicalExpression": {
      writer.writeLine(`Logical`);
      writer.indented(() => {
        writeReactiveValue(writer, value.left);
        writer.write(`${value.operator} `);
        writeReactiveValue(writer, value.right);
      });
      writer.newline();
      break;
    }
    case "SequenceExpression": {
      writer.writeLine(`Sequence`);
      writer.indented(() => {
        writer.indented(() => {
          value.instructions.forEach((instr) =>
            writeReactiveInstruction(writer, {
              kind: "instruction",
              instruction: instr,
            }),
          );
          writer.write(`[${value.id}] `);
          writeReactiveValue(writer, value.value);
        });
      });
      writer.newline();
      break;
    }
    case "OptionalExpression": {
      writer.append(`OptionalExpression optional=${value.optional}`);
      writer.newline();
      writer.indented(() => {
        writeReactiveValue(writer, value.value);
      });
      writer.newline();
      break;
    }
    default: {
      const printed = printInstructionValue(value);
      const lines = printed.split("\n");
      if (lines.length === 1) {
        writer.writeLine(printed);
      } else {
        writer.indented(() => {
          for (const line of lines) {
            writer.writeLine(line);
          }
        });
      }
    }
  }
}
function writeTerminal(writer, terminal) {
  switch (terminal.kind) {
    case "break": {
      const id = terminal.id !== null ? `[${terminal.id}]` : [];
      writer.writeLine(
        `${id} break bb${terminal.target} (${terminal.targetKind})`,
      );
      break;
    }
    case "continue": {
      const id = `[${terminal.id}]`;
      writer.writeLine(
        `${id} continue bb${terminal.target} (${terminal.targetKind})`,
      );
      break;
    }
    case "do-while": {
      writer.writeLine(`[${terminal.id}] do-while {`);
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("} (");
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(")");
      break;
    }
    case "while": {
      writer.writeLine(`[${terminal.id}] while (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "if": {
      const {
        test: test,
        consequent: consequent,
        alternate: alternate,
      } = terminal;
      writer.writeLine(`[${terminal.id}] if (${printPlace(test)}) {`);
      writeReactiveInstructions(writer, consequent);
      if (alternate !== null) {
        writer.writeLine("} else {");
        writeReactiveInstructions(writer, alternate);
      }
      writer.writeLine("}");
      break;
    }
    case "switch": {
      writer.writeLine(
        `[${terminal.id}] switch (${printPlace(terminal.test)}) {`,
      );
      writer.indented(() => {
        for (const case_ of terminal.cases) {
          let prefix =
            case_.test !== null ? `case ${printPlace(case_.test)}` : "default";
          writer.writeLine(`${prefix}: {`);
          writer.indented(() => {
            var _a, _b;
            const block = case_.block;
            CompilerError.invariant(block != null, {
              reason: "Expected case to have a block",
              description: null,
              loc:
                (_b =
                  (_a = case_.test) === null || _a === void 0
                    ? void 0
                    : _a.loc) !== null && _b !== void 0
                  ? _b
                  : null,
              suggestions: null,
            });
            writeReactiveInstructions(writer, block);
          });
          writer.writeLine("}");
        }
      });
      writer.writeLine("}");
      break;
    }
    case "for": {
      writer.writeLine(`[${terminal.id}] for (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
        writer.writeLine(";");
        writeReactiveValue(writer, terminal.test);
        writer.writeLine(";");
        if (terminal.update !== null) {
          writeReactiveValue(writer, terminal.update);
        }
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-of": {
      writer.writeLine(`[${terminal.id}] for-of (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-in": {
      writer.writeLine(`[${terminal.id}] for-in (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "throw": {
      writer.writeLine(`[${terminal.id}] throw ${printPlace(terminal.value)}`);
      break;
    }
    case "return": {
      writer.writeLine(`[${terminal.id}] return ${printPlace(terminal.value)}`);
      break;
    }
    case "label": {
      writer.writeLine("{");
      writeReactiveInstructions(writer, terminal.block);
      writer.writeLine("}");
      break;
    }
    case "try": {
      writer.writeLine(`[${terminal.id}] try {`);
      writeReactiveInstructions(writer, terminal.block);
      writer.write(`} catch `);
      if (terminal.handlerBinding !== null) {
        writer.writeLine(`(${printPlace(terminal.handlerBinding)}) {`);
      } else {
        writer.writeLine(`{`);
      }
      writeReactiveInstructions(writer, terminal.handler);
      writer.writeLine("}");
      break;
    }
    default:
      assertExhaustive(terminal, `Unhandled terminal ${terminal}`);
  }
}
class Writer {
  constructor({ depth: depth } = { depth: 0 }) {
    _Writer_out.set(this, []);
    _Writer_line.set(this, void 0);
    _Writer_depth.set(this, void 0);
    __classPrivateFieldSet(this, _Writer_depth, Math.max(depth, 0), "f");
    __classPrivateFieldSet(this, _Writer_line, "", "f");
  }
  complete() {
    const line = __classPrivateFieldGet(this, _Writer_line, "f").trimEnd();
    if (line.length > 0) {
      __classPrivateFieldGet(this, _Writer_out, "f").push(line);
    }
    return __classPrivateFieldGet(this, _Writer_out, "f").join("\n");
  }
  append(s) {
    this.write(s);
  }
  newline() {
    const line = __classPrivateFieldGet(this, _Writer_line, "f").trimEnd();
    if (line.length > 0) {
      __classPrivateFieldGet(this, _Writer_out, "f").push(line);
    }
    __classPrivateFieldSet(this, _Writer_line, "", "f");
  }
  write(s) {
    if (
      __classPrivateFieldGet(this, _Writer_line, "f").length === 0 &&
      __classPrivateFieldGet(this, _Writer_depth, "f") > 0
    ) {
      __classPrivateFieldSet(
        this,
        _Writer_line,
        "  ".repeat(__classPrivateFieldGet(this, _Writer_depth, "f")),
        "f",
      );
    }
    __classPrivateFieldSet(
      this,
      _Writer_line,
      __classPrivateFieldGet(this, _Writer_line, "f") + s,
      "f",
    );
  }
  writeLine(s) {
    this.write(s);
    this.newline();
  }
  indented(f) {
    var _a, _b;
    __classPrivateFieldSet(
      this,
      _Writer_depth,
      ((_a = __classPrivateFieldGet(this, _Writer_depth, "f")), _a++, _a),
      "f",
    );
    f();
    __classPrivateFieldSet(
      this,
      _Writer_depth,
      ((_b = __classPrivateFieldGet(this, _Writer_depth, "f")), _b--, _b),
      "f",
    );
  }
}
(_Writer_out = new WeakMap()),
  (_Writer_line = new WeakMap()),
  (_Writer_depth = new WeakMap());
function printFunction$1(fn) {
  const output = [];
  let definition = "";
  if (fn.id !== null) {
    definition += fn.id;
  }
  if (fn.params.length !== 0) {
    definition +=
      "(" +
      fn.params
        .map((param) => {
          if (param.kind === "Identifier") {
            return printPlace(param);
          } else {
            return `...${printPlace(param.place)}`;
          }
        })
        .join(", ") +
      ")";
  }
  if (definition.length !== 0) {
    output.push(definition);
  }
  output.push(printHIR(fn.body));
  output.push(...fn.directives);
  return output.join("\n");
}
function printHIR(ir, options = null) {
  var _a;
  let output = [];
  let indent = " ".repeat(
    (_a = options === null || options === void 0 ? void 0 : options.indent) !==
      null && _a !== void 0
      ? _a
      : 0,
  );
  const push = (text, indent = "  ") => {
    output.push(`${indent}${text}`);
  };
  for (const [blockId, block] of ir.blocks) {
    output.push(`bb${blockId} (${block.kind}):`);
    if (block.preds.size > 0) {
      const preds = ["predecessor blocks:"];
      for (const pred of block.preds) {
        preds.push(`bb${pred}`);
      }
      push(preds.join(" "));
    }
    for (const phi of block.phis) {
      push(printPhi(phi));
    }
    for (const instr of block.instructions) {
      push(printInstruction(instr));
    }
    const terminal = printTerminal(block.terminal);
    if (Array.isArray(terminal)) {
      terminal.forEach((line) => push(line));
    } else {
      push(terminal);
    }
  }
  return output.map((line) => indent + line).join("\n");
}
function printMixedHIR(value) {
  if (!("kind" in value)) {
    return printInstruction(value);
  }
  switch (value.kind) {
    case "try":
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "branch":
    case "if":
    case "logical":
    case "ternary":
    case "return":
    case "switch":
    case "throw":
    case "while":
    case "for":
    case "unsupported":
    case "goto":
    case "do-while":
    case "for-in":
    case "for-of":
    case "scope": {
      const terminal = printTerminal(value);
      if (Array.isArray(terminal)) {
        return terminal.join("; ");
      }
      return terminal;
    }
    default: {
      return printInstructionValue(value);
    }
  }
}
function printInstruction(instr) {
  const id = `[${instr.id}]`;
  const value = printInstructionValue(instr.value);
  if (instr.lvalue !== null) {
    return `${id} ${printPlace(instr.lvalue)} = ${value}`;
  } else {
    return `${id} ${value}`;
  }
}
function printPhi(phi) {
  const items = [];
  items.push(printIdentifier(phi.id));
  items.push(printMutableRange(phi.id));
  items.push(printType(phi.type));
  items.push(": phi(");
  const phis = [];
  for (const [blockId, id] of phi.operands) {
    phis.push(`bb${blockId}: ${printIdentifier(id)}`);
  }
  items.push(phis.join(", "));
  items.push(")");
  return items.join("");
}
function printTerminal(terminal) {
  let value;
  switch (terminal.kind) {
    case "if": {
      value = `[${terminal.id}] If (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate}${terminal.fallthrough ? ` fallthrough=bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "branch": {
      value = `[${terminal.id}] Branch (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate}`;
      break;
    }
    case "logical": {
      value = `[${terminal.id}] Logical ${terminal.operator} test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "ternary": {
      value = `[${terminal.id}] Ternary test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "optional": {
      value = `[${terminal.id}] Optional test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "throw": {
      value = `[${terminal.id}] Throw ${printPlace(terminal.value)}`;
      break;
    }
    case "return": {
      value = `[${terminal.id}] Return${terminal.value != null ? " " + printPlace(terminal.value) : ""}`;
      break;
    }
    case "goto": {
      value = `[${terminal.id}] Goto${terminal.variant === GotoVariant.Continue ? "(Continue)" : ""} bb${terminal.block}`;
      break;
    }
    case "switch": {
      const output = [];
      output.push(`[${terminal.id}] Switch (${printPlace(terminal.test)})`);
      terminal.cases.forEach((case_) => {
        if (case_.test !== null) {
          output.push(`  Case ${printPlace(case_.test)}: bb${case_.block}`);
        } else {
          output.push(`  Default: bb${case_.block}`);
        }
      });
      if (terminal.fallthrough) {
        output.push(`  Fallthrough: bb${terminal.fallthrough}`);
      }
      value = output;
      break;
    }
    case "do-while": {
      value = `[${terminal.id}] DoWhile loop=${`bb${terminal.loop}`} test=bb${terminal.test} fallthrough=${`bb${terminal.fallthrough}`}`;
      break;
    }
    case "while": {
      value = `[${terminal.id}] While test=bb${terminal.test} loop=${terminal.loop !== null ? `bb${terminal.loop}` : ""} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "for": {
      value = `[${terminal.id}] For init=bb${terminal.init} test=bb${terminal.test} loop=bb${terminal.loop} update=bb${terminal.update} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-of": {
      value = `[${terminal.id}] ForOf init=bb${terminal.init} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-in": {
      value = `[${terminal.id}] ForIn init=bb${terminal.init} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "label": {
      value = `[${terminal.id}] Label block=bb${terminal.block} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "sequence": {
      value = `[${terminal.id}] Sequence block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "unsupported": {
      value = `Unsupported`;
      break;
    }
    case "maybe-throw": {
      value = `MaybeThrow continuation=bb${terminal.continuation} handler=bb${terminal.handler}`;
      break;
    }
    case "scope": {
      value = `Scope ${printReactiveScopeSummary(terminal.scope)} block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "try": {
      value = `Try block=bb${terminal.block} handler=bb${terminal.handler}${terminal.handlerBinding !== null ? ` handlerBinding=(${printPlace(terminal.handlerBinding)})` : ""} fallthrough=${terminal.fallthrough != null ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal}'`);
    }
  }
  return value;
}
function printHole() {
  return "<hole>";
}
function printObjectPropertyKey(key) {
  switch (key.kind) {
    case "identifier":
      return key.name;
    case "string":
      return `"${key.name}"`;
    case "computed": {
      return `[${printPlace(key.name)}]`;
    }
  }
}
function printInstructionValue(instrValue) {
  var _a, _b;
  let value = "";
  switch (instrValue.kind) {
    case "ArrayExpression": {
      value = `Array [${instrValue.elements
        .map((element) => {
          if (element.kind === "Identifier") {
            return printPlace(element);
          } else if (element.kind === "Hole") {
            return printHole();
          } else {
            return `...${printPlace(element.place)}`;
          }
        })
        .join(", ")}]`;
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      if (instrValue.properties !== null) {
        for (const property of instrValue.properties) {
          if (property.kind === "ObjectProperty") {
            properties.push(
              `${printObjectPropertyKey(property.key)}: ${printPlace(property.place)}`,
            );
          } else {
            properties.push(`...${printPlace(property.place)}`);
          }
        }
      }
      value = `Object { ${properties.join(", ")} }`;
      break;
    }
    case "UnaryExpression": {
      value = `Unary ${printPlace(instrValue.value)}`;
      break;
    }
    case "BinaryExpression": {
      value = `Binary ${printPlace(instrValue.left)} ${instrValue.operator} ${printPlace(instrValue.right)}`;
      break;
    }
    case "NewExpression": {
      value = `New ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "CallExpression": {
      value = `Call ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "MethodCall": {
      value = `MethodCall ${printPlace(instrValue.receiver)}.${printPlace(instrValue.property)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "JSXText": {
      value = `JSXText ${JSON.stringify(instrValue.value)}`;
      break;
    }
    case "Primitive": {
      if (instrValue.value === undefined) {
        value = "<undefined>";
      } else {
        value = JSON.stringify(instrValue.value);
      }
      break;
    }
    case "TypeCastExpression": {
      value = `TypeCast ${printPlace(instrValue.value)}: ${printType(instrValue.type)}`;
      break;
    }
    case "JsxExpression": {
      const propItems = [];
      for (const attribute of instrValue.props) {
        if (attribute.kind === "JsxAttribute") {
          propItems.push(
            `${attribute.name}={${attribute.place !== null ? printPlace(attribute.place) : "<empty>"}}`,
          );
        } else {
          propItems.push(`...${printPlace(attribute.argument)}`);
        }
      }
      const tag =
        instrValue.tag.kind === "Identifier"
          ? printPlace(instrValue.tag)
          : instrValue.tag.name;
      const props = propItems.length !== 0 ? " " + propItems.join(" ") : "";
      if (instrValue.children !== null) {
        const children = instrValue.children.map(
          (child) => `{${printPlace(child)}}`,
        );
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}>${children.join("")}</${tag}>`;
      } else {
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}/>`;
      }
      break;
    }
    case "JsxFragment": {
      value = `JsxFragment [${instrValue.children.map((child) => printPlace(child)).join(", ")}]`;
      break;
    }
    case "UnsupportedNode": {
      value = `UnsupportedNode(${default_1(instrValue.node).code})`;
      break;
    }
    case "LoadLocal": {
      value = `LoadLocal ${printPlace(instrValue.place)}`;
      break;
    }
    case "DeclareLocal": {
      value = `DeclareLocal ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)}`;
      break;
    }
    case "DeclareContext": {
      value = `DeclareContext ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)}`;
      break;
    }
    case "StoreLocal": {
      value = `StoreLocal ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "LoadContext": {
      value = `LoadContext ${printPlace(instrValue.place)}`;
      break;
    }
    case "StoreContext": {
      value = `StoreContext ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "Destructure": {
      value = `Destructure ${instrValue.lvalue.kind} ${printPattern(instrValue.lvalue.pattern)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyLoad": {
      value = `PropertyLoad ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "PropertyStore": {
      value = `PropertyStore ${printPlace(instrValue.object)}.${instrValue.property} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyDelete": {
      value = `PropertyDelete ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "ComputedLoad": {
      value = `ComputedLoad ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}]`;
      break;
    }
    case "ComputedStore": {
      value = `ComputedStore ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}] = ${printPlace(instrValue.value)}`;
      break;
    }
    case "ComputedDelete": {
      value = `ComputedDelete ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}]`;
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      const kind =
        instrValue.kind === "FunctionExpression" ? "Function" : "ObjectMethod";
      const name = getFunctionName$1(instrValue, "");
      const fn = printFunction$1(instrValue.loweredFunc.func)
        .split("\n")
        .map((line) => `      ${line}`)
        .join("\n");
      const deps = instrValue.loweredFunc.dependencies
        .map((dep) => printPlace(dep))
        .join(",");
      const context = instrValue.loweredFunc.func.context
        .map((dep) => printPlace(dep))
        .join(",");
      value = `${kind} ${name} @deps[${deps}] @context[${context}]:\n${fn}`;
      break;
    }
    case "TaggedTemplateExpression": {
      value = `${printPlace(instrValue.tag)}\`${instrValue.value.raw}\``;
      break;
    }
    case "LogicalExpression": {
      value = `Logical ${printInstructionValue(instrValue.left)} ${instrValue.operator} ${printInstructionValue(instrValue.right)}`;
      break;
    }
    case "SequenceExpression": {
      value = [
        `Sequence`,
        ...instrValue.instructions.map(
          (instr) => `    ${printInstruction(instr)}`,
        ),
        `    ${printInstructionValue(instrValue.value)}`,
      ].join("\n");
      break;
    }
    case "ConditionalExpression": {
      value = `Ternary ${printInstructionValue(instrValue.test)} ? ${printInstructionValue(instrValue.consequent)} : ${printInstructionValue(instrValue.alternate)}`;
      break;
    }
    case "TemplateLiteral": {
      value = "`";
      CompilerError.invariant(
        instrValue.subexprs.length === instrValue.quasis.length - 1,
        {
          reason: "Bad assumption about quasi length.",
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        },
      );
      for (let i = 0; i < instrValue.subexprs.length; i++) {
        value += instrValue.quasis[i].raw;
        value += `\${${printPlace(instrValue.subexprs[i])}}`;
      }
      value += instrValue.quasis.at(-1).raw + "`";
      break;
    }
    case "LoadGlobal": {
      value = `Global ${instrValue.name}`;
      break;
    }
    case "OptionalExpression": {
      value = `OptionalExpression ${printInstructionValue(instrValue.value)}`;
      break;
    }
    case "RegExpLiteral": {
      value = `RegExp /${instrValue.pattern}/${instrValue.flags}`;
      break;
    }
    case "Await": {
      value = `Await ${printPlace(instrValue.value)}`;
      break;
    }
    case "NextIterableOf": {
      value = `NextIterableOf ${printPlace(instrValue.value)}`;
      break;
    }
    case "NextPropertyOf": {
      value = `NextPropertyOf ${printPlace(instrValue.value)}`;
      break;
    }
    case "Debugger": {
      value = `Debugger`;
      break;
    }
    case "PostfixUpdate": {
      value = `PostfixUpdate ${printPlace(instrValue.lvalue)} = ${printPlace(instrValue.value)} ${instrValue.operation}`;
      break;
    }
    case "PrefixUpdate": {
      value = `PrefixUpdate ${printPlace(instrValue.lvalue)} = ${instrValue.operation} ${printPlace(instrValue.value)}`;
      break;
    }
    case "StartMemoize": {
      value = `StartMemoize deps=${(_b = (_a = instrValue.deps) === null || _a === void 0 ? void 0 : _a.map((dep) => printManualMemoDependency(dep, false))) !== null && _b !== void 0 ? _b : "(none)"}`;
      break;
    }
    case "FinishMemoize": {
      value = `FinishMemoize decl=${printPlace(instrValue.decl)}`;
      break;
    }
    case "ReactiveFunctionValue": {
      value = `FunctionValue ${printReactiveFunction(instrValue.fn)}`;
      break;
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction kind '${instrValue.kind}'`,
      );
    }
  }
  return value;
}
function isMutable$1(range) {
  return range.end > range.start + 1;
}
function printMutableRange(identifier) {
  var _b, _c;
  const range =
    (_c =
      (_b = identifier.scope) === null || _b === void 0 ? void 0 : _b.range) !==
      null && _c !== void 0
      ? _c
      : identifier.mutableRange;
  return isMutable$1(range) ? `[${range.start}:${range.end}]` : "";
}
function printPattern(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return (
        "[ " +
        pattern.items
          .map((item) => {
            if (item.kind === "Hole") {
              return "<hole>";
            }
            return printPattern(item);
          })
          .join(", ") +
        " ]"
      );
    }
    case "ObjectPattern": {
      return (
        "{ " +
        pattern.properties
          .map((item) => {
            switch (item.kind) {
              case "ObjectProperty": {
                return `${printObjectPropertyKey(item.key)}: ${printPattern(item.place)}`;
              }
              case "Spread": {
                return printPattern(item);
              }
              default: {
                assertExhaustive(item, "Unexpected object property kind");
              }
            }
          })
          .join(", ") +
        " }"
      );
    }
    case "Spread": {
      return `...${printPlace(pattern.place)}`;
    }
    case "Identifier": {
      return printPlace(pattern);
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
}
function printPlace(place) {
  const items = [
    place.effect,
    " ",
    printIdentifier(place.identifier),
    printMutableRange(place.identifier),
    printType(place.identifier.type),
    place.reactive ? "{reactive}" : null,
  ];
  return items.filter((x) => x != null).join("");
}
function printIdentifier(id) {
  return `${printName(id.name)}$${id.id}${printScope(id.scope)}`;
}
function printName(name) {
  if (name === null) {
    return "";
  }
  return name.value;
}
function printScope(scope) {
  return `${scope !== null ? `_@${scope.id}` : ""}`;
}
function printManualMemoDependency(val, nameOnly) {
  var _a;
  let rootStr;
  if (val.root.kind === "Global") {
    rootStr = val.root.identifierName;
  } else {
    CompilerError.invariant(
      ((_a = val.root.value.identifier.name) === null || _a === void 0
        ? void 0
        : _a.kind) === "named",
      {
        reason: "DepsValidation: expected named local variable in depslist",
        suggestions: null,
        loc: val.root.value.loc,
      },
    );
    rootStr = nameOnly
      ? val.root.value.identifier.name.value
      : printIdentifier(val.root.value.identifier);
  }
  return `${rootStr}${val.path.length > 0 ? "." : ""}${val.path.join(".")}`;
}
function printType(type) {
  if (type.kind === "Type") return "";
  if (type.kind === "Object" && type.shapeId != null) {
    return `:T${type.kind}<${type.shapeId}>`;
  } else if (type.kind === "Function" && type.shapeId != null) {
    return `:T${type.kind}<${type.shapeId}>`;
  } else {
    return `:T${type.kind}`;
  }
}
function printSourceLocation(loc) {
  if (typeof loc === "symbol") {
    return "generated";
  } else {
    return `${loc.start.line}:${loc.start.column}:${loc.end.line}:${loc.end.column}`;
  }
}
function getFunctionName$1(instrValue, defaultValue) {
  var _a;
  switch (instrValue.kind) {
    case "FunctionExpression":
      return (_a = instrValue.name) !== null && _a !== void 0
        ? _a
        : defaultValue;
    case "ObjectMethod":
      return defaultValue;
  }
}
function* eachInstructionLValue(instr) {
  if (instr.lvalue !== null) {
    yield instr.lvalue;
  }
  yield* eachInstructionValueLValue(instr.value);
}
function* eachInstructionValueLValue(value) {
  switch (value.kind) {
    case "DeclareContext":
    case "StoreContext":
    case "DeclareLocal":
    case "StoreLocal": {
      yield value.lvalue.place;
      break;
    }
    case "Destructure": {
      yield* eachPatternOperand(value.lvalue.pattern);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield value.lvalue;
      break;
    }
  }
}
function* eachInstructionOperand(instr) {
  yield* eachInstructionValueOperand(instr.value);
}
function* eachInstructionValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "NewExpression":
    case "CallExpression": {
      yield instrValue.callee;
      yield* eachCallArgument(instrValue.args);
      break;
    }
    case "BinaryExpression": {
      yield instrValue.left;
      yield instrValue.right;
      break;
    }
    case "MethodCall": {
      yield instrValue.receiver;
      yield instrValue.property;
      yield* eachCallArgument(instrValue.args);
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      yield instrValue.place;
      break;
    }
    case "StoreLocal": {
      yield instrValue.value;
      break;
    }
    case "StoreContext": {
      yield instrValue.lvalue.place;
      yield instrValue.value;
      break;
    }
    case "Destructure": {
      yield instrValue.value;
      break;
    }
    case "PropertyLoad": {
      yield instrValue.object;
      break;
    }
    case "PropertyDelete": {
      yield instrValue.object;
      break;
    }
    case "PropertyStore": {
      yield instrValue.object;
      yield instrValue.value;
      break;
    }
    case "ComputedLoad": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedDelete": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedStore": {
      yield instrValue.object;
      yield instrValue.property;
      yield instrValue.value;
      break;
    }
    case "UnaryExpression": {
      yield instrValue.value;
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        yield instrValue.tag;
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            yield attribute.place;
            break;
          }
          case "JsxSpreadAttribute": {
            yield attribute.argument;
            break;
          }
          default: {
            assertExhaustive(
              attribute,
              `Unexpected attribute kind '${attribute.kind}'`,
            );
          }
        }
      }
      if (instrValue.children) {
        yield* instrValue.children;
      }
      break;
    }
    case "JsxFragment": {
      yield* instrValue.children;
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          yield property.key.name;
        }
        yield property.place;
      }
      break;
    }
    case "ArrayExpression": {
      for (const element of instrValue.elements) {
        if (element.kind === "Identifier") {
          yield element;
        } else if (element.kind === "Spread") {
          yield element.place;
        }
      }
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      yield* instrValue.loweredFunc.dependencies;
      break;
    }
    case "TaggedTemplateExpression": {
      yield instrValue.tag;
      break;
    }
    case "TypeCastExpression": {
      yield instrValue.value;
      break;
    }
    case "TemplateLiteral": {
      yield* instrValue.subexprs;
      break;
    }
    case "Await": {
      yield instrValue.value;
      break;
    }
    case "NextIterableOf": {
      yield instrValue.value;
      break;
    }
    case "NextPropertyOf": {
      yield instrValue.value;
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield instrValue.value;
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            yield dep.root.value;
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      yield instrValue.decl;
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction kind '${instrValue.kind}'`,
      );
    }
  }
}
function* eachCallArgument(args) {
  for (const arg of args) {
    if (arg.kind === "Identifier") {
      yield arg;
    } else {
      yield arg.place;
    }
  }
}
function doesPatternContainSpreadElement(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
  return false;
}
function* eachPatternOperand(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          yield item;
        } else if (item.kind === "Spread") {
          yield item.place;
        } else if (item.kind === "Hole") {
          continue;
        } else {
          assertExhaustive(item, `Unexpected item kind '${item.kind}'`);
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          yield property.place;
        } else if (property.kind === "Spread") {
          yield property.place;
        } else {
          assertExhaustive(property, `Unexpected item kind '${property.kind}'`);
        }
      }
      break;
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
}
function mapInstructionLValues(instr, fn) {
  switch (instr.value.kind) {
    case "DeclareLocal":
    case "StoreLocal": {
      const lvalue = instr.value.lvalue;
      lvalue.place = fn(lvalue.place);
      break;
    }
    case "Destructure": {
      mapPatternOperands(instr.value.lvalue.pattern, fn);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instr.value.lvalue = fn(instr.value.lvalue);
      break;
    }
  }
  if (instr.lvalue !== null) {
    instr.lvalue = fn(instr.lvalue);
  }
}
function mapInstructionOperands(instr, fn) {
  mapInstructionValueOperands(instr.value, fn);
}
function mapInstructionValueOperands(instrValue, fn) {
  switch (instrValue.kind) {
    case "BinaryExpression": {
      instrValue.left = fn(instrValue.left);
      instrValue.right = fn(instrValue.right);
      break;
    }
    case "PropertyLoad": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyDelete": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "ComputedLoad": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedDelete": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      instrValue.place = fn(instrValue.place);
      break;
    }
    case "StoreLocal": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StoreContext": {
      instrValue.lvalue.place = fn(instrValue.lvalue.place);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "Destructure": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "NewExpression":
    case "CallExpression": {
      instrValue.callee = fn(instrValue.callee);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "MethodCall": {
      instrValue.receiver = fn(instrValue.receiver);
      instrValue.property = fn(instrValue.property);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "UnaryExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        instrValue.tag = fn(instrValue.tag);
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            attribute.place = fn(attribute.place);
            break;
          }
          case "JsxSpreadAttribute": {
            attribute.argument = fn(attribute.argument);
            break;
          }
          default: {
            assertExhaustive(
              attribute,
              `Unexpected attribute kind '${attribute.kind}'`,
            );
          }
        }
      }
      if (instrValue.children) {
        instrValue.children = instrValue.children.map((p) => fn(p));
      }
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          property.key.name = fn(property.key.name);
        }
        property.place = fn(property.place);
      }
      break;
    }
    case "ArrayExpression": {
      instrValue.elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return fn(element);
        } else if (element.kind === "Spread") {
          element.place = fn(element.place);
          return element;
        } else {
          return element;
        }
      });
      break;
    }
    case "JsxFragment": {
      instrValue.children = instrValue.children.map((e) => fn(e));
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      instrValue.loweredFunc.dependencies =
        instrValue.loweredFunc.dependencies.map((d) => fn(d));
      break;
    }
    case "TaggedTemplateExpression": {
      instrValue.tag = fn(instrValue.tag);
      break;
    }
    case "TypeCastExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "TemplateLiteral": {
      instrValue.subexprs = instrValue.subexprs.map(fn);
      break;
    }
    case "Await": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "NextIterableOf": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "NextPropertyOf": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            dep.root.value = fn(dep.root.value);
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      instrValue.decl = fn(instrValue.decl);
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive(instrValue, "Unexpected instruction kind");
    }
  }
}
function mapCallArguments(args, fn) {
  return args.map((arg) => {
    if (arg.kind === "Identifier") {
      return fn(arg);
    } else {
      arg.place = fn(arg.place);
      return arg;
    }
  });
}
function mapPatternOperands(pattern, fn) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      pattern.items = pattern.items.map((item) => {
        if (item.kind === "Identifier") {
          return fn(item);
        } else if (item.kind === "Spread") {
          item.place = fn(item.place);
          return item;
        } else {
          return item;
        }
      });
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        property.place = fn(property.place);
      }
      break;
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
}
function mapTerminalSuccessors(terminal, fn) {
  switch (terminal.kind) {
    case "goto": {
      const target = fn(terminal.block);
      return {
        kind: "goto",
        block: target,
        variant: terminal.variant,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "if": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      const fallthrough =
        terminal.fallthrough !== null ? fn(terminal.fallthrough) : null;
      return {
        kind: "if",
        test: terminal.test,
        consequent: consequent,
        alternate: alternate,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "branch": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      return {
        kind: "branch",
        test: terminal.test,
        consequent: consequent,
        alternate: alternate,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "switch": {
      const cases = terminal.cases.map((case_) => {
        const target = fn(case_.block);
        return { test: case_.test, block: target };
      });
      const fallthrough =
        terminal.fallthrough !== null ? fn(terminal.fallthrough) : null;
      return {
        kind: "switch",
        test: terminal.test,
        cases: cases,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "logical": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "logical",
        test: test,
        fallthrough: fallthrough,
        operator: terminal.operator,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "ternary": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "ternary",
        test: test,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "optional": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "optional",
        optional: terminal.optional,
        test: test,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "return": {
      return {
        kind: "return",
        loc: terminal.loc,
        value: terminal.value,
        id: makeInstructionId(0),
      };
    }
    case "throw": {
      return terminal;
    }
    case "do-while": {
      const loop = fn(terminal.loop);
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "do-while",
        loc: terminal.loc,
        test: test,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "while": {
      const test = fn(terminal.test);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "while",
        loc: terminal.loc,
        test: test,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for": {
      const init = fn(terminal.init);
      const test = fn(terminal.test);
      const update = terminal.update !== null ? fn(terminal.update) : null;
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for",
        loc: terminal.loc,
        init: init,
        test: test,
        update: update,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for-of": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-of",
        loc: terminal.loc,
        init: init,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for-in": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-in",
        loc: terminal.loc,
        init: init,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "label": {
      const block = fn(terminal.block);
      const fallthrough =
        terminal.fallthrough !== null ? fn(terminal.fallthrough) : null;
      return {
        kind: "label",
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "sequence": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "sequence",
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "maybe-throw": {
      const continuation = fn(terminal.continuation);
      const handler = fn(terminal.handler);
      return {
        kind: "maybe-throw",
        continuation: continuation,
        handler: handler,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "try": {
      const block = fn(terminal.block);
      const handler = fn(terminal.handler);
      const fallthrough =
        terminal.fallthrough !== null ? fn(terminal.fallthrough) : null;
      return {
        kind: "try",
        block: block,
        handlerBinding: terminal.handlerBinding,
        handler: handler,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "scope": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "scope",
        scope: terminal.scope,
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "unsupported": {
      return terminal;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function terminalFallthrough(terminal) {
  switch (terminal.kind) {
    case "maybe-throw":
    case "branch":
    case "goto":
    case "return":
    case "throw":
    case "unsupported": {
      return null;
    }
    case "try":
    case "do-while":
    case "for-of":
    case "for-in":
    case "for":
    case "if":
    case "label":
    case "logical":
    case "optional":
    case "sequence":
    case "switch":
    case "ternary":
    case "while":
    case "scope": {
      return terminal.fallthrough;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function mapOptionalFallthroughs(terminal, fn) {
  switch (terminal.kind) {
    case "maybe-throw":
    case "branch":
    case "goto":
    case "return":
    case "throw":
    case "unsupported": {
      return;
    }
    case "do-while": {
      terminal.fallthrough;
      break;
    }
    case "for-of": {
      terminal.fallthrough;
      break;
    }
    case "for-in": {
      terminal.fallthrough;
      break;
    }
    case "for": {
      terminal.fallthrough;
      break;
    }
    case "logical": {
      terminal.fallthrough;
      break;
    }
    case "optional": {
      terminal.fallthrough;
      break;
    }
    case "ternary": {
      terminal.fallthrough;
      break;
    }
    case "while": {
      terminal.fallthrough;
      break;
    }
    case "scope": {
      terminal.fallthrough;
      break;
    }
    case "switch": {
      if (terminal.fallthrough !== null) {
        terminal.fallthrough = fn(terminal.fallthrough);
      } else {
        terminal.fallthrough = null;
      }
      break;
    }
    case "if": {
      if (terminal.fallthrough !== null) {
        terminal.fallthrough = fn(terminal.fallthrough);
      } else {
        terminal.fallthrough = null;
      }
      break;
    }
    case "label": {
      if (terminal.fallthrough !== null) {
        terminal.fallthrough = fn(terminal.fallthrough);
      } else {
        terminal.fallthrough = null;
      }
      break;
    }
    case "sequence": {
      terminal.fallthrough;
      break;
    }
    case "try": {
      if (terminal.fallthrough !== null) {
        terminal.fallthrough = fn(terminal.fallthrough);
      } else {
        terminal.fallthrough = null;
      }
      break;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function* eachTerminalSuccessor(terminal) {
  switch (terminal.kind) {
    case "goto": {
      yield terminal.block;
      break;
    }
    case "if": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "branch": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "switch": {
      for (const case_ of terminal.cases) {
        yield case_.block;
      }
      break;
    }
    case "optional":
    case "ternary":
    case "logical": {
      yield terminal.test;
      break;
    }
    case "return": {
      break;
    }
    case "throw": {
      break;
    }
    case "do-while": {
      yield terminal.loop;
      break;
    }
    case "while": {
      yield terminal.test;
      break;
    }
    case "for": {
      yield terminal.init;
      break;
    }
    case "for-of": {
      yield terminal.init;
      break;
    }
    case "for-in": {
      yield terminal.init;
      break;
    }
    case "label": {
      yield terminal.block;
      break;
    }
    case "sequence": {
      yield terminal.block;
      break;
    }
    case "maybe-throw": {
      yield terminal.continuation;
      yield terminal.handler;
      break;
    }
    case "try": {
      yield terminal.block;
      break;
    }
    case "scope": {
      yield terminal.block;
      break;
    }
    case "unsupported":
      break;
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function mapTerminalOperands(terminal, fn) {
  switch (terminal.kind) {
    case "if": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "branch": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "switch": {
      terminal.test = fn(terminal.test);
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        case_.test = fn(case_.test);
      }
      break;
    }
    case "return":
    case "throw": {
      terminal.value = fn(terminal.value);
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        terminal.handlerBinding = fn(terminal.handlerBinding);
      } else {
        terminal.handlerBinding = null;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unsupported":
    case "scope": {
      break;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function* eachTerminalOperand(terminal) {
  switch (terminal.kind) {
    case "if": {
      yield terminal.test;
      break;
    }
    case "branch": {
      yield terminal.test;
      break;
    }
    case "switch": {
      yield terminal.test;
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        yield case_.test;
      }
      break;
    }
    case "return":
    case "throw": {
      yield terminal.value;
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        yield terminal.handlerBinding;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unsupported":
    case "scope": {
      break;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function assertConsistentIdentifiers(fn) {
  const identifiers = new Map();
  const assignments = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      validate(identifiers, phi.id);
      for (const [, operand] of phi.operands) {
        validate(identifiers, operand);
      }
    }
    for (const instr of block.instructions) {
      CompilerError.invariant(instr.lvalue.identifier.name === null, {
        reason: `Expected all lvalues to be temporaries`,
        description: `Found named lvalue '${instr.lvalue.identifier.name}'`,
        loc: instr.lvalue.loc,
        suggestions: null,
      });
      CompilerError.invariant(!assignments.has(instr.lvalue.identifier.id), {
        reason: `Expected lvalues to be assigned exactly once`,
        description: `Found duplicate assignment of '${printPlace(instr.lvalue)}'`,
        loc: instr.lvalue.loc,
        suggestions: null,
      });
      assignments.add(instr.lvalue.identifier.id);
      for (const operand of eachInstructionLValue(instr)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      validate(identifiers, operand.identifier, operand.loc);
    }
  }
}
function validate(identifiers, identifier, loc = null) {
  const previous = identifiers.get(identifier.id);
  if (previous === undefined) {
    identifiers.set(identifier.id, identifier);
  } else {
    CompilerError.invariant(identifier === previous, {
      reason: `Duplicate identifier object`,
      description: `Found duplicate identifier object for id ${identifier.id}`,
      loc: loc !== null && loc !== void 0 ? loc : GeneratedSource,
      suggestions: null,
    });
  }
}
function assertTerminalSuccessorsExist(fn) {
  for (const [, block] of fn.body.blocks) {
    mapTerminalSuccessors(block.terminal, (successor) => {
      var _a;
      CompilerError.invariant(fn.body.blocks.has(successor), {
        reason: `Terminal successor references unknown block`,
        description: `Block bb${successor} does not exist for terminal '${printTerminal(block.terminal)}'`,
        loc:
          (_a = block.terminal.loc) !== null && _a !== void 0
            ? _a
            : GeneratedSource,
        suggestions: null,
      });
      return successor;
    });
  }
}
var NODE_ENV = process.env.NODE_ENV;
var invariant = function (condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        "Minified exception occurred; use the non-minified dev environment " +
          "for the full error message and additional helpful warnings.",
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function () {
          return args[argIndex++];
        }),
      );
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
};
var invariant_1 = invariant;
var invariant$1 = getDefaultExportFromCjs(invariant_1);
function assertValidMutableRanges(fn) {
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const [, operand] of phi.operands) {
        visitIdentifier(operand);
      }
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        visitIdentifier(operand.identifier);
      }
      for (const operand of eachInstructionOperand(instr)) {
        visitIdentifier(operand.identifier);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitIdentifier(operand.identifier);
    }
  }
}
function visitIdentifier(identifier) {
  validateMutableRange(identifier.mutableRange);
  if (identifier.scope !== null) {
    validateMutableRange(identifier.scope.range);
  }
}
function validateMutableRange(mutableRange) {
  invariant$1(
    (mutableRange.start === 0 && mutableRange.end === 0) ||
      mutableRange.end > mutableRange.start,
    "Identifier scope mutableRange was invalid: [%s:%s]",
    mutableRange.start,
    mutableRange.end,
  );
}
function Ok(val) {
  return new OkImpl(val);
}
class OkImpl {
  constructor(val) {
    this.val = val;
  }
  map(fn) {
    return new OkImpl(fn(this.val));
  }
  mapErr(_fn) {
    return this;
  }
  mapOr(_fallback, fn) {
    return fn(this.val);
  }
  mapOrElse(_fallback, fn) {
    return fn(this.val);
  }
  andThen(fn) {
    return fn(this.val);
  }
  and(res) {
    return res;
  }
  or(_res) {
    return this;
  }
  orElse(_fn) {
    return this;
  }
  isOk() {
    return true;
  }
  isErr() {
    return false;
  }
  expect(_msg) {
    return this.val;
  }
  expectErr(msg) {
    throw new Error(`${msg}: ${this.val}`);
  }
  unwrap() {
    return this.val;
  }
  unwrapOr(_fallback) {
    return this.val;
  }
  unwrapOrElse(_fallback) {
    return this.val;
  }
  unwrapErr() {
    if (this.val instanceof Error) {
      throw this.val;
    }
    throw new Error(`Can't unwrap \`Ok\` to \`Err\`: ${this.val}`);
  }
}
function Err(val) {
  return new ErrImpl(val);
}
class ErrImpl {
  constructor(val) {
    this.val = val;
  }
  map(_fn) {
    return this;
  }
  mapErr(fn) {
    return new ErrImpl(fn(this.val));
  }
  mapOr(fallback, _fn) {
    return fallback;
  }
  mapOrElse(fallback, _fn) {
    return fallback();
  }
  andThen(_fn) {
    return this;
  }
  and(_res) {
    return this;
  }
  or(res) {
    return res;
  }
  orElse(fn) {
    return fn(this.val);
  }
  isOk() {
    return false;
  }
  isErr() {
    return true;
  }
  expect(msg) {
    throw new Error(`${msg}: ${this.val}`);
  }
  expectErr(_msg) {
    return this.val;
  }
  unwrap() {
    if (this.val instanceof Error) {
      throw this.val;
    }
    throw new Error(`Can't unwrap \`Err\` to \`Ok\`: ${this.val}`);
  }
  unwrapOr(fallback) {
    return fallback;
  }
  unwrapOrElse(fallback) {
    return fallback(this.val);
  }
  unwrapErr() {
    return this.val;
  }
}
var _HIRBuilder_instances,
  _HIRBuilder_completed,
  _HIRBuilder_current,
  _HIRBuilder_entry,
  _HIRBuilder_scopes,
  _HIRBuilder_context,
  _HIRBuilder_bindings,
  _HIRBuilder_env,
  _HIRBuilder_exceptionHandlerStack,
  _HIRBuilder_resolveBabelBinding;
function newBlock(id, kind) {
  return { id: id, kind: kind, instructions: [] };
}
class HIRBuilder {
  get nextIdentifierId() {
    return __classPrivateFieldGet(this, _HIRBuilder_env, "f").nextIdentifierId;
  }
  get context() {
    return __classPrivateFieldGet(this, _HIRBuilder_context, "f");
  }
  get bindings() {
    return __classPrivateFieldGet(this, _HIRBuilder_bindings, "f");
  }
  get environment() {
    return __classPrivateFieldGet(this, _HIRBuilder_env, "f");
  }
  constructor(env, parentFunction, bindings = null, context = null) {
    _HIRBuilder_instances.add(this);
    _HIRBuilder_completed.set(this, new Map());
    _HIRBuilder_current.set(this, void 0);
    _HIRBuilder_entry.set(this, void 0);
    _HIRBuilder_scopes.set(this, []);
    _HIRBuilder_context.set(this, void 0);
    _HIRBuilder_bindings.set(this, void 0);
    _HIRBuilder_env.set(this, void 0);
    _HIRBuilder_exceptionHandlerStack.set(this, []);
    this.errors = new CompilerError();
    __classPrivateFieldSet(this, _HIRBuilder_env, env, "f");
    __classPrivateFieldSet(
      this,
      _HIRBuilder_bindings,
      bindings !== null && bindings !== void 0 ? bindings : new Map(),
      "f",
    );
    this.parentFunction = parentFunction;
    __classPrivateFieldSet(
      this,
      _HIRBuilder_context,
      context !== null && context !== void 0 ? context : [],
      "f",
    );
    __classPrivateFieldSet(
      this,
      _HIRBuilder_entry,
      makeBlockId(env.nextBlockId),
      "f",
    );
    __classPrivateFieldSet(
      this,
      _HIRBuilder_current,
      newBlock(__classPrivateFieldGet(this, _HIRBuilder_entry, "f"), "block"),
      "f",
    );
  }
  currentBlockKind() {
    return __classPrivateFieldGet(this, _HIRBuilder_current, "f").kind;
  }
  push(instruction) {
    __classPrivateFieldGet(this, _HIRBuilder_current, "f").instructions.push(
      instruction,
    );
    const exceptionHandler = __classPrivateFieldGet(
      this,
      _HIRBuilder_exceptionHandlerStack,
      "f",
    ).at(-1);
    if (exceptionHandler !== undefined) {
      const continuationBlock = this.reserve(this.currentBlockKind());
      this.terminateWithContinuation(
        {
          kind: "maybe-throw",
          continuation: continuationBlock.id,
          handler: exceptionHandler,
          id: makeInstructionId(0),
          loc: instruction.loc,
        },
        continuationBlock,
      );
    }
  }
  enterTryCatch(handler, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_exceptionHandlerStack, "f").push(
      handler,
    );
    fn();
    __classPrivateFieldGet(this, _HIRBuilder_exceptionHandlerStack, "f").pop();
  }
  resolveThrowHandler() {
    const handler = __classPrivateFieldGet(
      this,
      _HIRBuilder_exceptionHandlerStack,
      "f",
    ).at(-1);
    return handler !== null && handler !== void 0 ? handler : null;
  }
  makeTemporary() {
    const id = this.nextIdentifierId;
    return {
      id: id,
      name: null,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      scope: null,
      type: makeType(),
    };
  }
  resolveGlobal(path) {
    const name = path.node.name;
    const resolvedGlobal = __classPrivateFieldGet(
      this,
      _HIRBuilder_env,
      "f",
    ).getGlobalDeclaration(name);
    if (resolvedGlobal) {
      return Object.assign(Object.assign({}, resolvedGlobal), { name: name });
    } else {
      return { kind: "Poly", name: name };
    }
  }
  resolveIdentifier(path) {
    const originalName = path.node.name;
    const babelBinding = __classPrivateFieldGet(
      this,
      _HIRBuilder_instances,
      "m",
      _HIRBuilder_resolveBabelBinding,
    ).call(this, path);
    if (babelBinding == null) {
      return null;
    }
    const resolvedBinding = this.resolveBinding(babelBinding.identifier);
    if (resolvedBinding.name && resolvedBinding.name.value !== originalName) {
      babelBinding.scope.rename(originalName, resolvedBinding.name.value);
    }
    return resolvedBinding;
  }
  isContextIdentifier(path) {
    const binding = __classPrivateFieldGet(
      this,
      _HIRBuilder_instances,
      "m",
      _HIRBuilder_resolveBabelBinding,
    ).call(this, path);
    if (binding) {
      return __classPrivateFieldGet(
        this,
        _HIRBuilder_env,
        "f",
      ).isContextIdentifier(binding.identifier);
    } else {
      return false;
    }
  }
  resolveBinding(node) {
    const originalName = node.name;
    let name = originalName;
    let index = 0;
    while (true) {
      const mapping = __classPrivateFieldGet(
        this,
        _HIRBuilder_bindings,
        "f",
      ).get(name);
      if (mapping === undefined) {
        const id = this.nextIdentifierId;
        const identifier = {
          id: id,
          name: makeIdentifierName(name),
          mutableRange: {
            start: makeInstructionId(0),
            end: makeInstructionId(0),
          },
          scope: null,
          type: makeType(),
        };
        __classPrivateFieldGet(this, _HIRBuilder_bindings, "f").set(name, {
          node: node,
          identifier: identifier,
        });
        return identifier;
      } else if (mapping.node === node) {
        return mapping.identifier;
      } else {
        name = `${originalName}_${index++}`;
      }
    }
  }
  build() {
    var _a, _b;
    let ir = {
      blocks: __classPrivateFieldGet(this, _HIRBuilder_completed, "f"),
      entry: __classPrivateFieldGet(this, _HIRBuilder_entry, "f"),
    };
    const rpoBlocks = getReversePostorderedBlocks(ir);
    for (const [id, block] of ir.blocks) {
      if (
        !rpoBlocks.has(id) &&
        block.instructions.some(
          (instr) => instr.value.kind === "FunctionExpression",
        )
      ) {
        CompilerError.throwTodo({
          reason: `Support functions with unreachable code that may contain hoisted declarations`,
          loc:
            (_b =
              (_a = block.instructions[0]) === null || _a === void 0
                ? void 0
                : _a.loc) !== null && _b !== void 0
              ? _b
              : block.terminal.loc,
          description: null,
          suggestions: null,
        });
      }
    }
    ir.blocks = rpoBlocks;
    removeUnreachableForUpdates(ir);
    removeUnreachableFallthroughs(ir);
    removeDeadDoWhileStatements(ir);
    removeUnnecessaryTryCatch(ir);
    markInstructionIds(ir);
    markPredecessors(ir);
    return ir;
  }
  terminate(terminal, nextBlockKind) {
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    if (nextBlockKind) {
      const nextId = __classPrivateFieldGet(
        this,
        _HIRBuilder_env,
        "f",
      ).nextBlockId;
      __classPrivateFieldSet(
        this,
        _HIRBuilder_current,
        newBlock(nextId, nextBlockKind),
        "f",
      );
    }
  }
  terminateWithContinuation(terminal, continuation) {
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    __classPrivateFieldSet(this, _HIRBuilder_current, continuation, "f");
  }
  reserve(kind) {
    return newBlock(
      makeBlockId(
        __classPrivateFieldGet(this, _HIRBuilder_env, "f").nextBlockId,
      ),
      kind,
    );
  }
  complete(block, terminal) {
    const { id: blockId, kind: kind, instructions: instructions } = block;
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
  }
  enterReserved(wip, fn) {
    const current = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldSet(this, _HIRBuilder_current, wip, "f");
    const terminal = fn();
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    __classPrivateFieldSet(this, _HIRBuilder_current, current, "f");
  }
  enter(nextBlockKind, fn) {
    const wip = this.reserve(nextBlockKind);
    this.enterReserved(wip, () => fn(wip.id));
    return wip.id;
  }
  label(label, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "label",
      breakBlock: breakBlock,
      label: label,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "label" &&
        last.label === label &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    return value;
  }
  switch(label, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "switch",
      breakBlock: breakBlock,
      label: label,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "switch" &&
        last.label === label &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    return value;
  }
  loop(label, continueBlock, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "loop",
      label: label,
      continueBlock: continueBlock,
      breakBlock: breakBlock,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "loop" &&
        last.label === label &&
        last.continueBlock === continueBlock &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched loops",
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    return value;
  }
  lookupBreak(label) {
    for (
      let ii = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length - 1;
      ii >= 0;
      ii--
    ) {
      const scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[ii];
      if (
        (label === null &&
          (scope.kind === "loop" || scope.kind === "switch")) ||
        label === scope.label
      ) {
        return scope.breakBlock;
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop or switch to be in scope",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
  lookupContinue(label) {
    for (
      let ii = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length - 1;
      ii >= 0;
      ii--
    ) {
      const scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[ii];
      if (scope.kind === "loop") {
        if (label === null || label === scope.label) {
          return scope.continueBlock;
        }
      } else if (label !== null && scope.label === label) {
        CompilerError.invariant(false, {
          reason: "Continue may only refer to a labeled loop",
          description: null,
          loc: null,
          suggestions: null,
        });
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop to be in scope",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
}
(_HIRBuilder_completed = new WeakMap()),
  (_HIRBuilder_current = new WeakMap()),
  (_HIRBuilder_entry = new WeakMap()),
  (_HIRBuilder_scopes = new WeakMap()),
  (_HIRBuilder_context = new WeakMap()),
  (_HIRBuilder_bindings = new WeakMap()),
  (_HIRBuilder_env = new WeakMap()),
  (_HIRBuilder_exceptionHandlerStack = new WeakMap()),
  (_HIRBuilder_instances = new WeakSet()),
  (_HIRBuilder_resolveBabelBinding = function _HIRBuilder_resolveBabelBinding(
    path,
  ) {
    const originalName = path.node.name;
    const binding = path.scope.getBinding(originalName);
    if (binding == null) {
      return null;
    }
    const outerBinding =
      this.parentFunction.scope.parent.getBinding(originalName);
    if (binding === outerBinding) {
      return null;
    }
    return binding;
  });
function removeUnreachableForUpdates(fn) {
  for (const [, block] of fn.blocks) {
    if (
      block.terminal.kind === "for" &&
      block.terminal.update !== null &&
      !fn.blocks.has(block.terminal.update)
    ) {
      block.terminal.update = null;
    }
  }
}
function removeUnreachableFallthroughs(func) {
  const visited = new Set();
  for (const [_, block] of func.blocks) {
    visited.add(block.id);
  }
  for (const [_, block] of func.blocks) {
    mapOptionalFallthroughs(block.terminal, (fallthrough) => {
      if (visited.has(fallthrough)) {
        return fallthrough;
      } else {
        return null;
      }
    });
  }
}
function removeDeadDoWhileStatements(func) {
  const visited = new Set();
  for (const [_, block] of func.blocks) {
    visited.add(block.id);
  }
  for (const [_, block] of func.blocks) {
    if (block.terminal.kind === "do-while") {
      if (!visited.has(block.terminal.test)) {
        block.terminal = {
          kind: "goto",
          block: block.terminal.loop,
          variant: GotoVariant.Break,
          id: block.terminal.id,
          loc: block.terminal.loc,
        };
      }
    }
  }
}
function reversePostorderBlocks(func) {
  const rpoBlocks = getReversePostorderedBlocks(func);
  func.blocks = rpoBlocks;
}
function getReversePostorderedBlocks(func) {
  const visited = new Set();
  const postorder = [];
  function visit(blockId) {
    if (visited.has(blockId)) {
      return;
    }
    visited.add(blockId);
    const block = func.blocks.get(blockId);
    const { terminal: terminal } = block;
    switch (terminal.kind) {
      case "return":
      case "throw": {
        break;
      }
      case "goto": {
        visit(terminal.block);
        break;
      }
      case "if": {
        const { consequent: consequent, alternate: alternate } = terminal;
        visit(alternate);
        visit(consequent);
        break;
      }
      case "branch": {
        const { consequent: consequent, alternate: alternate } = terminal;
        visit(alternate);
        visit(consequent);
        break;
      }
      case "switch": {
        const { cases: cases } = terminal;
        for (const case_ of [...cases].reverse()) {
          visit(case_.block);
        }
        break;
      }
      case "optional":
      case "ternary":
      case "logical": {
        visit(terminal.test);
        break;
      }
      case "do-while": {
        visit(terminal.loop);
        break;
      }
      case "while": {
        visit(terminal.test);
        break;
      }
      case "for":
      case "for-in":
      case "for-of": {
        visit(terminal.init);
        break;
      }
      case "label": {
        visit(terminal.block);
        break;
      }
      case "sequence": {
        visit(terminal.block);
        break;
      }
      case "maybe-throw": {
        visit(terminal.handler);
        visit(terminal.continuation);
        break;
      }
      case "try": {
        visit(terminal.block);
        break;
      }
      case "scope": {
        visit(terminal.block);
        break;
      }
      case "unsupported": {
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind '${terminal.kind}'`,
        );
      }
    }
    postorder.push(blockId);
  }
  visit(func.entry);
  const blocks = new Map();
  for (const blockId of postorder.reverse()) {
    blocks.set(blockId, func.blocks.get(blockId));
  }
  return blocks;
}
function markInstructionIds(func) {
  let id = 0;
  const visited = new Set();
  for (const [_, block] of func.blocks) {
    for (const instr of block.instructions) {
      CompilerError.invariant(!visited.has(instr), {
        reason: `${printInstruction(instr)} already visited!`,
        description: null,
        loc: instr.loc,
        suggestions: null,
      });
      visited.add(instr);
      instr.id = makeInstructionId(++id);
    }
    block.terminal.id = makeInstructionId(++id);
  }
}
function markPredecessors(func) {
  for (const [, block] of func.blocks) {
    block.preds.clear();
  }
  const visited = new Set();
  function visit(blockId, prevBlock) {
    const block = func.blocks.get(blockId);
    if (prevBlock) {
      block.preds.add(prevBlock.id);
    }
    if (visited.has(blockId)) {
      return;
    }
    visited.add(blockId);
    const { terminal: terminal } = block;
    for (const successor of eachTerminalSuccessor(terminal)) {
      visit(successor, block);
    }
  }
  visit(func.entry, null);
}
function removeUnnecessaryTryCatch(fn) {
  for (const [, block] of fn.blocks) {
    if (
      block.terminal.kind === "try" &&
      !fn.blocks.has(block.terminal.handler)
    ) {
      block.terminal = {
        kind: "goto",
        block: block.terminal.block,
        id: makeInstructionId(0),
        loc: block.terminal.loc,
        variant: GotoVariant.Break,
      };
    }
  }
}
function createTemporaryPlace(env) {
  return {
    kind: "Identifier",
    identifier: {
      id: env.nextIdentifierId,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      name: null,
      scope: null,
      type: makeType(),
    },
    reactive: false,
    effect: exports.Effect.Unknown,
    loc: GeneratedSource,
  };
}
const PRIMITIVE_TYPE = { kind: "Primitive" };
let nextAnonId = 0;
function createAnonId() {
  return `<generated_${nextAnonId++}>`;
}
function addFunction(registry, properties, fn, id = null) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(
    registry,
    shapeId,
    properties,
    Object.assign(Object.assign({}, fn), { hookKind: null }),
  );
  return { kind: "Function", return: fn.returnType, shapeId: shapeId };
}
function addHook(registry, fn, id = null) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(registry, shapeId, [], fn);
  return { kind: "Function", return: fn.returnType, shapeId: shapeId };
}
function addObject(registry, id, properties) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(registry, shapeId, properties, null);
  return { kind: "Object", shapeId: shapeId };
}
function addShape(registry, id, properties, functionType) {
  const shape = { properties: new Map(properties), functionType: functionType };
  CompilerError.invariant(!registry.has(id), {
    reason: `[ObjectShape] Could not add shape to registry: name ${id} already exists.`,
    description: null,
    loc: null,
    suggestions: null,
  });
  registry.set(id, shape);
  return shape;
}
const BuiltInArrayId = "BuiltInArray";
const BuiltInObjectId = "BuiltInObject";
const BuiltInUseStateId = "BuiltInUseState";
const BuiltInSetStateId = "BuiltInSetState";
const BuiltInUseRefId = "BuiltInUseRefId";
const BuiltInRefValueId = "BuiltInRefValue";
const BuiltInMixedReadonlyId = "BuiltInMixedReadonly";
const BuiltInUseEffectHookId = "BuiltInUseEffectHook";
const BuiltInUseLayoutEffectHookId = "BuiltInUseLayoutEffectHook";
const BuiltInUseInsertionEffectHookId = "BuiltInUseInsertionEffectHook";
const BuiltInUseOperatorId = "BuiltInUseOperator";
const BUILTIN_SHAPES = new Map();
addObject(BUILTIN_SHAPES, BuiltInArrayId, [
  [
    "at",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [exports.Effect.Read],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.Capture,
      returnValueKind: exports.ValueKind.Mutable,
    }),
  ],
  [
    "concat",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Capture,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Mutable,
    }),
  ],
  ["length", PRIMITIVE_TYPE],
  [
    "push",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Capture,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: exports.Effect.Store,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "every",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Immutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "some",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Immutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "find",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "findIndex",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Immutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "join",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.ConditionallyMutate,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInObjectId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseStateId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: exports.Effect.Read,
        returnValueKind: exports.ValueKind.Immutable,
      },
      BuiltInSetStateId,
    ),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseRefId, [
  ["current", { kind: "Object", shapeId: BuiltInRefValueId }],
]);
addObject(BUILTIN_SHAPES, BuiltInRefValueId, [
  ["*", { kind: "Object", shapeId: BuiltInRefValueId }],
]);
addObject(BUILTIN_SHAPES, BuiltInMixedReadonlyId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Mutable,
      noAlias: true,
    }),
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: exports.Effect.ConditionallyMutate,
      returnValueKind: exports.ValueKind.Mutable,
      noAlias: true,
    }),
  ],
  ["*", { kind: "Object", shapeId: BuiltInMixedReadonlyId }],
]);
const DefaultMutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: exports.Effect.ConditionallyMutate,
    returnType: { kind: "Poly" },
    calleeEffect: exports.Effect.Read,
    hookKind: "Custom",
    returnValueKind: exports.ValueKind.Mutable,
  },
  "DefaultMutatingHook",
);
const DefaultNonmutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: exports.Effect.Freeze,
    returnType: { kind: "Poly" },
    calleeEffect: exports.Effect.Read,
    hookKind: "Custom",
    returnValueKind: exports.ValueKind.Frozen,
  },
  "DefaultNonmutatingHook",
);
function lower$1(func, env, bindings = null, capturedRefs = [], parent = null) {
  var _a, _b, _c;
  const builder = new HIRBuilder(
    env,
    parent !== null && parent !== void 0 ? parent : func,
    bindings,
    capturedRefs,
  );
  const context = [];
  for (const ref of capturedRefs !== null && capturedRefs !== void 0
    ? capturedRefs
    : []) {
    context.push({
      kind: "Identifier",
      identifier: builder.resolveBinding(ref),
      effect: exports.Effect.Unknown,
      reactive: false,
      loc: (_a = ref.loc) !== null && _a !== void 0 ? _a : GeneratedSource,
    });
  }
  let id = null;
  if (func.isFunctionDeclaration() || func.isFunctionExpression()) {
    const idNode = func.get("id");
    if (hasNode(idNode)) {
      id = idNode.node.name;
    }
  }
  const params = [];
  func.get("params").forEach((param) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (param.isIdentifier()) {
      const identifier = builder.resolveIdentifier(param);
      if (identifier === null) {
        builder.errors.push({
          reason: `(BuildHIR::lower) Could not find binding for param '${param.node.name}'`,
          severity: exports.ErrorSeverity.Invariant,
          loc: (_a = param.node.loc) !== null && _a !== void 0 ? _a : null,
          suggestions: null,
        });
        return;
      }
      const place = {
        kind: "Identifier",
        identifier: identifier,
        effect: exports.Effect.Unknown,
        reactive: false,
        loc:
          (_b = param.node.loc) !== null && _b !== void 0
            ? _b
            : GeneratedSource,
      };
      params.push(place);
    } else if (
      param.isObjectPattern() ||
      param.isArrayPattern() ||
      param.isAssignmentPattern()
    ) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary(),
        effect: exports.Effect.Unknown,
        reactive: false,
        loc:
          (_c = param.node.loc) !== null && _c !== void 0
            ? _c
            : GeneratedSource,
      };
      params.push(place);
      lowerAssignment(
        builder,
        (_d = param.node.loc) !== null && _d !== void 0 ? _d : GeneratedSource,
        InstructionKind.Let,
        param,
        place,
        "Assignment",
      );
    } else if (param.isRestElement()) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary(),
        effect: exports.Effect.Unknown,
        reactive: false,
        loc:
          (_e = param.node.loc) !== null && _e !== void 0
            ? _e
            : GeneratedSource,
      };
      params.push({ kind: "Spread", place: place });
      lowerAssignment(
        builder,
        (_f = param.node.loc) !== null && _f !== void 0 ? _f : GeneratedSource,
        InstructionKind.Let,
        param.get("argument"),
        place,
        "Assignment",
      );
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lower) Handle ${param.node.type} params`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_g = param.node.loc) !== null && _g !== void 0 ? _g : null,
        suggestions: null,
      });
    }
  });
  let directives = [];
  const body = func.get("body");
  if (body.isExpression()) {
    const fallthrough = builder.reserve("block");
    const terminal = {
      kind: "return",
      loc: GeneratedSource,
      value: lowerExpressionToTemporary(builder, body),
      id: makeInstructionId(0),
    };
    builder.terminateWithContinuation(terminal, fallthrough);
  } else if (body.isBlockStatement()) {
    lowerStatement(builder, body);
    directives = body.get("directives").map((d) => d.node.value.value);
  } else {
    builder.errors.push({
      reason: `Unexpected function body kind: ${body.type}}. This error is likely caused by a bug in React Compiler. Please file an issue`,
      severity: exports.ErrorSeverity.InvalidJS,
      loc: (_b = body.node.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
  }
  if (builder.errors.hasErrors()) {
    return Err(builder.errors);
  }
  builder.terminate(
    {
      kind: "return",
      loc: GeneratedSource,
      value: lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: undefined,
        loc: GeneratedSource,
      }),
      id: makeInstructionId(0),
    },
    null,
  );
  return Ok({
    id: id,
    params: params,
    fnType: parent == null ? env.fnType : "Other",
    returnType: null,
    body: builder.build(),
    context: context,
    generator: func.node.generator === true,
    async: func.node.async === true,
    loc: (_c = func.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
    env: env,
    effects: null,
    directives: directives,
  });
}
function lowerStatement(builder, stmtPath, label = null) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _0,
    _1,
    _2,
    _3,
    _4,
    _5,
    _6,
    _7,
    _8,
    _9,
    _10,
    _11,
    _12,
    _13,
    _14,
    _15,
    _16,
    _17,
    _18,
    _19,
    _20,
    _21,
    _22,
    _23,
    _24,
    _25,
    _26,
    _27,
    _28;
  const stmtNode = stmtPath.node;
  switch (stmtNode.type) {
    case "ThrowStatement": {
      const stmt = stmtPath;
      const value = lowerExpressionToTemporary(builder, stmt.get("argument"));
      const handler = builder.resolveThrowHandler();
      if (handler != null) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch",
          severity: exports.ErrorSeverity.Todo,
          loc: (_a = stmt.node.loc) !== null && _a !== void 0 ? _a : null,
          suggestions: null,
        });
      }
      const terminal = {
        kind: "throw",
        value: value,
        id: makeInstructionId(0),
        loc:
          (_b = stmt.node.loc) !== null && _b !== void 0 ? _b : GeneratedSource,
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "ReturnStatement": {
      const stmt = stmtPath;
      const argument = stmt.get("argument");
      let value;
      if (argument.node === null) {
        value = lowerValueToTemporary(builder, {
          kind: "Primitive",
          value: undefined,
          loc: GeneratedSource,
        });
      } else {
        value = lowerExpressionToTemporary(builder, argument);
      }
      const terminal = {
        kind: "return",
        loc:
          (_c = stmt.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
        value: value,
        id: makeInstructionId(0),
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "IfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const consequentBlock = builder.enter("block", (_blockId) => {
        var _a;
        const consequent = stmt.get("consequent");
        lowerStatement(builder, consequent);
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = consequent.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      let alternateBlock;
      const alternate = stmt.get("alternate");
      if (hasNode(alternate)) {
        alternateBlock = builder.enter("block", (_blockId) => {
          var _a, _b;
          lowerStatement(builder, alternate);
          return {
            kind: "goto",
            block: continuationBlock.id,
            variant: GotoVariant.Break,
            id: makeInstructionId(0),
            loc:
              (_b =
                (_a = alternate.node) === null || _a === void 0
                  ? void 0
                  : _a.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
          };
        });
      } else {
        alternateBlock = continuationBlock.id;
      }
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "if",
        test: test,
        consequent: consequentBlock,
        alternate: alternateBlock,
        fallthrough: continuationBlock.id,
        id: makeInstructionId(0),
        loc:
          (_d = stmt.node.loc) !== null && _d !== void 0 ? _d : GeneratedSource,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "BlockStatement": {
      const stmt = stmtPath;
      const statements = stmt.get("body");
      const hoistableIdentifiers = new Set();
      for (const [, binding] of Object.entries(stmt.scope.bindings)) {
        if (binding.kind !== "param") {
          hoistableIdentifiers.add(binding.identifier);
        }
      }
      for (const s of statements) {
        const willHoist = new Set();
        let fnDepth = s.isFunctionDeclaration() ? 1 : 0;
        const withFunctionContext = {
          enter: () => {
            fnDepth++;
          },
          exit: () => {
            fnDepth--;
          },
        };
        s.traverse({
          FunctionExpression: withFunctionContext,
          FunctionDeclaration: withFunctionContext,
          ArrowFunctionExpression: withFunctionContext,
          ObjectMethod: withFunctionContext,
          Identifier(id) {
            const id2 = id;
            if (
              !id2.isReferencedIdentifier() &&
              id.parent.type !== "AssignmentExpression"
            ) {
              return;
            }
            const binding = id.scope.getBinding(id.node.name);
            if (
              binding != null &&
              hoistableIdentifiers.has(binding.identifier) &&
              (fnDepth > 0 || binding.kind === "hoisted")
            ) {
              willHoist.add(id);
            }
          },
        });
        s.traverse({
          Identifier(path) {
            if (hoistableIdentifiers.has(path.node)) {
              hoistableIdentifiers.delete(path.node);
            }
          },
        });
        for (const id of willHoist) {
          const binding = stmt.scope.getBinding(id.node.name);
          CompilerError.invariant(binding != null, {
            reason: "Expected to find binding for hoisted identifier",
            description: `Could not find a binding for ${id.node.name}`,
            suggestions: null,
            loc:
              (_e = id.node.loc) !== null && _e !== void 0
                ? _e
                : GeneratedSource,
          });
          if (builder.environment.isHoistedIdentifier(binding.identifier)) {
            continue;
          }
          if (!binding.path.isVariableDeclarator()) {
            builder.errors.push({
              severity: exports.ErrorSeverity.Todo,
              reason: "Unsupported declaration type for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.path.type}`,
              suggestions: null,
              loc:
                (_f = id.parentPath.node.loc) !== null && _f !== void 0
                  ? _f
                  : GeneratedSource,
            });
            continue;
          } else if (!binding.path.get("id").isIdentifier()) {
            builder.errors.push({
              severity: exports.ErrorSeverity.Todo,
              reason: "Unsupported variable declaration type for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.path.get("id").type}`,
              suggestions: null,
              loc:
                (_g = id.parentPath.node.loc) !== null && _g !== void 0
                  ? _g
                  : GeneratedSource,
            });
            continue;
          } else if (binding.kind !== "const" && binding.kind !== "var") {
            builder.errors.push({
              severity: exports.ErrorSeverity.Todo,
              reason: "Handle non-const declarations for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.kind}`,
              suggestions: null,
              loc:
                (_h = id.parentPath.node.loc) !== null && _h !== void 0
                  ? _h
                  : GeneratedSource,
            });
            continue;
          }
          const identifier = builder.resolveIdentifier(id);
          const place = {
            effect: exports.Effect.Unknown,
            identifier: identifier,
            kind: "Identifier",
            reactive: false,
            loc:
              (_j = id.node.loc) !== null && _j !== void 0
                ? _j
                : GeneratedSource,
          };
          lowerValueToTemporary(builder, {
            kind: "DeclareContext",
            lvalue: { kind: InstructionKind.HoistedConst, place: place },
            loc:
              (_k = id.node.loc) !== null && _k !== void 0
                ? _k
                : GeneratedSource,
          });
          builder.environment.addHoistedIdentifier(binding.identifier);
        }
        lowerStatement(builder, s);
      }
      return;
    }
    case "BreakStatement": {
      const stmt = stmtPath;
      const block = builder.lookupBreak(
        (_m =
          (_l = stmt.node.label) === null || _l === void 0
            ? void 0
            : _l.name) !== null && _m !== void 0
          ? _m
          : null,
      );
      builder.terminate(
        {
          kind: "goto",
          block: block,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_o = stmt.node.loc) !== null && _o !== void 0
              ? _o
              : GeneratedSource,
        },
        "block",
      );
      return;
    }
    case "ContinueStatement": {
      const stmt = stmtPath;
      const block = builder.lookupContinue(
        (_q =
          (_p = stmt.node.label) === null || _p === void 0
            ? void 0
            : _p.name) !== null && _q !== void 0
          ? _q
          : null,
      );
      builder.terminate(
        {
          kind: "goto",
          block: block,
          variant: GotoVariant.Continue,
          id: makeInstructionId(0),
          loc:
            (_r = stmt.node.loc) !== null && _r !== void 0
              ? _r
              : GeneratedSource,
        },
        "block",
      );
      return;
    }
    case "ForStatement": {
      const stmt = stmtPath;
      const testBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.enter("loop", (_blockId) => {
        var _a, _b, _c, _d;
        const init = stmt.get("init");
        if (!init.isVariableDeclaration()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerStatement) Handle non-variable initialization in ForStatement",
            severity: exports.ErrorSeverity.Todo,
            loc: (_a = stmt.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
          });
          return {
            kind: "unsupported",
            id: makeInstructionId(0),
            loc:
              (_c =
                (_b = init.node) === null || _b === void 0
                  ? void 0
                  : _b.loc) !== null && _c !== void 0
                ? _c
                : GeneratedSource,
          };
        }
        lowerStatement(builder, init);
        return {
          kind: "goto",
          block: testBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_d = init.node.loc) !== null && _d !== void 0
              ? _d
              : GeneratedSource,
        };
      });
      let updateBlock = null;
      const update = stmt.get("update");
      if (hasNode(update)) {
        updateBlock = builder.enter("loop", (_blockId) => {
          var _a, _b;
          lowerExpressionToTemporary(builder, update);
          return {
            kind: "goto",
            block: testBlock.id,
            variant: GotoVariant.Break,
            id: makeInstructionId(0),
            loc:
              (_b =
                (_a = update.node) === null || _a === void 0
                  ? void 0
                  : _a.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
          };
        });
      }
      const bodyBlock = builder.enter("block", (_blockId) =>
        builder.loop(
          label,
          updateBlock !== null && updateBlock !== void 0
            ? updateBlock
            : testBlock.id,
          continuationBlock.id,
          () => {
            var _a;
            const body = stmt.get("body");
            lowerStatement(builder, body);
            return {
              kind: "goto",
              block:
                updateBlock !== null && updateBlock !== void 0
                  ? updateBlock
                  : testBlock.id,
              variant: GotoVariant.Continue,
              id: makeInstructionId(0),
              loc:
                (_a = body.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          },
        ),
      );
      builder.terminateWithContinuation(
        {
          kind: "for",
          loc:
            (_s = stmtNode.loc) !== null && _s !== void 0
              ? _s
              : GeneratedSource,
          init: initBlock,
          test: testBlock.id,
          update: updateBlock,
          loop: bodyBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        testBlock,
      );
      const test = stmt.get("test");
      if (test.node == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle empty test in ForStatement`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_t = stmt.node.loc) !== null && _t !== void 0 ? _t : null,
          suggestions: null,
        });
      } else {
        builder.terminateWithContinuation(
          {
            kind: "branch",
            test: lowerExpressionToTemporary(builder, test),
            consequent: bodyBlock,
            alternate: continuationBlock.id,
            id: makeInstructionId(0),
            loc:
              (_u = stmt.node.loc) !== null && _u !== void 0
                ? _u
                : GeneratedSource,
          },
          continuationBlock,
        );
      }
      return;
    }
    case "WhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, conditionalBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: conditionalBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        }),
      );
      const loc =
        (_v = stmt.node.loc) !== null && _v !== void 0 ? _v : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "while",
          loc: loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        conditionalBlock,
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test: test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        id: makeInstructionId(0),
        loc:
          (_w = stmt.node.loc) !== null && _w !== void 0 ? _w : GeneratedSource,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "LabeledStatement": {
      const stmt = stmtPath;
      const label = stmt.node.label.name;
      const body = stmt.get("body");
      switch (body.node.type) {
        case "ForInStatement":
        case "ForOfStatement":
        case "ForStatement":
        case "WhileStatement":
        case "DoWhileStatement": {
          lowerStatement(builder, stmt.get("body"), label);
          break;
        }
        default: {
          const continuationBlock = builder.reserve("block");
          const block = builder.enter("block", () => {
            var _a;
            const body = stmt.get("body");
            builder.label(label, continuationBlock.id, () => {
              lowerStatement(builder, body);
            });
            return {
              kind: "goto",
              block: continuationBlock.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = body.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "label",
              block: block,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc:
                (_x = stmt.node.loc) !== null && _x !== void 0
                  ? _x
                  : GeneratedSource,
            },
            continuationBlock,
          );
        }
      }
      return;
    }
    case "SwitchStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      let fallthrough = continuationBlock.id;
      const cases = [];
      let hasDefault = false;
      for (let ii = stmt.get("cases").length - 1; ii >= 0; ii--) {
        const case_ = stmt.get("cases")[ii];
        const testExpr = case_.get("test");
        if (testExpr.node == null) {
          if (hasDefault) {
            builder.errors.push({
              reason: `Expected at most one \`default\` branch in SwitchStatement, this code should have failed to parse. This error is likely caused by a bug in React Compiler. Please file an issue`,
              severity: exports.ErrorSeverity.InvalidJS,
              loc: (_y = case_.node.loc) !== null && _y !== void 0 ? _y : null,
              suggestions: null,
            });
            break;
          }
          hasDefault = true;
        }
        const block = builder.enter("block", (_blockId) =>
          builder.switch(label, continuationBlock.id, () => {
            var _a;
            case_
              .get("consequent")
              .forEach((consequent) => lowerStatement(builder, consequent));
            return {
              kind: "goto",
              block: fallthrough,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = case_.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          }),
        );
        let test = null;
        if (hasNode(testExpr)) {
          test = lowerReorderableExpression(builder, testExpr);
        }
        cases.push({ test: test, block: block });
        fallthrough = block;
      }
      cases.reverse();
      if (!hasDefault) {
        cases.push({ test: null, block: continuationBlock.id });
      }
      const test = lowerExpressionToTemporary(
        builder,
        stmt.get("discriminant"),
      );
      builder.terminateWithContinuation(
        {
          kind: "switch",
          test: test,
          cases: cases,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc:
            (_z = stmt.node.loc) !== null && _z !== void 0
              ? _z
              : GeneratedSource,
        },
        continuationBlock,
      );
      return;
    }
    case "VariableDeclaration": {
      const stmt = stmtPath;
      const nodeKind = stmt.node.kind;
      if (nodeKind === "var") {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${nodeKind} kinds in VariableDeclaration`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_0 = stmt.node.loc) !== null && _0 !== void 0 ? _0 : null,
          suggestions: null,
        });
        return;
      }
      const kind =
        nodeKind === "let" ? InstructionKind.Let : InstructionKind.Const;
      for (const declaration of stmt.get("declarations")) {
        const id = declaration.get("id");
        const init = declaration.get("init");
        if (hasNode(init)) {
          const value = lowerExpressionToTemporary(builder, init);
          lowerAssignment(
            builder,
            (_1 = stmt.node.loc) !== null && _1 !== void 0
              ? _1
              : GeneratedSource,
            kind,
            id,
            value,
            id.isObjectPattern() || id.isArrayPattern()
              ? "Destructure"
              : "Assignment",
          );
        } else if (id.isIdentifier()) {
          const identifier = builder.resolveIdentifier(id);
          if (identifier == null) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
              severity: exports.ErrorSeverity.Invariant,
              loc: (_2 = id.node.loc) !== null && _2 !== void 0 ? _2 : null,
              suggestions: null,
            });
          } else {
            const place = {
              effect: exports.Effect.Unknown,
              identifier: identifier,
              kind: "Identifier",
              reactive: false,
              loc:
                (_3 = id.node.loc) !== null && _3 !== void 0
                  ? _3
                  : GeneratedSource,
            };
            if (builder.isContextIdentifier(id)) {
              if (kind === InstructionKind.Const) {
                const declRangeStart = declaration.parentPath.node.start;
                builder.errors.push({
                  reason: `Invalid declaration kind (const), this variable is reassigned later`,
                  severity: exports.ErrorSeverity.InvalidJS,
                  loc: (_4 = id.node.loc) !== null && _4 !== void 0 ? _4 : null,
                  suggestions: [
                    {
                      description: "Change to let",
                      op: exports.CompilerSuggestionOperation.Replace,
                      range: [declRangeStart, declRangeStart + 5],
                      text: "let",
                    },
                  ],
                });
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareContext",
                lvalue: { kind: InstructionKind.Let, place: place },
                loc:
                  (_5 = id.node.loc) !== null && _5 !== void 0
                    ? _5
                    : GeneratedSource,
              });
            } else {
              const typeAnnotation = id.get("typeAnnotation");
              let type;
              if (typeAnnotation.isTSTypeAnnotation()) {
                const typePath = typeAnnotation.get("typeAnnotation");
                type = typePath.node;
              } else if (typeAnnotation.isTypeAnnotation()) {
                const typePath = typeAnnotation.get("typeAnnotation");
                type = typePath.node;
              } else {
                type = null;
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareLocal",
                lvalue: { kind: kind, place: place },
                type: type,
                loc:
                  (_6 = id.node.loc) !== null && _6 !== void 0
                    ? _6
                    : GeneratedSource,
              });
            }
          }
        } else {
          builder.errors.push({
            reason: `Expected variable declaration to be an identifier if no initializer was provided. This error is likely caused by a bug in React Compiler. Please file an issue`,
            severity: exports.ErrorSeverity.InvalidJS,
            loc: (_7 = stmt.node.loc) !== null && _7 !== void 0 ? _7 : null,
            suggestions: null,
          });
        }
      }
      return;
    }
    case "ExpressionStatement": {
      const stmt = stmtPath;
      const expression = stmt.get("expression");
      lowerExpressionToTemporary(builder, expression);
      return;
    }
    case "DoWhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_loopBlockId) =>
        builder.loop(label, conditionalBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: conditionalBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        }),
      );
      const loc =
        (_8 = stmt.node.loc) !== null && _8 !== void 0 ? _8 : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "do-while",
          loc: loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        conditionalBlock,
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test: test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        id: makeInstructionId(0),
        loc: loc,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "FunctionDeclaration": {
      const stmt = stmtPath;
      stmt.skip();
      CompilerError.invariant(stmt.get("id").type === "Identifier", {
        reason: "function declarations must have a name",
        description: null,
        loc: (_9 = stmt.node.loc) !== null && _9 !== void 0 ? _9 : null,
        suggestions: null,
      });
      const id = stmt.get("id");
      const fn = lowerValueToTemporary(
        builder,
        lowerFunctionToValue(builder, stmt),
      );
      lowerAssignment(
        builder,
        (_10 = stmt.node.loc) !== null && _10 !== void 0
          ? _10
          : GeneratedSource,
        InstructionKind.Let,
        id,
        fn,
        "Assignment",
      );
      return;
    }
    case "ForOfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        }),
      );
      const loc =
        (_11 = stmt.node.loc) !== null && _11 !== void 0
          ? _11
          : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-of",
          loc: loc,
          init: initBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        initBlock,
      );
      const left = stmt.get("left");
      const leftLoc =
        (_12 = left.node.loc) !== null && _12 !== void 0
          ? _12
          : GeneratedSource;
      let test;
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForOfStatement, got ${declarations.length}`,
          description: null,
          loc: (_13 = left.node.loc) !== null && _13 !== void 0 ? _13 : null,
          suggestions: null,
        });
        const id = declarations[0].get("id");
        const nextIterableOf = lowerValueToTemporary(builder, {
          kind: "NextIterableOf",
          loc: leftLoc,
          value: value,
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          InstructionKind.Let,
          id,
          nextIterableOf,
          "Assignment",
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${left.type} inits in ForOfStatement`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_14 = left.node.loc) !== null && _14 !== void 0 ? _14 : null,
          suggestions: null,
        });
        return;
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test: test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          loc:
            (_15 = stmt.node.loc) !== null && _15 !== void 0
              ? _15
              : GeneratedSource,
        },
        continuationBlock,
      );
      return;
    }
    case "ForInStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        }),
      );
      const loc =
        (_16 = stmt.node.loc) !== null && _16 !== void 0
          ? _16
          : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-in",
          loc: loc,
          init: initBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        initBlock,
      );
      const left = stmt.get("left");
      const leftLoc =
        (_17 = left.node.loc) !== null && _17 !== void 0
          ? _17
          : GeneratedSource;
      let test;
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForInStatement, got ${declarations.length}`,
          description: null,
          loc: (_18 = left.node.loc) !== null && _18 !== void 0 ? _18 : null,
          suggestions: null,
        });
        const id = declarations[0].get("id");
        const nextIterableOf = lowerValueToTemporary(builder, {
          kind: "NextPropertyOf",
          loc: leftLoc,
          value: value,
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          InstructionKind.Let,
          id,
          nextIterableOf,
          "Assignment",
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${left.type} inits in ForInStatement`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_19 = left.node.loc) !== null && _19 !== void 0 ? _19 : null,
          suggestions: null,
        });
        return;
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test: test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          loc:
            (_20 = stmt.node.loc) !== null && _20 !== void 0
              ? _20
              : GeneratedSource,
        },
        continuationBlock,
      );
      return;
    }
    case "DebuggerStatement": {
      const stmt = stmtPath;
      const loc =
        (_21 = stmt.node.loc) !== null && _21 !== void 0
          ? _21
          : GeneratedSource;
      builder.push({
        id: makeInstructionId(0),
        lvalue: buildTemporaryPlace(builder, loc),
        value: { kind: "Debugger", loc: loc },
        loc: loc,
      });
      return;
    }
    case "EmptyStatement": {
      return;
    }
    case "TryStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const handlerPath = stmt.get("handler");
      if (!hasNode(handlerPath)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement without a catch clause`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_22 = stmt.node.loc) !== null && _22 !== void 0 ? _22 : null,
          suggestions: null,
        });
        return;
      }
      if (hasNode(stmt.get("finalizer"))) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement with a finalizer ('finally') clause`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_23 = stmt.node.loc) !== null && _23 !== void 0 ? _23 : null,
          suggestions: null,
        });
      }
      const handlerBindingPath = handlerPath.get("param");
      let handlerBinding = null;
      if (hasNode(handlerBindingPath)) {
        const place = {
          kind: "Identifier",
          identifier: builder.makeTemporary(),
          effect: exports.Effect.Unknown,
          reactive: false,
          loc:
            (_24 = handlerBindingPath.node.loc) !== null && _24 !== void 0
              ? _24
              : GeneratedSource,
        };
        promoteTemporary(place.identifier);
        lowerValueToTemporary(builder, {
          kind: "DeclareLocal",
          lvalue: {
            kind: InstructionKind.Catch,
            place: Object.assign({}, place),
          },
          type: null,
          loc:
            (_25 = handlerBindingPath.node.loc) !== null && _25 !== void 0
              ? _25
              : GeneratedSource,
        });
        handlerBinding = { path: handlerBindingPath, place: place };
      }
      const handler = builder.enter("catch", (_blockId) => {
        var _a, _b;
        if (handlerBinding !== null) {
          lowerAssignment(
            builder,
            (_a = handlerBinding.path.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
            InstructionKind.Catch,
            handlerBinding.path,
            Object.assign({}, handlerBinding.place),
            "Assignment",
          );
        }
        lowerStatement(builder, handlerPath.get("body"));
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_b = handlerPath.node.loc) !== null && _b !== void 0
              ? _b
              : GeneratedSource,
        };
      });
      const block = builder.enter("block", (_blockId) => {
        var _a;
        const block = stmt.get("block");
        builder.enterTryCatch(handler, () => {
          lowerStatement(builder, block);
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Try,
          id: makeInstructionId(0),
          loc:
            (_a = block.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "try",
          block: block,
          handlerBinding:
            handlerBinding !== null
              ? Object.assign({}, handlerBinding.place)
              : null,
          handler: handler,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc:
            (_26 = stmt.node.loc) !== null && _26 !== void 0
              ? _26
              : GeneratedSource,
        },
        continuationBlock,
      );
      return;
    }
    case "TypeAlias":
    case "TSTypeAliasDeclaration": {
      return;
    }
    case "ClassDeclaration":
    case "DeclareClass":
    case "DeclareExportAllDeclaration":
    case "DeclareExportDeclaration":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareOpaqueType":
    case "DeclareTypeAlias":
    case "DeclareVariable":
    case "EnumDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TSDeclareFunction":
    case "TSEnumDeclaration":
    case "TSExportAssignment":
    case "TSImportEqualsDeclaration":
    case "TSInterfaceDeclaration":
    case "TSModuleDeclaration":
    case "TSNamespaceExportDeclaration":
    case "WithStatement": {
      builder.errors.push({
        reason: `(BuildHIR::lowerStatement) Handle ${stmtPath.type} statements`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_27 = stmtPath.node.loc) !== null && _27 !== void 0 ? _27 : null,
        suggestions: null,
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc:
          (_28 = stmtPath.node.loc) !== null && _28 !== void 0
            ? _28
            : GeneratedSource,
        node: stmtPath.node,
      });
      return;
    }
    default: {
      return assertExhaustive(
        stmtNode,
        `Unsupported statement kind '${stmtNode.type}'`,
      );
    }
  }
}
function lowerObjectMethod(builder, property) {
  var _a;
  const loc =
    (_a = property.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const loweredFunc = lowerFunction(builder, property);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: property.node, loc: loc };
  }
  return { kind: "ObjectMethod", loc: loc, loweredFunc: loweredFunc };
}
function lowerObjectPropertyKey(builder, property) {
  var _a, _b;
  const key = property.get("key");
  if (key.isStringLiteral()) {
    return { kind: "string", name: key.node.value };
  } else if (property.node.computed && key.isExpression()) {
    if (!key.isIdentifier()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key.type} key in ObjectExpression`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_a = key.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
      return null;
    }
    const place = lowerExpressionToTemporary(builder, key);
    return { kind: "computed", name: place };
  } else if (key.isIdentifier()) {
    return { kind: "identifier", name: key.node.name };
  }
  builder.errors.push({
    reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key.type} key in ObjectExpression`,
    severity: exports.ErrorSeverity.Todo,
    loc: (_b = key.node.loc) !== null && _b !== void 0 ? _b : null,
    suggestions: null,
  });
  return null;
}
function lowerExpression(builder, exprPath) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _0,
    _1,
    _2,
    _3,
    _4,
    _5,
    _6,
    _7,
    _8,
    _9,
    _10,
    _11,
    _12,
    _13,
    _14,
    _15;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  switch (exprNode.type) {
    case "Identifier": {
      const expr = exprPath;
      const place = lowerIdentifier(builder, expr);
      return { kind: getLoadKind(builder, expr), place: place, loc: exprLoc };
    }
    case "NullLiteral": {
      return { kind: "Primitive", value: null, loc: exprLoc };
    }
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral": {
      const expr = exprPath;
      const value = expr.node.value;
      return { kind: "Primitive", value: value, loc: exprLoc };
    }
    case "ObjectExpression": {
      const expr = exprPath;
      const propertyPaths = expr.get("properties");
      const properties = [];
      for (const propertyPath of propertyPaths) {
        if (propertyPath.isObjectProperty()) {
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          const valuePath = propertyPath.get("value");
          if (!valuePath.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valuePath.type} values in ObjectExpression`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_b = valuePath.node.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
            continue;
          }
          const value = lowerExpressionToTemporary(builder, valuePath);
          properties.push({
            kind: "ObjectProperty",
            type: "property",
            place: value,
            key: loweredKey,
          });
        } else if (propertyPath.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            propertyPath.get("argument"),
          );
          properties.push({ kind: "Spread", place: place });
        } else if (propertyPath.isObjectMethod()) {
          const method = lowerObjectMethod(builder, propertyPath);
          const place = lowerValueToTemporary(builder, method);
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          properties.push({
            kind: "ObjectProperty",
            type: "method",
            place: place,
            key: loweredKey,
          });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${propertyPath.type} properties in ObjectExpression`,
            severity: exports.ErrorSeverity.Todo,
            loc:
              (_c = propertyPath.node.loc) !== null && _c !== void 0
                ? _c
                : null,
            suggestions: null,
          });
          continue;
        }
      }
      return { kind: "ObjectExpression", properties: properties, loc: exprLoc };
    }
    case "ArrayExpression": {
      const expr = exprPath;
      let elements = [];
      for (const element of expr.get("elements")) {
        if (element.node == null) {
          elements.push({ kind: "Hole" });
          continue;
        } else if (element.isExpression()) {
          elements.push(lowerExpressionToTemporary(builder, element));
        } else if (element.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            element.get("argument"),
          );
          elements.push({ kind: "Spread", place: place });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${element.type} elements in ArrayExpression`,
            severity: exports.ErrorSeverity.Todo,
            loc: (_d = element.node.loc) !== null && _d !== void 0 ? _d : null,
            suggestions: null,
          });
          continue;
        }
      }
      return { kind: "ArrayExpression", elements: elements, loc: exprLoc };
    }
    case "NewExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected Expression, got ${calleePath.type} in NewExpression (v8 intrinsics not supported): ${calleePath.type}. This error is likely caused by a bug in React Compiler. Please file an issue`,
          severity: exports.ErrorSeverity.InvalidJS,
          loc: (_e = calleePath.node.loc) !== null && _e !== void 0 ? _e : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const callee = lowerExpressionToTemporary(builder, calleePath);
      const args = lowerArguments(builder, expr.get("arguments"));
      return {
        kind: "NewExpression",
        callee: callee,
        args: args,
        loc: exprLoc,
      };
    }
    case "OptionalCallExpression": {
      const expr = exprPath;
      return lowerOptionalCallExpression(builder, expr, null);
    }
    case "CallExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected Expression, got ${calleePath.type} in CallExpression (v8 intrinsics not supported). This error is likely caused by a bug in React Compiler. Please file an issue`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_f = calleePath.node.loc) !== null && _f !== void 0 ? _f : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (calleePath.isMemberExpression()) {
        const memberExpr = lowerMemberExpression(builder, calleePath);
        const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "MethodCall",
          receiver: memberExpr.object,
          property: Object.assign({}, propertyPlace),
          args: args,
          loc: exprLoc,
        };
      } else {
        const callee = lowerExpressionToTemporary(builder, calleePath);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "CallExpression",
          callee: callee,
          args: args,
          loc: exprLoc,
        };
      }
    }
    case "BinaryExpression": {
      const expr = exprPath;
      const leftPath = expr.get("left");
      if (!leftPath.isExpression()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Expected Expression, got ${leftPath.type} lval in BinaryExpression`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_g = leftPath.node.loc) !== null && _g !== void 0 ? _g : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = lowerExpressionToTemporary(builder, leftPath);
      const right = lowerExpressionToTemporary(builder, expr.get("right"));
      const operator = expr.node.operator;
      return {
        kind: "BinaryExpression",
        operator: operator,
        left: left,
        right: right,
        loc: exprLoc,
      };
    }
    case "SequenceExpression": {
      const expr = exprPath;
      const exprLoc =
        (_h = expr.node.loc) !== null && _h !== void 0 ? _h : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const place = buildTemporaryPlace(builder, exprLoc);
      const sequenceBlock = builder.enter("sequence", (_) => {
        var _a;
        let last = null;
        for (const item of expr.get("expressions")) {
          last = lowerExpressionToTemporary(builder, item);
        }
        if (last === null) {
          builder.errors.push({
            reason: `Expected SequenceExpression to have at least one expression. This error is likely caused by a bug in React Compiler. Please file an issue`,
            severity: exports.ErrorSeverity.InvalidJS,
            loc: (_a = expr.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
          });
        } else {
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: last,
            type: null,
            loc: exprLoc,
          });
        }
        return {
          kind: "goto",
          id: makeInstructionId(0),
          block: continuationBlock.id,
          loc: exprLoc,
          variant: GotoVariant.Break,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "sequence",
          block: sequenceBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock,
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "ConditionalExpression": {
      const expr = exprPath;
      const exprLoc =
        (_j = expr.node.loc) !== null && _j !== void 0 ? _j : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc);
      const consequentBlock = builder.enter("value", (_blockId) => {
        var _a;
        const consequentPath = expr.get("consequent");
        const consequent = lowerExpressionToTemporary(builder, consequentPath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: consequent,
          type: null,
          loc: exprLoc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = consequentPath.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      const alternateBlock = builder.enter("value", (_blockId) => {
        var _a;
        const alternatePath = expr.get("alternate");
        const alternate = lowerExpressionToTemporary(builder, alternatePath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: alternate,
          type: null,
          loc: exprLoc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = alternatePath.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          loc: exprLoc,
        },
        testBlock,
      );
      const testPlace = lowerExpressionToTemporary(builder, expr.get("test"));
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, testPlace),
          consequent: consequentBlock,
          alternate: alternateBlock,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock,
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "LogicalExpression": {
      const expr = exprPath;
      const exprLoc =
        (_k = expr.node.loc) !== null && _k !== void 0 ? _k : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc);
      const leftPlace = buildTemporaryPlace(
        builder,
        (_l = expr.get("left").node.loc) !== null && _l !== void 0
          ? _l
          : GeneratedSource,
      );
      const consequent = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: Object.assign({}, leftPlace),
          type: null,
          loc: leftPlace.loc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc: leftPlace.loc,
        };
      });
      const alternate = builder.enter("value", () => {
        const right = lowerExpressionToTemporary(builder, expr.get("right"));
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: Object.assign({}, right),
          type: null,
          loc: right.loc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc: right.loc,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "logical",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          operator: expr.node.operator,
          loc: exprLoc,
        },
        testBlock,
      );
      const leftValue = lowerExpressionToTemporary(builder, expr.get("left"));
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, leftPlace),
        value: { kind: "LoadLocal", place: leftValue, loc: exprLoc },
        loc: exprLoc,
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, leftPlace),
          consequent: consequent,
          alternate: alternate,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock,
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "AssignmentExpression": {
      const expr = exprPath;
      const operator = expr.node.operator;
      if (operator === "=") {
        const left = expr.get("left");
        return lowerAssignment(
          builder,
          (_m = left.node.loc) !== null && _m !== void 0 ? _m : GeneratedSource,
          InstructionKind.Reassign,
          left,
          lowerExpressionToTemporary(builder, expr.get("right")),
          left.isArrayPattern() || left.isObjectPattern()
            ? "Destructure"
            : "Assignment",
        );
      }
      const operators = {
        "+=": "+",
        "-=": "-",
        "/=": "/",
        "%=": "%",
        "*=": "*",
        "**=": "**",
        "&=": "&",
        "|=": "|",
        ">>=": ">>",
        ">>>=": ">>>",
        "<<=": "<<",
        "^=": "^",
      };
      const binaryOperator = operators[operator];
      if (binaryOperator == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle ${operator} operators in AssignmentExpression`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_o = expr.node.loc) !== null && _o !== void 0 ? _o : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = expr.get("left");
      const leftNode = left.node;
      switch (leftNode.type) {
        case "Identifier": {
          const leftExpr = left;
          const identifier = lowerIdentifier(builder, leftExpr);
          const leftPlace = lowerExpressionToTemporary(builder, leftExpr);
          const right = lowerExpressionToTemporary(builder, expr.get("right"));
          const binaryPlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: leftPlace,
            right: right,
            loc: exprLoc,
          });
          const kind = getStoreKind(builder, leftExpr);
          if (kind === "StoreLocal") {
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                place: Object.assign({}, identifier),
                kind: InstructionKind.Reassign,
              },
              value: Object.assign({}, binaryPlace),
              type: null,
              loc: exprLoc,
            });
            return { kind: "LoadLocal", place: identifier, loc: exprLoc };
          } else {
            lowerValueToTemporary(builder, {
              kind: "StoreContext",
              lvalue: {
                place: Object.assign({}, identifier),
                kind: InstructionKind.Reassign,
              },
              value: Object.assign({}, binaryPlace),
              loc: exprLoc,
            });
            return { kind: "LoadContext", place: identifier, loc: exprLoc };
          }
        }
        case "MemberExpression": {
          const leftExpr = left;
          const {
            object: object,
            property: property,
            value: value,
          } = lowerMemberExpression(builder, leftExpr);
          const previousValuePlace = lowerValueToTemporary(builder, value);
          const newValuePlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: Object.assign({}, previousValuePlace),
            right: lowerExpressionToTemporary(builder, expr.get("right")),
            loc:
              (_p = leftExpr.node.loc) !== null && _p !== void 0
                ? _p
                : GeneratedSource,
          });
          if (typeof property === "string") {
            return {
              kind: "PropertyStore",
              object: Object.assign({}, object),
              property: property,
              value: Object.assign({}, newValuePlace),
              loc:
                (_q = leftExpr.node.loc) !== null && _q !== void 0
                  ? _q
                  : GeneratedSource,
            };
          } else {
            return {
              kind: "ComputedStore",
              object: Object.assign({}, object),
              property: Object.assign({}, property),
              value: Object.assign({}, newValuePlace),
              loc:
                (_r = leftExpr.node.loc) !== null && _r !== void 0
                  ? _r
                  : GeneratedSource,
            };
          }
        }
        default: {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Expected Identifier or MemberExpression, got ${expr.type} lval in AssignmentExpression`,
            severity: exports.ErrorSeverity.Todo,
            loc: (_s = expr.node.loc) !== null && _s !== void 0 ? _s : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
      }
    }
    case "OptionalMemberExpression": {
      const expr = exprPath;
      const { value: value } = lowerOptionalMemberExpression(
        builder,
        expr,
        null,
      );
      return { kind: "LoadLocal", place: value, loc: value.loc };
    }
    case "MemberExpression": {
      const expr = exprPath;
      const { value: value } = lowerMemberExpression(builder, expr);
      const place = lowerValueToTemporary(builder, value);
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "JSXElement": {
      const expr = exprPath;
      const opening = expr.get("openingElement");
      const openingLoc =
        (_t = opening.node.loc) !== null && _t !== void 0
          ? _t
          : GeneratedSource;
      const tag = lowerJsxElementName(builder, opening.get("name"));
      const props = [];
      for (const attribute of opening.get("attributes")) {
        if (attribute.isJSXSpreadAttribute()) {
          const argument = lowerExpressionToTemporary(
            builder,
            attribute.get("argument"),
          );
          props.push({ kind: "JsxSpreadAttribute", argument: argument });
          continue;
        }
        if (!attribute.isJSXAttribute()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${attribute.type} attributes in JSXElement`,
            severity: exports.ErrorSeverity.Todo,
            loc:
              (_u = attribute.node.loc) !== null && _u !== void 0 ? _u : null,
            suggestions: null,
          });
          continue;
        }
        const namePath = attribute.get("name");
        let propName;
        if (namePath.isJSXIdentifier()) {
          propName = namePath.node.name;
          if (propName.indexOf(":") !== -1) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Unexpected colon in attribute name '${name}'`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_v = namePath.node.loc) !== null && _v !== void 0 ? _v : null,
              suggestions: null,
            });
          }
        } else {
          CompilerError.invariant(namePath.isJSXNamespacedName(), {
            reason: "Refinement",
            description: null,
            loc: (_w = namePath.node.loc) !== null && _w !== void 0 ? _w : null,
            suggestions: null,
          });
          const namespace = namePath.node.namespace.name;
          const name = namePath.node.name.name;
          propName = `${namespace}:${name}`;
        }
        const valueExpr = attribute.get("value");
        let value;
        if (valueExpr.isJSXElement() || valueExpr.isStringLiteral()) {
          value = lowerExpressionToTemporary(builder, valueExpr);
        } else if (valueExpr.type == null) {
          value = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: true,
            loc:
              (_x = attribute.node.loc) !== null && _x !== void 0
                ? _x
                : GeneratedSource,
          });
        } else {
          if (!valueExpr.isJSXExpressionContainer()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valueExpr.type} attribute values in JSXElement`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_z =
                  (_y = valueExpr.node) === null || _y === void 0
                    ? void 0
                    : _y.loc) !== null && _z !== void 0
                  ? _z
                  : null,
              suggestions: null,
            });
            continue;
          }
          const expression = valueExpr.get("expression");
          if (!expression.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${expression.type} expressions in JSXExpressionContainer within JSXElement`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_0 = valueExpr.node.loc) !== null && _0 !== void 0 ? _0 : null,
              suggestions: null,
            });
            continue;
          }
          value = lowerExpressionToTemporary(builder, expression);
        }
        props.push({ kind: "JsxAttribute", name: propName, place: value });
      }
      if (tag.kind === "BuiltinTag" && tag.name === "fbt") {
        const openingIdentifier = opening.get("name");
        const tagIdentifier = openingIdentifier.isJSXIdentifier()
          ? builder.resolveIdentifier(openingIdentifier)
          : null;
        if (tagIdentifier != null) {
          CompilerError.throwTodo({
            reason: `Support <fbt> tags where 'fbt' is a local variable instead of a global`,
            loc:
              (_1 = openingIdentifier.node.loc) !== null && _1 !== void 0
                ? _1
                : GeneratedSource,
            description: null,
            suggestions: null,
          });
        }
        const fbtEnumLocations = [];
        expr.traverse({
          JSXNamespacedName(path) {
            var _a;
            if (
              path.node.namespace.name === "fbt" &&
              path.node.name.name === "enum"
            ) {
              fbtEnumLocations.push(
                (_a = path.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
              );
            }
          },
        });
        if (fbtEnumLocations.length > 1) {
          CompilerError.throwTodo({
            reason: `Support <fbt> tags with multiple <fbt:enum> values`,
            loc:
              (_2 = fbtEnumLocations.at(-1)) !== null && _2 !== void 0
                ? _2
                : GeneratedSource,
            description: null,
            suggestions: null,
          });
        }
      }
      let children;
      if (tag.kind === "BuiltinTag" && tag.name === "fbt") {
        children = expr
          .get("children")
          .map((child) => {
            var _a;
            if (child.isJSXText()) {
              const text = child.node.value.replace(/[^\S\u00A0]+/g, " ");
              return lowerValueToTemporary(builder, {
                kind: "JSXText",
                value: text,
                loc:
                  (_a = child.node.loc) !== null && _a !== void 0
                    ? _a
                    : GeneratedSource,
              });
            }
            return lowerJsxElement(builder, child);
          })
          .filter(notNull);
      } else {
        children = expr
          .get("children")
          .map((child) => lowerJsxElement(builder, child))
          .filter(notNull);
      }
      return {
        kind: "JsxExpression",
        tag: tag,
        props: props,
        children: children.length === 0 ? null : children,
        loc: exprLoc,
        openingLoc: openingLoc,
        closingLoc:
          (_4 =
            (_3 = expr.get("closingElement").node) === null || _3 === void 0
              ? void 0
              : _3.loc) !== null && _4 !== void 0
            ? _4
            : GeneratedSource,
      };
    }
    case "JSXFragment": {
      const expr = exprPath;
      const children = expr
        .get("children")
        .map((child) => lowerJsxElement(builder, child))
        .filter(notNull);
      return { kind: "JsxFragment", children: children, loc: exprLoc };
    }
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      const expr = exprPath;
      return lowerFunctionToValue(builder, expr);
    }
    case "TaggedTemplateExpression": {
      const expr = exprPath;
      if (expr.get("quasi").get("expressions").length !== 0) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerExpression) Handle tagged template with interpolations",
          severity: exports.ErrorSeverity.Todo,
          loc: (_5 = exprPath.node.loc) !== null && _5 !== void 0 ? _5 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      CompilerError.invariant(expr.get("quasi").get("quasis").length == 1, {
        reason:
          "there should be only one quasi as we don't support interpolations yet",
        description: null,
        loc: (_6 = expr.node.loc) !== null && _6 !== void 0 ? _6 : null,
        suggestions: null,
      });
      const value = expr.get("quasi").get("quasis").at(0).node.value;
      if (value.raw !== value.cooked) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerExpression) Handle tagged template where cooked value is different from raw value",
          severity: exports.ErrorSeverity.Todo,
          loc: (_7 = exprPath.node.loc) !== null && _7 !== void 0 ? _7 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "TaggedTemplateExpression",
        tag: lowerExpressionToTemporary(builder, expr.get("tag")),
        value: value,
        loc: exprLoc,
      };
    }
    case "TemplateLiteral": {
      const expr = exprPath;
      const subexprs = expr.get("expressions");
      const quasis = expr.get("quasis");
      if (subexprs.length !== quasis.length - 1) {
        builder.errors.push({
          reason: `Unexpected quasi and subexpression lengths in TemplateLiteral. This error is likely caused by a bug in React Compiler. Please file an issue`,
          severity: exports.ErrorSeverity.InvalidJS,
          loc: (_8 = exprPath.node.loc) !== null && _8 !== void 0 ? _8 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (subexprs.some((e) => !e.isExpression())) {
        builder.errors.push({
          reason: `(BuildHIR::lowerAssignment) Handle TSType in TemplateLiteral.`,
          severity: exports.ErrorSeverity.Todo,
          loc: (_9 = exprPath.node.loc) !== null && _9 !== void 0 ? _9 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const subexprPlaces = subexprs.map((e) =>
        lowerExpressionToTemporary(builder, e),
      );
      return {
        kind: "TemplateLiteral",
        subexprs: subexprPlaces,
        quasis: expr.get("quasis").map((q) => q.node.value),
        loc: exprLoc,
      };
    }
    case "UnaryExpression": {
      let expr = exprPath;
      if (expr.node.operator === "delete") {
        const argument = expr.get("argument");
        if (argument.isMemberExpression()) {
          const { object: object, property: property } = lowerMemberExpression(
            builder,
            argument,
          );
          if (typeof property === "string") {
            return {
              kind: "PropertyDelete",
              object: object,
              property: property,
              loc: exprLoc,
            };
          } else {
            return {
              kind: "ComputedDelete",
              object: object,
              property: property,
              loc: exprLoc,
            };
          }
        } else {
          builder.errors.push({
            reason: `Deleting a non-member expression has no semantic meaning`,
            severity: exports.ErrorSeverity.InvalidJS,
            loc: (_10 = expr.node.loc) !== null && _10 !== void 0 ? _10 : null,
            suggestions: [
              {
                description: "Remove this line",
                range: [expr.node.start, expr.node.end],
                op: exports.CompilerSuggestionOperation.Remove,
              },
            ],
          });
          return { kind: "UnsupportedNode", node: expr.node, loc: exprLoc };
        }
      } else {
        return {
          kind: "UnaryExpression",
          operator: expr.node.operator,
          value: lowerExpressionToTemporary(builder, expr.get("argument")),
          loc: exprLoc,
        };
      }
    }
    case "AwaitExpression": {
      let expr = exprPath;
      return {
        kind: "Await",
        value: lowerExpressionToTemporary(builder, expr.get("argument")),
        loc: exprLoc,
      };
    }
    case "TypeCastExpression": {
      let expr = exprPath;
      const typeAnnotation = expr.get("typeAnnotation").get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation.node,
        type: lowerType(typeAnnotation.node),
        loc: exprLoc,
      };
    }
    case "TSAsExpression": {
      let expr = exprPath;
      const typeAnnotation = expr.get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation.node,
        type: lowerType(typeAnnotation.node),
        loc: exprLoc,
      };
    }
    case "UpdateExpression": {
      let expr = exprPath;
      const argument = expr.get("argument");
      if (!argument.isIdentifier()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression with ${argument.type} argument`,
          severity: exports.ErrorSeverity.Todo,
          loc:
            (_11 = exprPath.node.loc) !== null && _11 !== void 0 ? _11 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      } else if (builder.isContextIdentifier(argument)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas.`,
          severity: exports.ErrorSeverity.Todo,
          loc:
            (_12 = exprPath.node.loc) !== null && _12 !== void 0 ? _12 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const lvalue = lowerIdentifierForAssignment(
        builder,
        (_13 = argument.node.loc) !== null && _13 !== void 0
          ? _13
          : GeneratedSource,
        InstructionKind.Reassign,
        argument,
      );
      if (lvalue === null) {
        if (!builder.errors.hasErrors()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Found an invalid UpdateExpression without a previously reported error`,
            severity: exports.ErrorSeverity.Invariant,
            loc: exprLoc,
            suggestions: null,
          });
        }
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const value = lowerIdentifier(builder, argument);
      if (expr.node.prefix) {
        return {
          kind: "PrefixUpdate",
          lvalue: lvalue,
          operation: expr.node.operator,
          value: value,
          loc: exprLoc,
        };
      } else {
        return {
          kind: "PostfixUpdate",
          lvalue: lvalue,
          operation: expr.node.operator,
          value: value,
          loc: exprLoc,
        };
      }
    }
    case "RegExpLiteral": {
      let expr = exprPath;
      return {
        kind: "RegExpLiteral",
        pattern: expr.node.pattern,
        flags: expr.node.flags,
        loc:
          (_14 = expr.node.loc) !== null && _14 !== void 0
            ? _14
            : GeneratedSource,
      };
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${exprPath.type} expressions`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_15 = exprPath.node.loc) !== null && _15 !== void 0 ? _15 : null,
        suggestions: null,
      });
      return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
    }
  }
}
function lowerOptionalMemberExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const loc =
    (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate =
    parentAlternate !== null
      ? parentAlternate
      : builder.enter("value", () => {
          const temp = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: loc,
          });
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: Object.assign({}, temp),
            type: null,
            loc: loc,
          });
          return {
            kind: "goto",
            variant: GotoVariant.Break,
            block: continuationBlock.id,
            id: makeInstructionId(0),
            loc: loc,
          };
        });
  let object = null;
  const testBlock = builder.enter("value", () => {
    const objectPath = expr.get("object");
    if (objectPath.isOptionalMemberExpression()) {
      const { value: value } = lowerOptionalMemberExpression(
        builder,
        objectPath,
        alternate,
      );
      object = value;
    } else if (objectPath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, objectPath, alternate);
      object = lowerValueToTemporary(builder, value);
    } else {
      object = lowerExpressionToTemporary(builder, objectPath);
    }
    return {
      kind: "branch",
      test: Object.assign({}, object),
      consequent: consequent.id,
      alternate: alternate,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  CompilerError.invariant(object !== null, {
    reason: "Satisfy type checker",
    description: null,
    loc: null,
    suggestions: null,
  });
  builder.enterReserved(consequent, () => {
    const { value: value } = lowerMemberExpression(builder, expr, object);
    const temp = lowerValueToTemporary(builder, value);
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: InstructionKind.Const, place: Object.assign({}, place) },
      value: Object.assign({}, temp),
      type: null,
      loc: loc,
    });
    return {
      kind: "goto",
      variant: GotoVariant.Break,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional: optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    },
    continuationBlock,
  );
  return { object: object, value: place };
}
function lowerOptionalCallExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const calleePath = expr.get("callee");
  const loc =
    (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate =
    parentAlternate !== null
      ? parentAlternate
      : builder.enter("value", () => {
          const temp = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: loc,
          });
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: Object.assign({}, temp),
            type: null,
            loc: loc,
          });
          return {
            kind: "goto",
            variant: GotoVariant.Break,
            block: continuationBlock.id,
            id: makeInstructionId(0),
            loc: loc,
          };
        });
  let callee;
  const testBlock = builder.enter("value", () => {
    if (calleePath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, calleePath, alternate);
      const valuePlace = lowerValueToTemporary(builder, value);
      callee = { kind: "CallExpression", callee: valuePlace };
    } else if (calleePath.isOptionalMemberExpression()) {
      const { object: object, value: value } = lowerOptionalMemberExpression(
        builder,
        calleePath,
        alternate,
      );
      callee = { kind: "MethodCall", receiver: object, property: value };
    } else if (calleePath.isMemberExpression()) {
      const memberExpr = lowerMemberExpression(builder, calleePath);
      const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
      callee = {
        kind: "MethodCall",
        receiver: memberExpr.object,
        property: propertyPlace,
      };
    } else {
      callee = {
        kind: "CallExpression",
        callee: lowerExpressionToTemporary(builder, calleePath),
      };
    }
    const testPlace =
      callee.kind === "CallExpression" ? callee.callee : callee.property;
    return {
      kind: "branch",
      test: Object.assign({}, testPlace),
      consequent: consequent.id,
      alternate: alternate,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.enterReserved(consequent, () => {
    const args = lowerArguments(builder, expr.get("arguments"));
    const temp = buildTemporaryPlace(builder, loc);
    if (callee.kind === "CallExpression") {
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, temp),
        value: {
          kind: "CallExpression",
          callee: Object.assign({}, callee.callee),
          args: args,
          loc: loc,
        },
        loc: loc,
      });
    } else {
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, temp),
        value: {
          kind: "MethodCall",
          receiver: Object.assign({}, callee.receiver),
          property: Object.assign({}, callee.property),
          args: args,
          loc: loc,
        },
        loc: loc,
      });
    }
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: InstructionKind.Const, place: Object.assign({}, place) },
      value: Object.assign({}, temp),
      type: null,
      loc: loc,
    });
    return {
      kind: "goto",
      variant: GotoVariant.Break,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional: optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    },
    continuationBlock,
  );
  return { kind: "LoadLocal", place: place, loc: place.loc };
}
function lowerReorderableExpression(builder, expr) {
  var _a;
  if (!isReorderableExpression(builder, expr, true)) {
    builder.errors.push({
      reason: `(BuildHIR::node.lowerReorderableExpression) Expression type '${expr.type}' cannot be safely reordered`,
      severity: exports.ErrorSeverity.Todo,
      loc: (_a = expr.node.loc) !== null && _a !== void 0 ? _a : null,
      suggestions: null,
    });
  }
  return lowerExpressionToTemporary(builder, expr);
}
function isReorderableExpression(builder, expr, allowLocalIdentifiers) {
  switch (expr.node.type) {
    case "Identifier": {
      const identifier = builder.resolveIdentifier(expr);
      if (identifier === null) {
        return true;
      } else {
        return allowLocalIdentifiers;
      }
    }
    case "RegExpLiteral":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral": {
      return true;
    }
    case "UnaryExpression": {
      const unary = expr;
      switch (expr.node.operator) {
        case "!":
        case "+":
        case "-": {
          return isReorderableExpression(
            builder,
            unary.get("argument"),
            allowLocalIdentifiers,
          );
        }
        default: {
          return false;
        }
      }
    }
    case "TypeCastExpression": {
      return isReorderableExpression(
        builder,
        expr.get("expression"),
        allowLocalIdentifiers,
      );
    }
    case "ConditionalExpression": {
      const conditional = expr;
      return (
        isReorderableExpression(
          builder,
          conditional.get("test"),
          allowLocalIdentifiers,
        ) &&
        isReorderableExpression(
          builder,
          conditional.get("consequent"),
          allowLocalIdentifiers,
        ) &&
        isReorderableExpression(
          builder,
          conditional.get("alternate"),
          allowLocalIdentifiers,
        )
      );
    }
    case "ArrayExpression": {
      return expr
        .get("elements")
        .every(
          (element) =>
            element.isExpression() &&
            isReorderableExpression(builder, element, allowLocalIdentifiers),
        );
    }
    case "ObjectExpression": {
      return expr.get("properties").every((property) => {
        if (!property.isObjectProperty() || property.node.computed) {
          return false;
        }
        const value = property.get("value");
        return (
          value.isExpression() &&
          isReorderableExpression(builder, value, allowLocalIdentifiers)
        );
      });
    }
    case "MemberExpression": {
      const test = expr;
      let innerObject = test;
      while (innerObject.isMemberExpression()) {
        innerObject = innerObject.get("object");
      }
      if (
        innerObject.isIdentifier() &&
        builder.resolveIdentifier(innerObject) === null
      ) {
        return true;
      } else {
        return false;
      }
    }
    case "ArrowFunctionExpression": {
      const fn = expr;
      const body = fn.get("body");
      if (body.node.type === "BlockStatement") {
        return body.node.body.length === 0;
      } else {
        invariant$1(body.isExpression(), "Expected an expression");
        return isReorderableExpression(builder, body, false);
      }
    }
    case "CallExpression": {
      const call = expr;
      const callee = call.get("callee");
      return (
        callee.isExpression() &&
        isReorderableExpression(builder, callee, allowLocalIdentifiers) &&
        call
          .get("arguments")
          .every(
            (arg) =>
              arg.isExpression() &&
              isReorderableExpression(builder, arg, allowLocalIdentifiers),
          )
      );
    }
    default: {
      return false;
    }
  }
}
function lowerArguments(builder, expr) {
  var _a;
  let args = [];
  for (const argPath of expr) {
    if (argPath.isSpreadElement()) {
      args.push({
        kind: "Spread",
        place: lowerExpressionToTemporary(builder, argPath.get("argument")),
      });
    } else if (argPath.isExpression()) {
      args.push(lowerExpressionToTemporary(builder, argPath));
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${argPath.type} arguments in CallExpression`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_a = argPath.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
    }
  }
  return args;
}
function lowerMemberExpression(builder, expr, loweredObject = null) {
  var _a, _b, _c;
  const exprNode = expr.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const objectNode = expr.get("object");
  const propertyNode = expr.get("property");
  const object =
    loweredObject !== null && loweredObject !== void 0
      ? loweredObject
      : lowerExpressionToTemporary(builder, objectNode);
  if (!expr.node.computed) {
    if (!propertyNode.isIdentifier()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Handle ${propertyNode.type} property`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_b = propertyNode.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
      return {
        object: object,
        property: propertyNode.toString(),
        value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc },
      };
    }
    const value = {
      kind: "PropertyLoad",
      object: Object.assign({}, object),
      property: propertyNode.node.name,
      loc: exprLoc,
    };
    return { object: object, property: propertyNode.node.name, value: value };
  } else {
    if (!propertyNode.isExpression()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Expected Expression, got ${propertyNode.type} property`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_c = propertyNode.node.loc) !== null && _c !== void 0 ? _c : null,
        suggestions: null,
      });
      return {
        object: object,
        property: propertyNode.toString(),
        value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc },
      };
    }
    const property = lowerExpressionToTemporary(builder, propertyNode);
    const value = {
      kind: "ComputedLoad",
      object: Object.assign({}, object),
      property: Object.assign({}, property),
      loc: exprLoc,
    };
    return { object: object, property: property, value: value };
  }
}
function lowerJsxElementName(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  if (exprPath.isJSXIdentifier()) {
    const tag = exprPath.node.name;
    if (tag.match(/^[A-Z]/)) {
      const kind = getLoadKind(builder, exprPath);
      return lowerValueToTemporary(builder, {
        kind: kind,
        place: lowerIdentifier(builder, exprPath),
        loc: exprLoc,
      });
    } else {
      return { kind: "BuiltinTag", name: tag, loc: exprLoc };
    }
  } else if (exprPath.isJSXMemberExpression()) {
    return lowerJsxMemberExpression(builder, exprPath);
  } else if (exprPath.isJSXNamespacedName()) {
    const namespace = exprPath.node.namespace.name;
    const name = exprPath.node.name.name;
    const tag = `${namespace}:${name}`;
    if (namespace.indexOf(":") !== -1 || name.indexOf(":") !== -1) {
      builder.errors.push({
        reason: `Expected JSXNamespacedName to have no colons in the namespace or name, got '${namespace}' : '${name}'. This error is likely caused by a bug in React Compiler. Please file an issue`,
        severity: exports.ErrorSeverity.InvalidJS,
        loc: (_b = exprPath.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
    }
    const place = lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: tag,
      loc: exprLoc,
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElementName) Handle ${exprPath.type} tags`,
      severity: exports.ErrorSeverity.Todo,
      loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
      suggestions: null,
    });
    return lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc,
    });
  }
}
function lowerJsxMemberExpression(builder, exprPath) {
  var _a, _b;
  const loc =
    (_a = exprPath.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const object = exprPath.get("object");
  let objectPlace;
  if (object.isJSXMemberExpression()) {
    objectPlace = lowerJsxMemberExpression(builder, object);
  } else {
    CompilerError.invariant(object.isJSXIdentifier(), {
      reason: `TypeScript refinement fail: expected 'JsxIdentifier', got '${object.node.type}'`,
      description: null,
      loc: (_b = object.node.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
    objectPlace = lowerIdentifier(builder, object);
  }
  const property = exprPath.get("property").node.name;
  return lowerValueToTemporary(builder, {
    kind: "PropertyLoad",
    object: objectPlace,
    property: property,
    loc: loc,
  });
}
function lowerJsxElement(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  if (exprPath.isJSXElement() || exprPath.isJSXFragment()) {
    return lowerExpressionToTemporary(builder, exprPath);
  } else if (exprPath.isJSXExpressionContainer()) {
    const expression = exprPath.get("expression");
    if (expression.isJSXEmptyExpression()) {
      return null;
    } else {
      CompilerError.invariant(expression.isExpression(), {
        reason: `(BuildHIR::lowerJsxElement) Expected Expression but found ${expression.type}!`,
        description: null,
        loc: (_b = expression.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
      return lowerExpressionToTemporary(builder, expression);
    }
  } else if (exprPath.isJSXText()) {
    const text = trimJsxText(exprPath.node.value);
    if (text === null) {
      return null;
    }
    const place = lowerValueToTemporary(builder, {
      kind: "JSXText",
      value: text,
      loc: exprLoc,
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElement) Unhandled JsxElement, got: ${exprPath.type}`,
      severity: exports.ErrorSeverity.Todo,
      loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
      suggestions: null,
    });
    const place = lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc,
    });
    return place;
  }
}
function trimJsxText(original) {
  const lines = original.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }
  let str = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }
    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }
      str += trimmedLine;
    }
  }
  if (str.length !== 0) {
    return str;
  } else {
    return null;
  }
}
function lowerFunctionToValue(builder, expr) {
  var _a, _b, _c, _d;
  const exprNode = expr.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  let name = null;
  if (expr.isFunctionExpression()) {
    name =
      (_d =
        (_c =
          (_b = expr.get("id")) === null || _b === void 0
            ? void 0
            : _b.node) === null || _c === void 0
          ? void 0
          : _c.name) !== null && _d !== void 0
        ? _d
        : null;
  }
  const loweredFunc = lowerFunction(builder, expr);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
  }
  return {
    kind: "FunctionExpression",
    name: name,
    expr: expr.node,
    loc: exprLoc,
    loweredFunc: loweredFunc,
  };
}
function lowerFunction(builder, expr) {
  const componentScope = builder.parentFunction.scope;
  const captured = gatherCapturedDeps(builder, expr, componentScope);
  const lowering = lower$1(
    expr,
    builder.environment,
    builder.bindings,
    [...builder.context, ...captured.identifiers],
    builder.parentFunction,
  );
  let loweredFunc;
  if (lowering.isErr()) {
    lowering
      .unwrapErr()
      .details.forEach((detail) => builder.errors.pushErrorDetail(detail));
    return null;
  }
  loweredFunc = lowering.unwrap();
  return { func: loweredFunc, dependencies: captured.refs };
}
function lowerExpressionToTemporary(builder, exprPath) {
  const value = lowerExpression(builder, exprPath);
  return lowerValueToTemporary(builder, value);
}
function lowerValueToTemporary(builder, value) {
  if (value.kind === "LoadLocal" && value.place.identifier.name === null) {
    return value.place;
  }
  const place = buildTemporaryPlace(builder, value.loc);
  builder.push({
    id: makeInstructionId(0),
    value: value,
    loc: value.loc,
    lvalue: Object.assign({}, place),
  });
  return place;
}
function lowerIdentifier(builder, exprPath) {
  var _a;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const identifier = builder.resolveIdentifier(exprPath);
  if (identifier === null) {
    const global = builder.resolveGlobal(exprPath);
    let value;
    if (global !== null) {
      value = { kind: "LoadGlobal", name: global.name, loc: exprLoc };
    } else {
      value = { kind: "UnsupportedNode", node: exprPath.node, loc: exprLoc };
    }
    return lowerValueToTemporary(builder, value);
  }
  const place = {
    kind: "Identifier",
    identifier: identifier,
    effect: exports.Effect.Unknown,
    reactive: false,
    loc: exprLoc,
  };
  return place;
}
function buildTemporaryPlace(builder, loc) {
  const place = {
    kind: "Identifier",
    identifier: builder.makeTemporary(),
    effect: exports.Effect.Unknown,
    reactive: false,
    loc: loc,
  };
  return place;
}
function getStoreKind(builder, identifier) {
  const isContext = builder.isContextIdentifier(identifier);
  return isContext ? "StoreContext" : "StoreLocal";
}
function getLoadKind(builder, identifier) {
  const isContext = builder.isContextIdentifier(identifier);
  return isContext ? "LoadContext" : "LoadLocal";
}
function lowerIdentifierForAssignment(builder, loc, kind, path) {
  var _a, _b;
  const identifier = builder.resolveIdentifier(path);
  if (identifier == null) {
    if (kind === InstructionKind.Reassign) {
      builder.errors.push({
        reason: `This reassigns a variable which was not defined inside of the component. Components should be pure and side-effect free. If this variable is used in rendering, use useState instead. (https://react.dev/learn/keeping-components-pure)`,
        severity: exports.ErrorSeverity.InvalidReact,
        loc:
          (_a = path.parentPath.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
        severity: exports.ErrorSeverity.Invariant,
        loc: (_b = path.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
    }
    return null;
  }
  const place = {
    kind: "Identifier",
    identifier: identifier,
    effect: exports.Effect.Unknown,
    reactive: false,
    loc: loc,
  };
  return place;
}
function lowerAssignment(
  builder,
  loc,
  kind,
  lvaluePath,
  value,
  assignmentKind,
) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w;
  const lvalueNode = lvaluePath.node;
  switch (lvalueNode.type) {
    case "Identifier": {
      const lvalue = lvaluePath;
      const place = lowerIdentifierForAssignment(builder, loc, kind, lvalue);
      if (place === null) {
        return {
          kind: "UnsupportedNode",
          loc:
            (_a = lvalue.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
          node: lvalue.node,
        };
      }
      const isHoistedIdentifier = builder.environment.isHoistedIdentifier(
        lvalue.node,
      );
      let temporary;
      if (builder.isContextIdentifier(lvalue)) {
        if (kind !== InstructionKind.Reassign && !isHoistedIdentifier) {
          if (kind === InstructionKind.Const) {
            builder.errors.push({
              reason: `[lowerAssignment] Invalid declaration kind (const), this variable is reassigned later`,
              severity: exports.ErrorSeverity.InvalidJS,
              loc: (_b = lvalue.node.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
          }
          lowerValueToTemporary(builder, {
            kind: "DeclareContext",
            lvalue: {
              kind: InstructionKind.Let,
              place: Object.assign({}, place),
            },
            loc: place.loc,
          });
        }
        temporary = lowerValueToTemporary(builder, {
          kind: "StoreContext",
          lvalue: {
            place: Object.assign({}, place),
            kind: InstructionKind.Reassign,
          },
          value: value,
          loc: loc,
        });
      } else {
        const typeAnnotation = lvalue.get("typeAnnotation");
        let type;
        if (typeAnnotation.isTSTypeAnnotation()) {
          const typePath = typeAnnotation.get("typeAnnotation");
          type = typePath.node;
        } else if (typeAnnotation.isTypeAnnotation()) {
          const typePath = typeAnnotation.get("typeAnnotation");
          type = typePath.node;
        } else {
          type = null;
        }
        temporary = lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { place: Object.assign({}, place), kind: kind },
          value: value,
          type: type,
          loc: loc,
        });
      }
      return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
    }
    case "MemberExpression": {
      CompilerError.invariant(kind === InstructionKind.Reassign, {
        reason: "MemberExpression may only appear in an assignment expression",
        description: null,
        loc: (_c = lvaluePath.node.loc) !== null && _c !== void 0 ? _c : null,
        suggestions: null,
      });
      const lvalue = lvaluePath;
      const property = lvalue.get("property");
      const object = lowerExpressionToTemporary(builder, lvalue.get("object"));
      if (!lvalue.node.computed) {
        if (!property.isIdentifier()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in MemberExpression`,
            severity: exports.ErrorSeverity.Todo,
            loc: (_d = property.node.loc) !== null && _d !== void 0 ? _d : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
        }
        const temporary = lowerValueToTemporary(builder, {
          kind: "PropertyStore",
          object: object,
          property: property.node.name,
          value: value,
          loc: loc,
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      } else {
        if (!property.isExpression()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerAssignment) Expected private name to appear as a non-computed property",
            severity: exports.ErrorSeverity.Todo,
            loc: (_e = property.node.loc) !== null && _e !== void 0 ? _e : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
        }
        const propertyPlace = lowerExpressionToTemporary(builder, property);
        const temporary = lowerValueToTemporary(builder, {
          kind: "ComputedStore",
          object: object,
          property: propertyPlace,
          value: value,
          loc: loc,
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      }
    }
    case "ArrayPattern": {
      const lvalue = lvaluePath;
      const elements = lvalue.get("elements");
      const items = [];
      const followups = [];
      const forceTemporaries =
        kind === InstructionKind.Reassign &&
        (elements.some((element) => !element.isIdentifier()) ||
          elements.some(
            (element) =>
              element.isIdentifier() &&
              getStoreKind(builder, element) !== "StoreLocal",
          ));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (element.node == null) {
          items.push({ kind: "Hole" });
          continue;
        }
        if (element.isRestElement()) {
          const argument = element.get("argument");
          if (
            argument.isIdentifier() &&
            !forceTemporaries &&
            (assignmentKind === "Assignment" ||
              getStoreKind(builder, argument) === "StoreLocal")
          ) {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_f = element.node.loc) !== null && _f !== void 0
                ? _f
                : GeneratedSource,
              kind,
              argument,
            );
            if (identifier === null) {
              continue;
            }
            items.push({ kind: "Spread", place: identifier });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_g = element.node.loc) !== null && _g !== void 0
                ? _g
                : GeneratedSource,
            );
            promoteTemporary(temp.identifier);
            items.push({ kind: "Spread", place: Object.assign({}, temp) });
            followups.push({ place: temp, path: argument });
          }
        } else if (
          element.isIdentifier() &&
          !forceTemporaries &&
          (assignmentKind === "Assignment" ||
            getStoreKind(builder, element) === "StoreLocal")
        ) {
          const identifier = lowerIdentifierForAssignment(
            builder,
            (_h = element.node.loc) !== null && _h !== void 0
              ? _h
              : GeneratedSource,
            kind,
            element,
          );
          if (identifier === null) {
            continue;
          }
          items.push(identifier);
        } else {
          const temp = buildTemporaryPlace(
            builder,
            (_j = element.node.loc) !== null && _j !== void 0
              ? _j
              : GeneratedSource,
          );
          promoteTemporary(temp.identifier);
          items.push(Object.assign({}, temp));
          followups.push({ place: temp, path: element });
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: { kind: kind, pattern: { kind: "ArrayPattern", items: items } },
        value: value,
        loc: loc,
      });
      for (const { place: place, path: path } of followups) {
        lowerAssignment(
          builder,
          (_k = path.node.loc) !== null && _k !== void 0 ? _k : loc,
          kind,
          path,
          place,
          assignmentKind,
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "ObjectPattern": {
      const lvalue = lvaluePath;
      const propertiesPaths = lvalue.get("properties");
      const properties = [];
      const followups = [];
      const forceTemporaries =
        kind === InstructionKind.Reassign &&
        propertiesPaths.some(
          (property) =>
            property.isRestElement() ||
            (property.isObjectProperty() &&
              !property.get("value").isIdentifier()),
        );
      for (let i = 0; i < propertiesPaths.length; i++) {
        const property = propertiesPaths[i];
        if (property.isRestElement()) {
          const argument = property.get("argument");
          if (!argument.isIdentifier()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${argument.node.type} rest element in ObjectPattern`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_l = argument.node.loc) !== null && _l !== void 0 ? _l : null,
              suggestions: null,
            });
            continue;
          }
          if (
            forceTemporaries ||
            getStoreKind(builder, argument) === "StoreContext"
          ) {
            const temp = buildTemporaryPlace(
              builder,
              (_m = property.node.loc) !== null && _m !== void 0
                ? _m
                : GeneratedSource,
            );
            promoteTemporary(temp.identifier);
            properties.push({ kind: "Spread", place: Object.assign({}, temp) });
            followups.push({ place: temp, path: argument });
          } else {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_o = property.node.loc) !== null && _o !== void 0
                ? _o
                : GeneratedSource,
              kind,
              argument,
            );
            if (identifier === null) {
              continue;
            }
            properties.push({ kind: "Spread", place: identifier });
          }
        } else {
          if (!property.isObjectProperty()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in ObjectPattern`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_p = property.node.loc) !== null && _p !== void 0 ? _p : null,
              suggestions: null,
            });
            continue;
          }
          if (property.node.computed) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_q = property.node.loc) !== null && _q !== void 0 ? _q : null,
              suggestions: null,
            });
            continue;
          }
          const loweredKey = lowerObjectPropertyKey(builder, property);
          if (!loweredKey) {
            continue;
          }
          const element = property.get("value");
          if (!element.isLVal()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Expected object property value to be an LVal, got: ${element.type}`,
              severity: exports.ErrorSeverity.Todo,
              loc:
                (_r = element.node.loc) !== null && _r !== void 0 ? _r : null,
              suggestions: null,
            });
            continue;
          }
          if (
            element.isIdentifier() &&
            !forceTemporaries &&
            (assignmentKind === "Assignment" ||
              getStoreKind(builder, element) === "StoreLocal")
          ) {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_s = element.node.loc) !== null && _s !== void 0
                ? _s
                : GeneratedSource,
              kind,
              element,
            );
            if (identifier === null) {
              continue;
            }
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: identifier,
              key: loweredKey,
            });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_t = element.node.loc) !== null && _t !== void 0
                ? _t
                : GeneratedSource,
            );
            promoteTemporary(temp.identifier);
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: Object.assign({}, temp),
              key: loweredKey,
            });
            followups.push({ place: temp, path: element });
          }
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: {
          kind: kind,
          pattern: { kind: "ObjectPattern", properties: properties },
        },
        value: value,
        loc: loc,
      });
      for (const { place: place, path: path } of followups) {
        lowerAssignment(
          builder,
          (_u = path.node.loc) !== null && _u !== void 0 ? _u : loc,
          kind,
          path,
          place,
          assignmentKind,
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "AssignmentPattern": {
      const lvalue = lvaluePath;
      const loc =
        (_v = lvalue.node.loc) !== null && _v !== void 0 ? _v : GeneratedSource;
      const temp = buildTemporaryPlace(builder, loc);
      const testBlock = builder.reserve("value");
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const consequent = builder.enter("value", () => {
        const defaultValue = lowerReorderableExpression(
          builder,
          lvalue.get("right"),
        );
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, temp),
          },
          value: Object.assign({}, defaultValue),
          type: null,
          loc: loc,
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        };
      });
      const alternate = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, temp),
          },
          value: Object.assign({}, value),
          type: null,
          loc: loc,
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          test: testBlock.id,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        },
        testBlock,
      );
      const undef = lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: undefined,
        loc: loc,
      });
      const test = lowerValueToTemporary(builder, {
        kind: "BinaryExpression",
        left: Object.assign({}, value),
        operator: "===",
        right: Object.assign({}, undef),
        loc: loc,
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, test),
          consequent: consequent,
          alternate: alternate,
          id: makeInstructionId(0),
          loc: loc,
        },
        continuationBlock,
      );
      return lowerAssignment(
        builder,
        loc,
        kind,
        lvalue.get("left"),
        temp,
        assignmentKind,
      );
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Handle ${lvaluePath.type} assignments`,
        severity: exports.ErrorSeverity.Todo,
        loc: (_w = lvaluePath.node.loc) !== null && _w !== void 0 ? _w : null,
        suggestions: null,
      });
      return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
    }
  }
}
function isValidDependency(path) {
  const parent = path.parentPath;
  return (
    !path.node.computed &&
    !(parent.isCallExpression() && parent.get("callee") === path)
  );
}
function captureScopes({ from: from, to: to }) {
  let scopes = new Set();
  while (from) {
    scopes.add(from);
    if (from === to) {
      break;
    }
    from = from.parent;
  }
  return scopes;
}
function gatherCapturedDeps(builder, fn, componentScope) {
  const capturedIds = new Map();
  const capturedRefs = new Set();
  const seenPaths = new Set();
  const pureScopes = captureScopes({
    from: fn.scope.parent,
    to: componentScope,
  });
  function addCapturedId(bindingIdentifier) {
    if (!capturedIds.has(bindingIdentifier)) {
      const index = capturedIds.size;
      capturedIds.set(bindingIdentifier, index);
      return index;
    } else {
      return capturedIds.get(bindingIdentifier);
    }
  }
  function handleMaybeDependency(path) {
    var _a;
    let baseIdentifier;
    let dependency;
    if (path.isJSXOpeningElement()) {
      const name = path.get("name");
      if (!(name.isJSXMemberExpression() || name.isJSXIdentifier())) {
        return;
      }
      let current = name;
      while (current.isJSXMemberExpression()) {
        current = current.get("object");
      }
      invariant$1(
        current.isJSXIdentifier(),
        "Invalid logic in gatherCapturedDeps",
      );
      baseIdentifier = current;
      let currentDep = baseIdentifier;
      while (true) {
        const nextDep = currentDep.parentPath;
        if (nextDep && nextDep.isJSXMemberExpression()) {
          currentDep = nextDep;
        } else {
          break;
        }
      }
      dependency = currentDep;
    } else if (path.isMemberExpression()) {
      let currentId = path;
      while (currentId.isMemberExpression()) {
        currentId = currentId.get("object");
      }
      if (!currentId.isIdentifier()) {
        return;
      }
      baseIdentifier = currentId;
      let currentDep = baseIdentifier;
      while (true) {
        const nextDep = currentDep.parentPath;
        if (
          nextDep &&
          nextDep.isMemberExpression() &&
          isValidDependency(nextDep)
        ) {
          currentDep = nextDep;
        } else {
          break;
        }
      }
      dependency = currentDep;
    } else {
      baseIdentifier = path;
      dependency = path;
    }
    dependency.skip();
    const binding = baseIdentifier.scope.getBinding(baseIdentifier.node.name);
    if (binding === undefined || !pureScopes.has(binding.scope)) {
      return;
    }
    const idKey = String(addCapturedId(binding.identifier));
    let exprKey = idKey;
    if (dependency.isMemberExpression()) {
      let pathTokens = [];
      let current = dependency;
      while (current.isMemberExpression()) {
        const property = current.get("property");
        pathTokens.push(property.node.name);
        current = current.get("object");
      }
      exprKey += "." + pathTokens.reverse().join(".");
    } else if (dependency.isJSXMemberExpression()) {
      let pathTokens = [];
      let current = dependency;
      while (current.isJSXMemberExpression()) {
        const property = current.get("property");
        pathTokens.push(property.node.name);
        current = current.get("object");
      }
    }
    if (!seenPaths.has(exprKey)) {
      let loweredDep;
      if (dependency.isJSXIdentifier()) {
        loweredDep = lowerValueToTemporary(builder, {
          kind: "LoadLocal",
          place: lowerIdentifier(builder, dependency),
          loc:
            (_a = path.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        });
      } else if (dependency.isJSXMemberExpression()) {
        loweredDep = lowerJsxMemberExpression(builder, dependency);
      } else {
        loweredDep = lowerExpressionToTemporary(builder, dependency);
      }
      capturedRefs.add(loweredDep);
      seenPaths.add(exprKey);
    }
  }
  fn.traverse({
    TypeAnnotation(path) {
      path.skip();
    },
    TSTypeAnnotation(path) {
      path.skip();
    },
    TypeAlias(path) {
      path.skip();
    },
    TSTypeAliasDeclaration(path) {
      path.skip();
    },
    Expression(path) {
      if (path.isAssignmentExpression()) {
        const left = path.get("left");
        if (left.isIdentifier()) {
          handleMaybeDependency(left);
        }
        return;
      } else if (path.isJSXElement()) {
        handleMaybeDependency(path.get("openingElement"));
      } else if (path.isMemberExpression() || path.isIdentifier()) {
        handleMaybeDependency(path);
      }
    },
  });
  return { identifiers: [...capturedIds.keys()], refs: [...capturedRefs] };
}
function notNull(value) {
  return value !== null;
}
function lowerType(node) {
  switch (node.type) {
    case "GenericTypeAnnotation": {
      const id = node.id;
      if (id.type === "Identifier" && id.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "TSTypeReference": {
      const typeName = node.typeName;
      if (typeName.type === "Identifier" && typeName.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "ArrayTypeAnnotation":
    case "TSArrayType": {
      return { kind: "Object", shapeId: BuiltInArrayId };
    }
    case "BooleanLiteralTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "TSBooleanKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSVoidKeyword":
    case "VoidTypeAnnotation": {
      return { kind: "Primitive" };
    }
    default: {
      return makeType();
    }
  }
}
var ansiStyles$2 = { exports: {} };
var conversions$3 = { exports: {} };
var colorName$1 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50],
};
var cssKeywords = colorName$1;
var reverseKeywords = {};
for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}
var convert$1 = (conversions$3.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] },
});
for (var model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    var channels = convert$1[model].channels;
    var labels = convert$1[model].labels;
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
}
convert$1.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h;
  var s;
  var l;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
convert$1.rgb.hsv = function (rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff = v - Math.min(r, g, b);
  var diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [h * 360, s * 100, v * 100];
};
convert$1.rgb.hwb = function (rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert$1.rgb.hsl(rgb)[0];
  var w = (1 / 255) * Math.min(r, Math.min(g, b));
  b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert$1.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return (
    Math.pow(x[0] - y[0], 2) +
    Math.pow(x[1] - y[1], 2) +
    Math.pow(x[2] - y[2], 2)
  );
}
convert$1.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword];
      var distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function (keyword) {
  return cssKeywords[keyword];
};
convert$1.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert$1.rgb.lab = function (rgb) {
  var xyz = convert$1.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.hsl.rgb = function (hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  t1 = 2 * l - t2;
  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + (1 / 3) * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function (hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
};
convert$1.hsv.rgb = function (hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
};
convert$1.hsv.hsl = function (hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
};
convert$1.hwb.rgb = function (hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i;
  var v;
  var f;
  var n;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);
  var r;
  var g;
  var b;
  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;
    case 1:
      r = n;
      g = v;
      b = wh;
      break;
    case 2:
      r = wh;
      g = v;
      b = n;
      break;
    case 3:
      r = wh;
      g = n;
      b = v;
      break;
    case 4:
      r = n;
      g = wh;
      b = v;
      break;
    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  return [r * 255, g * 255, b * 255];
};
convert$1.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r;
  var g;
  var b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.204 + z * 1.057;
  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.lab = function (xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.lab.xyz = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert$1.lab.lch = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c;
  hr = Math.atan2(b, a);
  h = (hr * 360) / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};
convert$1.lch.lab = function (lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var a;
  var b;
  var hr;
  hr = (h / 360) * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};
convert$1.rgb.ansi16 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi =
    30 +
    ((Math.round(b / 255) << 2) |
      (Math.round(g / 255) << 1) |
      Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function (args) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};
convert$1.rgb.ansi256 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round(((r - 8) / 247) * 24) + 232;
  }
  var ansi =
    16 +
    36 * Math.round((r / 255) * 5) +
    6 * Math.round((g / 255) * 5) +
    Math.round((b / 255) * 5);
  return ansi;
};
convert$1.ansi16.rgb = function (args) {
  var color = args % 10;
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }
    color = (color / 10.5) * 255;
    return [color, color, color];
  }
  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = ((color >> 1) & 1) * mult * 255;
  var b = ((color >> 2) & 1) * mult * 255;
  return [r, g, b];
};
convert$1.ansi256.rgb = function (args) {
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  var rem;
  var r = (Math.floor(args / 36) / 5) * 255;
  var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
  var b = ((rem % 6) / 5) * 255;
  return [r, g, b];
};
convert$1.rgb.hex = function (args) {
  var integer =
    ((Math.round(args[0]) & 255) << 16) +
    ((Math.round(args[1]) & 255) << 8) +
    (Math.round(args[2]) & 255);
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  var colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString
      .split("")
      .map(function (char) {
        return char + char;
      })
      .join("");
  }
  var integer = parseInt(colorString, 16);
  var r = (integer >> 16) & 255;
  var g = (integer >> 8) & 255;
  var b = integer & 255;
  return [r, g, b];
};
convert$1.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max = Math.max(Math.max(r, g), b);
  var min = Math.min(Math.min(r, g), b);
  var chroma = max - min;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = ((g - b) / chroma) % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function (hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;
  if (l < 0.5) {
    c = 2 * s * l;
  } else {
    c = 2 * s * (1 - l);
  }
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$1.hsv.hcg = function (hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$1.hcg.rgb = function (hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  var pure = [0, 0, 0];
  var hi = (h % 1) * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255,
  ];
};
convert$1.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  var f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert$1.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1 - c) + 0.5 * c;
  var s = 0;
  if (l > 0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert$1.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert$1.hwb.hcg = function (hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$1.apple.rgb = function (apple) {
  return [
    (apple[0] / 65535) * 255,
    (apple[1] / 65535) * 255,
    (apple[2] / 65535) * 255,
  ];
};
convert$1.rgb.apple = function (rgb) {
  return [
    (rgb[0] / 255) * 65535,
    (rgb[1] / 255) * 65535,
    (rgb[2] / 255) * 65535,
  ];
};
convert$1.gray.rgb = function (args) {
  return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
};
convert$1.gray.hsl = convert$1.gray.hsv = function (args) {
  return [0, 0, args[0]];
};
convert$1.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function (gray) {
  var val = Math.round((gray[0] / 100) * 255) & 255;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [(val / 255) * 100];
};
var conversionsExports = conversions$3.exports;
var conversions$2 = conversionsExports;
function buildGraph() {
  var graph = {};
  var models = Object.keys(conversions$2);
  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = { distance: -1, parent: null };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions$2[current]);
    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions$2[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions$2[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
var route$2 = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);
  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions$1 = conversionsExports;
var route$1 = route$2;
var convert = {};
var models = Object.keys(conversions$1);
function wrapRaw(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    var result = fn(args);
    if (typeof result === "object") {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", {
    value: conversions$1[fromModel].channels,
  });
  Object.defineProperty(convert[fromModel], "labels", {
    value: conversions$1[fromModel].labels,
  });
  var routes = route$1(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert$1 = convert;
ansiStyles$2.exports;
(function (module) {
  const colorConvert = colorConvert$1;
  const wrapAnsi16 = (fn, offset) =>
    function () {
      const code = fn.apply(colorConvert, arguments);
      return `[${code + offset}m`;
    };
  const wrapAnsi256 = (fn, offset) =>
    function () {
      const code = fn.apply(colorConvert, arguments);
      return `[${38 + offset};5;${code}m`;
    };
  const wrapAnsi16m = (fn, offset) =>
    function () {
      const rgb = fn.apply(colorConvert, arguments);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39],
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49],
      },
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = { open: `[${style[0]}m`, close: `[${style[1]}m` };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false,
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false,
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = { ansi: wrapAnsi16(ansi2ansi, 0) };
    styles.color.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 0) };
    styles.color.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 0) };
    styles.bgColor.ansi = { ansi: wrapAnsi16(ansi2ansi, 10) };
    styles.bgColor.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 10) };
    styles.bgColor.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 10) };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles,
  });
})(ansiStyles$2);
var ansiStylesExports$1 = ansiStyles$2.exports;
var collections = {};
Object.defineProperty(collections, "__esModule", { value: true });
collections.printIteratorEntries = printIteratorEntries;
collections.printIteratorValues = printIteratorValues;
collections.printListItems = printListItems;
collections.printObjectProperties = printObjectProperties;
const getKeysOfEnumerableProperties = (object) => {
  const keys = Object.keys(object).sort();
  if (Object.getOwnPropertySymbols) {
    Object.getOwnPropertySymbols(object).forEach((symbol) => {
      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
        keys.push(symbol);
      }
    });
  }
  return keys;
};
function printIteratorEntries(
  iterator,
  config,
  indentation,
  depth,
  refs,
  printer,
  separator = ": ",
) {
  let result = "";
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      const name = printer(
        current.value[0],
        config,
        indentationNext,
        depth,
        refs,
      );
      const value = printer(
        current.value[1],
        config,
        indentationNext,
        depth,
        refs,
      );
      result += indentationNext + name + separator + value;
      current = iterator.next();
      if (!current.done) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(
  iterator,
  config,
  indentation,
  depth,
  refs,
  printer,
) {
  let result = "";
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result +=
        indentationNext +
        printer(current.value, config, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config, indentation, depth, refs, printer) {
  let result = "";
  if (list.length) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < list.length; i++) {
      result +=
        indentationNext +
        printer(list[i], config, indentationNext, depth, refs);
      if (i < list.length - 1) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config, indentation, depth, refs, printer) {
  let result = "";
  const keys = getKeysOfEnumerableProperties(val);
  if (keys.length) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const name = printer(key, config, indentationNext, depth, refs);
      const value = printer(val[key], config, indentationNext, depth, refs);
      result += indentationNext + name + ": " + value;
      if (i < keys.length - 1) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
var AsymmetricMatcher = {};
Object.defineProperty(AsymmetricMatcher, "__esModule", { value: true });
AsymmetricMatcher.default =
  AsymmetricMatcher.test =
  AsymmetricMatcher.serialize =
    void 0;
var _collections$3 = collections;
var Symbol$3 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const asymmetricMatcher = Symbol$3.for("jest.asymmetricMatcher");
const SPACE$2 = " ";
const serialize$6 = (val, config, indentation, depth, refs, printer) => {
  const stringedValue = val.toString();
  if (
    stringedValue === "ArrayContaining" ||
    stringedValue === "ArrayNotContaining"
  ) {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return (
      stringedValue +
      SPACE$2 +
      "[" +
      (0, _collections$3.printListItems)(
        val.sample,
        config,
        indentation,
        depth,
        refs,
        printer,
      ) +
      "]"
    );
  }
  if (
    stringedValue === "ObjectContaining" ||
    stringedValue === "ObjectNotContaining"
  ) {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return (
      stringedValue +
      SPACE$2 +
      "{" +
      (0, _collections$3.printObjectProperties)(
        val.sample,
        config,
        indentation,
        depth,
        refs,
        printer,
      ) +
      "}"
    );
  }
  if (
    stringedValue === "StringMatching" ||
    stringedValue === "StringNotMatching"
  ) {
    return (
      stringedValue +
      SPACE$2 +
      printer(val.sample, config, indentation, depth, refs)
    );
  }
  if (
    stringedValue === "StringContaining" ||
    stringedValue === "StringNotContaining"
  ) {
    return (
      stringedValue +
      SPACE$2 +
      printer(val.sample, config, indentation, depth, refs)
    );
  }
  return val.toAsymmetricMatcher();
};
AsymmetricMatcher.serialize = serialize$6;
const test$6 = (val) => val && val.$$typeof === asymmetricMatcher;
AsymmetricMatcher.test = test$6;
const plugin$6 = { serialize: serialize$6, test: test$6 };
var _default$6 = plugin$6;
AsymmetricMatcher.default = _default$6;
var ConvertAnsi = {};
var ansiRegex = (options) => {
  options = Object.assign({ onlyFirst: false }, options);
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
  ].join("|");
  return new RegExp(pattern, options.onlyFirst ? undefined : "g");
};
Object.defineProperty(ConvertAnsi, "__esModule", { value: true });
ConvertAnsi.default = ConvertAnsi.serialize = ConvertAnsi.test = void 0;
var _ansiRegex = _interopRequireDefault$2(ansiRegex);
var _ansiStyles$1 = _interopRequireDefault$2(ansiStylesExports$1);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const toHumanReadableAnsi = (text) =>
  text.replace((0, _ansiRegex.default)(), (match) => {
    switch (match) {
      case _ansiStyles$1.default.red.close:
      case _ansiStyles$1.default.green.close:
      case _ansiStyles$1.default.cyan.close:
      case _ansiStyles$1.default.gray.close:
      case _ansiStyles$1.default.white.close:
      case _ansiStyles$1.default.yellow.close:
      case _ansiStyles$1.default.bgRed.close:
      case _ansiStyles$1.default.bgGreen.close:
      case _ansiStyles$1.default.bgYellow.close:
      case _ansiStyles$1.default.inverse.close:
      case _ansiStyles$1.default.dim.close:
      case _ansiStyles$1.default.bold.close:
      case _ansiStyles$1.default.reset.open:
      case _ansiStyles$1.default.reset.close:
        return "</>";
      case _ansiStyles$1.default.red.open:
        return "<red>";
      case _ansiStyles$1.default.green.open:
        return "<green>";
      case _ansiStyles$1.default.cyan.open:
        return "<cyan>";
      case _ansiStyles$1.default.gray.open:
        return "<gray>";
      case _ansiStyles$1.default.white.open:
        return "<white>";
      case _ansiStyles$1.default.yellow.open:
        return "<yellow>";
      case _ansiStyles$1.default.bgRed.open:
        return "<bgRed>";
      case _ansiStyles$1.default.bgGreen.open:
        return "<bgGreen>";
      case _ansiStyles$1.default.bgYellow.open:
        return "<bgYellow>";
      case _ansiStyles$1.default.inverse.open:
        return "<inverse>";
      case _ansiStyles$1.default.dim.open:
        return "<dim>";
      case _ansiStyles$1.default.bold.open:
        return "<bold>";
      default:
        return "";
    }
  });
const test$5 = (val) =>
  typeof val === "string" && !!val.match((0, _ansiRegex.default)());
ConvertAnsi.test = test$5;
const serialize$5 = (val, config, indentation, depth, refs, printer) =>
  printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
ConvertAnsi.serialize = serialize$5;
const plugin$5 = { serialize: serialize$5, test: test$5 };
var _default$5 = plugin$5;
ConvertAnsi.default = _default$5;
var DOMCollection = {};
Object.defineProperty(DOMCollection, "__esModule", { value: true });
DOMCollection.default = DOMCollection.serialize = DOMCollection.test = void 0;
var _collections$2 = collections;
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }),
      );
    }
    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
const SPACE$1 = " ";
const OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
const testName = (name) =>
  OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
const test$4 = (val) =>
  val &&
  val.constructor &&
  val.constructor.name &&
  testName(val.constructor.name);
DOMCollection.test = test$4;
const propsReducer = (props, attribute) => {
  props[attribute.name] = attribute.value;
  return props;
};
const serialize$4 = (collection, config, indentation, depth, refs, printer) => {
  const name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return "[" + name + "]";
  }
  return (
    (config.min ? "" : name + SPACE$1) +
    (OBJECT_NAMES.indexOf(name) !== -1
      ? "{" +
        (0, _collections$2.printObjectProperties)(
          name === "NamedNodeMap"
            ? Array.prototype.reduce.call(collection, propsReducer, {})
            : _objectSpread({}, collection),
          config,
          indentation,
          depth,
          refs,
          printer,
        ) +
        "}"
      : "[" +
        (0, _collections$2.printListItems)(
          Array.from(collection),
          config,
          indentation,
          depth,
          refs,
          printer,
        ) +
        "]")
  );
};
DOMCollection.serialize = serialize$4;
const plugin$4 = { serialize: serialize$4, test: test$4 };
var _default$4 = plugin$4;
DOMCollection.default = _default$4;
var DOMElement = {};
var markup = {};
var escapeHTML$1 = {};
Object.defineProperty(escapeHTML$1, "__esModule", { value: true });
escapeHTML$1.default = escapeHTML;
function escapeHTML(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
Object.defineProperty(markup, "__esModule", { value: true });
markup.printElementAsLeaf =
  markup.printElement =
  markup.printComment =
  markup.printText =
  markup.printChildren =
  markup.printProps =
    void 0;
var _escapeHTML = _interopRequireDefault$1(escapeHTML$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const printProps = (keys, props, config, indentation, depth, refs, printer) => {
  const indentationNext = indentation + config.indent;
  const colors = config.colors;
  return keys
    .map((key) => {
      const value = props[key];
      let printed = printer(value, config, indentationNext, depth, refs);
      if (typeof value !== "string") {
        if (printed.indexOf("\n") !== -1) {
          printed =
            config.spacingOuter +
            indentationNext +
            printed +
            config.spacingOuter +
            indentation;
        }
        printed = "{" + printed + "}";
      }
      return (
        config.spacingInner +
        indentation +
        colors.prop.open +
        key +
        colors.prop.close +
        "=" +
        colors.value.open +
        printed +
        colors.value.close
      );
    })
    .join("");
};
markup.printProps = printProps;
const printChildren = (children, config, indentation, depth, refs, printer) =>
  children
    .map(
      (child) =>
        config.spacingOuter +
        indentation +
        (typeof child === "string"
          ? printText(child, config)
          : printer(child, config, indentation, depth, refs)),
    )
    .join("");
markup.printChildren = printChildren;
const printText = (text, config) => {
  const contentColor = config.colors.content;
  return (
    contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close
  );
};
markup.printText = printText;
const printComment = (comment, config) => {
  const commentColor = config.colors.comment;
  return (
    commentColor.open +
    "\x3c!--" +
    (0, _escapeHTML.default)(comment) +
    "--\x3e" +
    commentColor.close
  );
};
markup.printComment = printComment;
const printElement = (
  type,
  printedProps,
  printedChildren,
  config,
  indentation,
) => {
  const tagColor = config.colors.tag;
  return (
    tagColor.open +
    "<" +
    type +
    (printedProps &&
      tagColor.close +
        printedProps +
        config.spacingOuter +
        indentation +
        tagColor.open) +
    (printedChildren
      ? ">" +
        tagColor.close +
        printedChildren +
        config.spacingOuter +
        indentation +
        tagColor.open +
        "</" +
        type
      : (printedProps && !config.min ? "" : " ") + "/") +
    ">" +
    tagColor.close
  );
};
markup.printElement = printElement;
const printElementAsLeaf = (type, config) => {
  const tagColor = config.colors.tag;
  return (
    tagColor.open +
    "<" +
    type +
    tagColor.close +
    " " +
    tagColor.open +
    " />" +
    tagColor.close
  );
};
markup.printElementAsLeaf = printElementAsLeaf;
Object.defineProperty(DOMElement, "__esModule", { value: true });
DOMElement.default = DOMElement.serialize = DOMElement.test = void 0;
var _markup$2 = markup;
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const FRAGMENT_NODE = 11;
const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
const testNode = (nodeType, name) =>
  (nodeType === ELEMENT_NODE && ELEMENT_REGEXP.test(name)) ||
  (nodeType === TEXT_NODE && name === "Text") ||
  (nodeType === COMMENT_NODE && name === "Comment") ||
  (nodeType === FRAGMENT_NODE && name === "DocumentFragment");
const test$3 = (val) =>
  val &&
  val.constructor &&
  val.constructor.name &&
  testNode(val.nodeType, val.constructor.name);
DOMElement.test = test$3;
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
const serialize$3 = (node, config, indentation, depth, refs, printer) => {
  if (nodeIsText(node)) {
    return (0, _markup$2.printText)(node.data, config);
  }
  if (nodeIsComment(node)) {
    return (0, _markup$2.printComment)(node.data, config);
  }
  const type = nodeIsFragment(node)
    ? `DocumentFragment`
    : node.tagName.toLowerCase();
  if (++depth > config.maxDepth) {
    return (0, _markup$2.printElementAsLeaf)(type, config);
  }
  return (0, _markup$2.printElement)(
    type,
    (0, _markup$2.printProps)(
      nodeIsFragment(node)
        ? []
        : Array.from(node.attributes)
            .map((attr) => attr.name)
            .sort(),
      nodeIsFragment(node)
        ? []
        : Array.from(node.attributes).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}),
      config,
      indentation + config.indent,
      depth,
      refs,
      printer,
    ),
    (0, _markup$2.printChildren)(
      Array.prototype.slice.call(node.childNodes || node.children),
      config,
      indentation + config.indent,
      depth,
      refs,
      printer,
    ),
    config,
    indentation,
  );
};
DOMElement.serialize = serialize$3;
const plugin$3 = { serialize: serialize$3, test: test$3 };
var _default$3 = plugin$3;
DOMElement.default = _default$3;
var Immutable = {};
Object.defineProperty(Immutable, "__esModule", { value: true });
Immutable.default = Immutable.test = Immutable.serialize = void 0;
var _collections$1 = collections;
const IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
const IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
const IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
const getImmutableName = (name) => "Immutable." + name;
const printAsLeaf = (name) => "[" + name + "]";
const SPACE = " ";
const LAZY = "";
const printImmutableEntries = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer,
  type,
) =>
  ++depth > config.maxDepth
    ? printAsLeaf(getImmutableName(type))
    : getImmutableName(type) +
      SPACE +
      "{" +
      (0, _collections$1.printIteratorEntries)(
        val.entries(),
        config,
        indentation,
        depth,
        refs,
        printer,
      ) +
      "}";
const getRecordEntries = (val) => {
  let i = 0;
  return {
    next() {
      if (i < val._keys.length) {
        const key = val._keys[i++];
        return { done: false, value: [key, val.get(key)] };
      }
      return { done: true };
    },
  };
};
const printImmutableRecord = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer,
) => {
  const name = getImmutableName(val._name || "Record");
  return ++depth > config.maxDepth
    ? printAsLeaf(name)
    : name +
        SPACE +
        "{" +
        (0, _collections$1.printIteratorEntries)(
          getRecordEntries(val),
          config,
          indentation,
          depth,
          refs,
          printer,
        ) +
        "}";
};
const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
  const name = getImmutableName("Seq");
  if (++depth > config.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL]) {
    return (
      name +
      SPACE +
      "{" +
      (val._iter || val._object
        ? (0, _collections$1.printIteratorEntries)(
            val.entries(),
            config,
            indentation,
            depth,
            refs,
            printer,
          )
        : LAZY) +
      "}"
    );
  }
  return (
    name +
    SPACE +
    "[" +
    (val._iter || val._array || val._collection || val._iterable
      ? (0, _collections$1.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer,
        )
      : LAZY) +
    "]"
  );
};
const printImmutableValues = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer,
  type,
) =>
  ++depth > config.maxDepth
    ? printAsLeaf(getImmutableName(type))
    : getImmutableName(type) +
      SPACE +
      "[" +
      (0, _collections$1.printIteratorValues)(
        val.values(),
        config,
        indentation,
        depth,
        refs,
        printer,
      ) +
      "]";
const serialize$2 = (val, config, indentation, depth, refs, printer) => {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map",
    );
  }
  if (val[IS_LIST_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      "List",
    );
  }
  if (val[IS_SET_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set",
    );
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      "Stack",
    );
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config, indentation, depth, refs, printer);
  }
  return printImmutableRecord(val, config, indentation, depth, refs, printer);
};
Immutable.serialize = serialize$2;
const test$2 = (val) =>
  val &&
  (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
Immutable.test = test$2;
const plugin$2 = { serialize: serialize$2, test: test$2 };
var _default$2 = plugin$2;
Immutable.default = _default$2;
var ReactElement = {};
var reactIs = { exports: {} };
var reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (((a = a.type), a)) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (((a = a && a.$$typeof), a)) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function (a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function (a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function (a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function (a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function (a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function (a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function (a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function (a) {
    return z(a) === r;
  };
  reactIs_production_min.isPortal = function (a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function (a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function (a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function (a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function (a) {
    return (
      "string" === typeof a ||
      "function" === typeof a ||
      a === e ||
      a === m ||
      a === g ||
      a === f ||
      a === p ||
      a === q ||
      ("object" === typeof a &&
        null !== a &&
        (a.$$typeof === t ||
          a.$$typeof === r ||
          a.$$typeof === h ||
          a.$$typeof === k ||
          a.$$typeof === n ||
          a.$$typeof === w ||
          a.$$typeof === x ||
          a.$$typeof === y ||
          a.$$typeof === v))
    );
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function () {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol
        ? Symbol.for("react.fragment")
        : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol
        ? Symbol.for("react.strict_mode")
        : 60108;
      var REACT_PROFILER_TYPE = hasSymbol
        ? Symbol.for("react.profiler")
        : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol
        ? Symbol.for("react.provider")
        : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol
        ? Symbol.for("react.async_mode")
        : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol
        ? Symbol.for("react.concurrent_mode")
        : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol
        ? Symbol.for("react.forward_ref")
        : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol
        ? Symbol.for("react.suspense")
        : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol
        ? Symbol.for("react.suspense_list")
        : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol
        ? Symbol.for("react.fundamental")
        : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol
        ? Symbol.for("react.responder")
        : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return (
          typeof type === "string" ||
          typeof type === "function" ||
          type === REACT_FRAGMENT_TYPE ||
          type === REACT_CONCURRENT_MODE_TYPE ||
          type === REACT_PROFILER_TYPE ||
          type === REACT_STRICT_MODE_TYPE ||
          type === REACT_SUSPENSE_TYPE ||
          type === REACT_SUSPENSE_LIST_TYPE ||
          (typeof type === "object" &&
            type !== null &&
            (type.$$typeof === REACT_LAZY_TYPE ||
              type.$$typeof === REACT_MEMO_TYPE ||
              type.$$typeof === REACT_PROVIDER_TYPE ||
              type.$$typeof === REACT_CONTEXT_TYPE ||
              type.$$typeof === REACT_FORWARD_REF_TYPE ||
              type.$$typeof === REACT_FUNDAMENTAL_TYPE ||
              type.$$typeof === REACT_RESPONDER_TYPE ||
              type.$$typeof === REACT_SCOPE_TYPE ||
              type.$$typeof === REACT_BLOCK_TYPE))
        );
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"](
              "The ReactIs.isAsyncMode() alias has been deprecated, " +
                "and will be removed in React 17+. Update your code to use " +
                "ReactIs.isConcurrentMode() instead. It has the exact same API.",
            );
          }
        }
        return (
          isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE
        );
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return (
          typeof object === "object" &&
          object !== null &&
          object.$$typeof === REACT_ELEMENT_TYPE
        );
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
if (process.env.NODE_ENV === "production") {
  reactIs.exports = requireReactIs_production_min();
} else {
  reactIs.exports = requireReactIs_development();
}
var reactIsExports = reactIs.exports;
Object.defineProperty(ReactElement, "__esModule", { value: true });
ReactElement.default = ReactElement.test = ReactElement.serialize = void 0;
var ReactIs = _interopRequireWildcard(reactIsExports);
var _markup$1 = markup;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
const getChildren = (arg, children = []) => {
  if (Array.isArray(arg)) {
    arg.forEach((item) => {
      getChildren(item, children);
    });
  } else if (arg != null && arg !== false) {
    children.push(arg);
  }
  return children;
};
const getType = (element) => {
  const type = element.type;
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "function") {
    return type.displayName || type.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (typeof type === "object" && type !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      const functionName = type.render.displayName || type.render.name || "";
      return functionName !== ""
        ? "ForwardRef(" + functionName + ")"
        : "ForwardRef";
    }
    if (ReactIs.isMemo(type)) {
      const functionName =
        type.displayName || type.type.displayName || type.type.name || "";
      return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
    }
  }
  return "UNDEFINED";
};
const getPropKeys$1 = (element) => {
  const props = element.props;
  return Object.keys(props)
    .filter((key) => key !== "children" && props[key] !== undefined)
    .sort();
};
const serialize$1 = (element, config, indentation, depth, refs, printer) =>
  ++depth > config.maxDepth
    ? (0, _markup$1.printElementAsLeaf)(getType(element), config)
    : (0, _markup$1.printElement)(
        getType(element),
        (0, _markup$1.printProps)(
          getPropKeys$1(element),
          element.props,
          config,
          indentation + config.indent,
          depth,
          refs,
          printer,
        ),
        (0, _markup$1.printChildren)(
          getChildren(element.props.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer,
        ),
        config,
        indentation,
      );
ReactElement.serialize = serialize$1;
const test$1 = (val) => val && ReactIs.isElement(val);
ReactElement.test = test$1;
const plugin$1 = { serialize: serialize$1, test: test$1 };
var _default$1 = plugin$1;
ReactElement.default = _default$1;
var ReactTestComponent = {};
Object.defineProperty(ReactTestComponent, "__esModule", { value: true });
ReactTestComponent.default =
  ReactTestComponent.test =
  ReactTestComponent.serialize =
    void 0;
var _markup = markup;
var Symbol$2 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const testSymbol = Symbol$2.for("react.test.json");
const getPropKeys = (object) => {
  const props = object.props;
  return props
    ? Object.keys(props)
        .filter((key) => props[key] !== undefined)
        .sort()
    : [];
};
const serialize = (object, config, indentation, depth, refs, printer) =>
  ++depth > config.maxDepth
    ? (0, _markup.printElementAsLeaf)(object.type, config)
    : (0, _markup.printElement)(
        object.type,
        object.props
          ? (0, _markup.printProps)(
              getPropKeys(object),
              object.props,
              config,
              indentation + config.indent,
              depth,
              refs,
              printer,
            )
          : "",
        object.children
          ? (0, _markup.printChildren)(
              object.children,
              config,
              indentation + config.indent,
              depth,
              refs,
              printer,
            )
          : "",
        config,
        indentation,
      );
ReactTestComponent.serialize = serialize;
const test = (val) => val && val.$$typeof === testSymbol;
ReactTestComponent.test = test;
const plugin = { serialize: serialize, test: test };
var _default = plugin;
ReactTestComponent.default = _default;
var _ansiStyles = _interopRequireDefault(ansiStylesExports$1);
var _collections = collections;
var _AsymmetricMatcher = _interopRequireDefault(AsymmetricMatcher);
var _ConvertAnsi = _interopRequireDefault(ConvertAnsi);
var _DOMCollection = _interopRequireDefault(DOMCollection);
var _DOMElement = _interopRequireDefault(DOMElement);
var _Immutable = _interopRequireDefault(Immutable);
var _ReactElement = _interopRequireDefault(ReactElement);
var _ReactTestComponent = _interopRequireDefault(ReactTestComponent);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var Symbol$1 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = Symbol$1.prototype.toString;
const getConstructorName = (val) =>
  (typeof val.constructor === "function" && val.constructor.name) || "Object";
const isWindow = (val) => typeof window !== "undefined" && val === window;
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/gi;
class PrettyFormatPluginError extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
}
function isToStringedArrayType(toStringed) {
  return (
    toStringed === "[object Array]" ||
    toStringed === "[object ArrayBuffer]" ||
    toStringed === "[object DataView]" ||
    toStringed === "[object Float32Array]" ||
    toStringed === "[object Float64Array]" ||
    toStringed === "[object Int8Array]" ||
    toStringed === "[object Int16Array]" ||
    toStringed === "[object Int32Array]" ||
    toStringed === "[object Uint8Array]" ||
    toStringed === "[object Uint8ClampedArray]" ||
    toStringed === "[object Uint16Array]" ||
    toStringed === "[object Uint32Array]"
  );
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return "[Function " + (val.name || "anonymous") + "]";
}
function printSymbol(val) {
  return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return "[" + errorToString.call(val) + "]";
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return "" + val;
  }
  if (val === undefined) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  const typeOf = typeof val;
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return '"' + val.replace(/"|\\/g, "\\$&") + '"';
    }
    return '"' + val + '"';
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (
    toStringed === "[object Function]" ||
    toStringed === "[object GeneratorFunction]"
  ) {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
function printComplexValue(
  val,
  config,
  indentation,
  depth,
  refs,
  hasCalledToJSON,
) {
  if (refs.indexOf(val) !== -1) {
    return "[Circular]";
  }
  refs = refs.slice();
  refs.push(val);
  const hitMaxDepth = ++depth > config.maxDepth;
  const min = config.min;
  if (
    config.callToJSON &&
    !hitMaxDepth &&
    val.toJSON &&
    typeof val.toJSON === "function" &&
    !hasCalledToJSON
  ) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth
      ? "[Arguments]"
      : (min ? "" : "Arguments ") +
          "[" +
          (0, _collections.printListItems)(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
          ) +
          "]";
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth
      ? "[" + val.constructor.name + "]"
      : (min ? "" : val.constructor.name + " ") +
          "[" +
          (0, _collections.printListItems)(
            val,
            config,
            indentation,
            depth,
            refs,
            printer,
          ) +
          "]";
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth
      ? "[Map]"
      : "Map {" +
          (0, _collections.printIteratorEntries)(
            val.entries(),
            config,
            indentation,
            depth,
            refs,
            printer,
            " => ",
          ) +
          "}";
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth
      ? "[Set]"
      : "Set {" +
          (0, _collections.printIteratorValues)(
            val.values(),
            config,
            indentation,
            depth,
            refs,
            printer,
          ) +
          "}";
  }
  return hitMaxDepth || isWindow(val)
    ? "[" + getConstructorName(val) + "]"
    : (min ? "" : getConstructorName(val) + " ") +
        "{" +
        (0, _collections.printObjectProperties)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
        ) +
        "}";
}
function isNewPlugin(plugin) {
  return plugin.serialize != null;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin)
      ? plugin.serialize(val, config, indentation, depth, refs, printer)
      : plugin.print(
          val,
          (valChild) => printer(valChild, config, indentation, depth, refs),
          (str) => {
            const indentationNext = indentation + config.indent;
            return (
              indentationNext +
              str.replace(NEWLINE_REGEXP, "\n" + indentationNext)
            );
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner,
          },
          config.colors,
        );
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new Error(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`,
    );
  }
  return printed;
}
function findPlugin(plugins, val) {
  for (let p = 0; p < plugins.length; p++) {
    try {
      if (plugins[p].test(val)) {
        return plugins[p];
      }
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  }
  return null;
}
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
  const plugin = findPlugin(config.plugins, val);
  if (plugin !== null) {
    return printPlugin(plugin, val, config, indentation, depth, refs);
  }
  const basicResult = printBasicValue(
    val,
    config.printFunctionName,
    config.escapeRegex,
    config.escapeString,
  );
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(
    val,
    config,
    indentation,
    depth,
    refs,
    hasCalledToJSON,
  );
}
const DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green",
};
const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
const DEFAULT_OPTIONS = {
  callToJSON: true,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Infinity,
  min: false,
  plugins: [],
  printFunctionName: true,
  theme: DEFAULT_THEME,
};
function validateOptions(options) {
  Object.keys(options).forEach((key) => {
    if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
      throw new Error(`pretty-format: Unknown option "${key}".`);
    }
  });
  if (options.min && options.indent !== undefined && options.indent !== 0) {
    throw new Error(
      'pretty-format: Options "min" and "indent" cannot be used together.',
    );
  }
  if (options.theme !== undefined) {
    if (options.theme === null) {
      throw new Error(`pretty-format: Option "theme" must not be null.`);
    }
    if (typeof options.theme !== "object") {
      throw new Error(
        `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`,
      );
    }
  }
}
const getColorsHighlight = (options) =>
  DEFAULT_THEME_KEYS.reduce((colors, key) => {
    const value =
      options.theme && options.theme[key] !== undefined
        ? options.theme[key]
        : DEFAULT_THEME[key];
    const color = value && _ansiStyles.default[value];
    if (
      color &&
      typeof color.close === "string" &&
      typeof color.open === "string"
    ) {
      colors[key] = color;
    } else {
      throw new Error(
        `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`,
      );
    }
    return colors;
  }, Object.create(null));
const getColorsEmpty = () =>
  DEFAULT_THEME_KEYS.reduce((colors, key) => {
    colors[key] = { close: "", open: "" };
    return colors;
  }, Object.create(null));
const getPrintFunctionName = (options) =>
  options && options.printFunctionName !== undefined
    ? options.printFunctionName
    : DEFAULT_OPTIONS.printFunctionName;
const getEscapeRegex = (options) =>
  options && options.escapeRegex !== undefined
    ? options.escapeRegex
    : DEFAULT_OPTIONS.escapeRegex;
const getEscapeString = (options) =>
  options && options.escapeString !== undefined
    ? options.escapeString
    : DEFAULT_OPTIONS.escapeString;
const getConfig = (options) => ({
  callToJSON:
    options && options.callToJSON !== undefined
      ? options.callToJSON
      : DEFAULT_OPTIONS.callToJSON,
  colors:
    options && options.highlight
      ? getColorsHighlight(options)
      : getColorsEmpty(),
  escapeRegex: getEscapeRegex(options),
  escapeString: getEscapeString(options),
  indent:
    options && options.min
      ? ""
      : createIndent(
          options && options.indent !== undefined
            ? options.indent
            : DEFAULT_OPTIONS.indent,
        ),
  maxDepth:
    options && options.maxDepth !== undefined
      ? options.maxDepth
      : DEFAULT_OPTIONS.maxDepth,
  min: options && options.min !== undefined ? options.min : DEFAULT_OPTIONS.min,
  plugins:
    options && options.plugins !== undefined
      ? options.plugins
      : DEFAULT_OPTIONS.plugins,
  printFunctionName: getPrintFunctionName(options),
  spacingInner: options && options.min ? " " : "\n",
  spacingOuter: options && options.min ? "" : "\n",
});
function createIndent(indent) {
  return new Array(indent + 1).join(" ");
}
function prettyFormat(val, options) {
  if (options) {
    validateOptions(options);
    if (options.plugins) {
      const plugin = findPlugin(options.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, getConfig(options), "", 0, []);
      }
    }
  }
  const basicResult = printBasicValue(
    val,
    getPrintFunctionName(options),
    getEscapeRegex(options),
    getEscapeString(options),
  );
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
prettyFormat.plugins = {
  AsymmetricMatcher: _AsymmetricMatcher.default,
  ConvertAnsi: _ConvertAnsi.default,
  DOMCollection: _DOMCollection.default,
  DOMElement: _DOMElement.default,
  Immutable: _Immutable.default,
  ReactElement: _ReactElement.default,
  ReactTestComponent: _ReactTestComponent.default,
};
var build = prettyFormat;
var prettyFormat$1 = getDefaultExportFromCjs(build);
var _PostDominator_exit, _PostDominator_nodes;
function computePostDominatorTree(fn, options) {
  const graph = buildReverseGraph(fn, options.includeThrowsAsExitNode);
  const nodes = computeImmediateDominators(graph);
  if (!options.includeThrowsAsExitNode) {
    for (const [id] of fn.body.blocks) {
      if (!nodes.has(id)) {
        nodes.set(id, id);
      }
    }
  }
  return new PostDominator(graph.entry, nodes);
}
class PostDominator {
  constructor(exit, nodes) {
    _PostDominator_exit.set(this, void 0);
    _PostDominator_nodes.set(this, void 0);
    __classPrivateFieldSet(this, _PostDominator_exit, exit, "f");
    __classPrivateFieldSet(this, _PostDominator_nodes, nodes, "f");
  }
  get exit() {
    return __classPrivateFieldGet(this, _PostDominator_exit, "f");
  }
  get(id) {
    const dominator = __classPrivateFieldGet(
      this,
      _PostDominator_nodes,
      "f",
    ).get(id);
    CompilerError.invariant(dominator !== undefined, {
      reason: "Unknown node",
      description: null,
      loc: null,
      suggestions: null,
    });
    return dominator === id ? null : dominator;
  }
  debug() {
    const postDominators = new Map();
    for (const [key, value] of __classPrivateFieldGet(
      this,
      _PostDominator_nodes,
      "f",
    )) {
      postDominators.set(`bb${key}`, `bb${value}`);
    }
    return prettyFormat$1({
      exit: `bb${this.exit}`,
      postDominators: postDominators,
    });
  }
}
(_PostDominator_exit = new WeakMap()), (_PostDominator_nodes = new WeakMap());
function computeImmediateDominators(graph) {
  const nodes = new Map();
  nodes.set(graph.entry, graph.entry);
  let changed = true;
  while (changed) {
    changed = false;
    for (const [id, node] of graph.nodes) {
      if (node.id === graph.entry) {
        continue;
      }
      let newIdom = null;
      for (const pred of node.preds) {
        if (nodes.has(pred)) {
          newIdom = pred;
          break;
        }
      }
      CompilerError.invariant(newIdom !== null, {
        reason: `At least one predecessor must have been visited for block ${id}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      for (const pred of node.preds) {
        if (pred === newIdom) {
          continue;
        }
        const predDom = nodes.get(pred);
        if (predDom !== undefined) {
          newIdom = intersect(pred, newIdom, graph, nodes);
        }
      }
      if (nodes.get(id) !== newIdom) {
        nodes.set(id, newIdom);
        changed = true;
      }
    }
  }
  return nodes;
}
function intersect(a, b, graph, nodes) {
  let block1 = graph.nodes.get(a);
  let block2 = graph.nodes.get(b);
  while (block1 !== block2) {
    while (block1.index > block2.index) {
      const dom = nodes.get(block1.id);
      block1 = graph.nodes.get(dom);
    }
    while (block2.index > block1.index) {
      const dom = nodes.get(block2.id);
      block2 = graph.nodes.get(dom);
    }
  }
  return block1.id;
}
function buildReverseGraph(fn, includeThrowsAsExitNode) {
  const nodes = new Map();
  const exitId = fn.env.nextBlockId;
  const exit = { id: exitId, index: 0, preds: new Set(), succs: new Set() };
  nodes.set(exitId, exit);
  for (const [id, block] of fn.body.blocks) {
    const node = {
      id: id,
      index: 0,
      preds: new Set(eachTerminalSuccessor(block.terminal)),
      succs: new Set(block.preds),
    };
    if (block.terminal.kind === "return") {
      node.preds.add(exitId);
      exit.succs.add(id);
    } else if (block.terminal.kind === "throw" && includeThrowsAsExitNode) {
      node.preds.add(exitId);
      exit.succs.add(id);
    }
    nodes.set(id, node);
  }
  const visited = new Set();
  const postorder = [];
  function visit(id) {
    if (visited.has(id)) {
      return;
    }
    visited.add(id);
    const node = nodes.get(id);
    for (const successor of node.succs) {
      visit(successor);
    }
    postorder.push(id);
  }
  visit(exitId);
  const rpo = { entry: exitId, nodes: new Map() };
  let index = 0;
  for (const id of postorder.reverse()) {
    const node = nodes.get(id);
    node.index = index++;
    rpo.nodes.set(id, node);
  }
  return rpo;
}
var util$1;
(function (util) {
  util.assertEqual = (val) => val;
  function assertIs(_arg) {}
  util.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util.assertNever = assertNever;
  util.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util.getValidEnumValues = (obj) => {
    const validKeys = util
      .objectKeys(obj)
      .filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util.objectValues(filtered);
  };
  util.objectValues = (obj) =>
    util.objectKeys(obj).map(function (e) {
      return obj[e];
    });
  util.objectKeys =
    typeof Object.keys === "function"
      ? (obj) => Object.keys(obj)
      : (object) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
  util.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return undefined;
  };
  util.isInteger =
    typeof Number.isInteger === "function"
      ? (val) => Number.isInteger(val)
      : (val) =>
          typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array
      .map((val) => (typeof val === "string" ? `'${val}'` : val))
      .join(separator);
  }
  util.joinValues = joinValues;
  util.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$1 || (util$1 = {}));
var objectUtil;
(function (objectUtil) {
  objectUtil.mergeShapes = (first, second) => ({ ...first, ...second });
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$1.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set",
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (
        data.then &&
        typeof data.then === "function" &&
        data.catch &&
        typeof data.catch === "function"
      ) {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$1.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper =
      _mapper ||
      function (issue) {
        return issue.message;
      };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors: formErrors, fieldErrors: fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$1.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$1.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$1.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$1.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$1.assertNever(issue);
  }
  return { message: message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const {
    data: data,
    path: path,
    errorMaps: errorMaps,
    issueData: issueData,
  } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = { ...issueData, path: fullPath };
  let errorMessage = "";
  const maps = errorMaps
    .filter((m) => !!m)
    .slice()
    .reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, {
      data: data,
      defaultError: errorMessage,
    }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage,
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData: issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap,
    ].filter((x) => !!x),
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted") return INVALID;
      if (s.status === "dirty") status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({ key: await pair.key, value: await pair.value });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key, value: value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();
      if (
        key.value !== "__proto__" &&
        (typeof value.value !== "undefined" || pair.alwaysSet)
      ) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({ status: "dirty", value: value });
const OK = (value) => ({ status: "valid", value: value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function (errorUtil) {
  errorUtil.errToObj = (message) =>
    typeof message === "string" ? { message: message } : message || {};
  errorUtil.toString = (message) =>
    typeof message === "string"
      ? message
      : message === null || message === void 0
        ? void 0
        : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error) return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      },
    };
  }
};
function processCreateParams(params) {
  if (!params) return {};
  const {
    errorMap: errorMap,
    invalid_type_error: invalid_type_error,
    required_error: required_error,
    description: description,
  } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    );
  }
  if (errorMap) return { errorMap: errorMap, description: description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return {
        message:
          required_error !== null && required_error !== void 0
            ? required_error
            : ctx.defaultError,
      };
    }
    return {
      message:
        invalid_type_error !== null && invalid_type_error !== void 0
          ? invalid_type_error
          : ctx.defaultError,
    };
  };
  return { errorMap: customMap, description: description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return (
      ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      }
    );
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      },
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async:
          (_a =
            params === null || params === void 0 ? void 0 : params.async) !==
            null && _a !== void 0
            ? _a
            : false,
        contextualErrorMap:
          params === null || params === void 0 ? void 0 : params.errorMap,
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data,
      parsedType: getParsedType(data),
    };
    const result = this._parseSync({ data: data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap:
          params === null || params === void 0 ? void 0 : params.errorMap,
        async: true,
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data,
      parsedType: getParsedType(data),
    };
    const maybeAsyncResult = this._parse({
      data: data,
      path: ctx.path,
      parent: ctx,
    });
    const result = await (isAsync(maybeAsyncResult)
      ? maybeAsyncResult
      : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message: message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () =>
        ctx.addIssue({ code: ZodIssueCode.custom, ...getIssueProperties(val) });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(
          typeof refinementData === "function"
            ? refinementData(val, ctx)
            : refinementData,
        );
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement: refinement },
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform },
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def),
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({ ...this._def, description: description });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex =
  /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex =
  /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex =
  /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex =
  /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`,
      );
    } else {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`,
      );
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`,
      );
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`,
      );
    } else {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`,
      );
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message,
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message,
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation: validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message),
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options,
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision:
        typeof (options === null || options === void 0
          ? void 0
          : options.precision) === "undefined"
          ? null
          : options === null || options === void 0
            ? void 0
            : options.precision,
      offset:
        (_a =
          options === null || options === void 0 ? void 0 : options.offset) !==
          null && _a !== void 0
          ? _a
          : false,
      ...errorUtil.errToObj(
        options === null || options === void 0 ? void 0 : options.message,
      ),
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex,
      ...errorUtil.errToObj(message),
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value: value,
      position:
        options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(
        options === null || options === void 0 ? void 0 : options.message,
      ),
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value,
      ...errorUtil.errToObj(message),
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value,
      ...errorUtil.errToObj(message),
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message),
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message),
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message),
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce:
      (_a = params === null || params === void 0 ? void 0 : params.coerce) !==
        null && _a !== void 0
        ? _a
        : false,
    ...processCreateParams(params),
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$1.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive
          ? input.data < check.value
          : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive
          ? input.data > check.value
          : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message,
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind,
          value: value,
          inclusive: inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message),
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value,
      message: errorUtil.toString(message),
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message),
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message),
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message),
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find(
      (ch) =>
        ch.kind === "int" ||
        (ch.kind === "multipleOf" && util$1.isInteger(ch.value)),
    );
  }
  get isFinite() {
    let max = null,
      min = null;
    for (const ch of this._def.checks) {
      if (
        ch.kind === "finite" ||
        ch.kind === "int" ||
        ch.kind === "multipleOf"
      ) {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) =>
  new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce:
      (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params),
  });
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive
          ? input.data < check.value
          : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive
          ? input.data > check.value
          : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message,
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind,
          value: value,
          inclusive: inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value,
      message: errorUtil.toString(message),
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce:
      (_a = params === null || params === void 0 ? void 0 : params.coerce) !==
        null && _a !== void 0
        ? _a
        : false,
    ...processCreateParams(params),
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) =>
  new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce:
      (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params),
  });
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, { code: ZodIssueCode.invalid_date });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date",
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date",
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: new Date(input.data.getTime()) };
  }
  _addCheck(check) {
    return new ZodDate({ ...this._def, checks: [...this._def.checks, check] });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message),
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message),
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) =>
  new ZodDate({
    checks: [],
    coerce:
      (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params),
  });
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) =>
  new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params),
  });
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) =>
  new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params),
  });
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) =>
  new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params),
  });
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) =>
  new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params),
  });
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) =>
  new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params),
  });
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType,
    });
    return INVALID;
  }
}
ZodNever.create = (params) =>
  new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params),
  });
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) =>
  new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params),
  });
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx: ctx, status: status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message,
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message,
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message,
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i) =>
          def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)),
        ),
      ).then((result) => ParseStatus.mergeArray(status, result));
    }
    const result = [...ctx.data].map((item, i) =>
      def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)),
    );
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) },
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) },
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) },
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) =>
  new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params),
  });
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({ ...schema._def, shape: () => newShape });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element),
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys = util$1.objectKeys(shape);
    return (this._cached = { shape: shape, keys: keys });
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const { status: status, ctx: ctx } = this._processInputParams(input);
    const { shape: shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (
      !(
        this._def.catchall instanceof ZodNever &&
        this._def.unknownKeys === "strip"
      )
    ) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, key),
        ),
        alwaysSet: key in ctx.data,
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] },
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys,
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip");
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key),
          ),
          alwaysSet: key in ctx.data,
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve()
        .then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key: key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet,
            });
          }
          return syncPairs;
        })
        .then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs));
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...(message !== undefined
        ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError =
                (_c =
                  (_b = (_a = this._def).errorMap) === null || _b === void 0
                    ? void 0
                    : _b.call(_a, issue, ctx).message) !== null && _c !== void 0
                  ? _c
                  : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message:
                    (_d = errorUtil.errToObj(message).message) !== null &&
                    _d !== void 0
                      ? _d
                      : defaultError,
                };
              return { message: defaultError };
            },
          }
        : {}),
    });
  }
  strip() {
    return new ZodObject({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new ZodObject({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...augmentation }),
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({ ...this._def.shape(), ...merging._def.shape() }),
      typeName: ZodFirstPartyTypeKind.ZodObject,
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({ ...this._def, catchall: index });
  }
  pick(mask) {
    const shape = {};
    util$1.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({ ...this._def, shape: () => shape });
  }
  omit(mask) {
    const shape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({ ...this._def, shape: () => shape });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({ ...this._def, shape: () => newShape });
  }
  required(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({ ...this._def, shape: () => newShape });
  }
  keyof() {
    return createZodEnum(util$1.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) =>
  new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params),
  });
ZodObject.strictCreate = (shape, params) =>
  new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params),
  });
ZodObject.lazycreate = (shape, params) =>
  new ZodObject({
    shape: shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params),
  });
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map(
        (result) => new ZodError(result.ctx.common.issues),
      );
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors: unionErrors,
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: { ...ctx.common, issues: [] },
            parent: null,
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx,
            }),
            ctx: childCtx,
          };
        }),
      ).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: { ...ctx.common, issues: [] },
          parent: null,
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx,
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result: result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues) => new ZodError(issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors: unionErrors,
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) =>
  new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params),
  });
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator],
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    } else {
      return option._parseSync({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`,
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(
            `Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`,
          );
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: discriminator,
      options: options,
      optionsMap: optionsMap,
      ...processCreateParams(params),
    });
  }
}
function mergeValues$1(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$1.objectKeys(b);
    const sharedKeys = util$1
      .objectKeys(a)
      .filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$1(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$1(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (
    aType === ZodParsedType.date &&
    bType === ZodParsedType.date &&
    +a === +b
  ) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues$1(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types,
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      );
    }
  }
}
ZodIntersection.create = (left, right, params) =>
  new ZodIntersection({
    left: left,
    right: right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params),
  });
class ZodTuple extends ZodType {
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array",
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array",
      });
      status.dirty();
    }
    const items = [...ctx.data]
      .map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema) return null;
        return schema._parse(
          new ParseInputLazyPath(ctx, item, ctx.path, itemIndex),
        );
      })
      .filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) =>
        ParseStatus.mergeArray(status, results),
      );
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({ ...this._def, rest: rest });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params),
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key),
        ),
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third),
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second),
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => ({
      key: keyType._parse(
        new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"]),
      ),
      value: valueType._parse(
        new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]),
      ),
    }));
    if (ctx.common.async) {
      const finalMap = new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) =>
  new ZodMap({
    valueType: valueType,
    keyType: keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params),
  });
class ZodSet extends ZodType {
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message,
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message,
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements) {
      const parsedSet = new Set();
      for (const element of elements) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) =>
      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)),
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements) => finalizeSet(elements));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) },
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) },
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) =>
  new ZodSet({
    valueType: valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params),
  });
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap,
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error,
        },
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap,
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error,
        },
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function (...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args
          .parseAsync(args, params)
          .catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type
          .parseAsync(result, params)
          .catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function (...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create()),
    });
  }
  returns(returnType) {
    return new ZodFunction({ ...this._def, returns: returnType });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params),
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) =>
  new ZodLazy({
    getter: getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params),
  });
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) =>
  new ZodLiteral({
    value: value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params),
  });
function createZodEnum(values, params) {
  return new ZodEnum({
    values: values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params),
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type,
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (
      ctx.parsedType !== ZodParsedType.string &&
      ctx.parsedType !== ZodParsedType.number
    ) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type,
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) =>
  new ZodNativeEnum({
    values: values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params),
  });
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    if (
      ctx.parsedType !== ZodParsedType.promise &&
      ctx.common.async === false
    ) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const promisified =
      ctx.parsedType === ZodParsedType.promise
        ? ctx.data
        : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) =>
        this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap,
        }),
      ),
    );
  }
}
ZodPromise.create = (schema, params) =>
  new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params),
  });
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      },
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return { status: "dirty", value: ctx.data };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed) =>
          this._def.schema._parseAsync({
            data: processed,
            path: ctx.path,
            parent: ctx,
          }),
        );
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx,
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((inner) => {
            if (inner.status === "aborted") return INVALID;
            if (inner.status === "dirty") status.dirty();
            return executeRefinement(inner.value).then(() => ({
              status: status.value,
              value: inner.value,
            }));
          });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (!isValid(base)) return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`,
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((base) => {
            if (!isValid(base)) return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then(
              (result) => ({ status: status.value, value: result }),
            );
          });
      }
    }
    util$1.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) =>
  new ZodEffects({
    schema: schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect,
    ...processCreateParams(params),
  });
ZodEffects.createWithPreprocess = (preprocess, schema, params) =>
  new ZodEffects({
    schema: schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params),
  });
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) =>
  new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params),
  });
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) =>
  new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params),
  });
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data,
      path: ctx.path,
      parent: ctx,
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) =>
  new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue:
      typeof params.default === "function"
        ? params.default
        : () => params.default,
    ...processCreateParams(params),
  });
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    const newCtx = { ...ctx, common: { ...ctx.common, issues: [] } };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: { ...newCtx },
    });
    if (isAsync(result)) {
      return result.then((result) => ({
        status: "valid",
        value:
          result.status === "valid"
            ? result.value
            : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data,
              }),
      }));
    } else {
      return {
        status: "valid",
        value:
          result.status === "valid"
            ? result.value
            : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data,
              }),
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) =>
  new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue:
      typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params),
  });
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) =>
  new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params),
  });
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx: ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({ data: data, path: ctx.path, parent: ctx });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status: status, ctx: ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx,
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
      if (inResult.status === "aborted") return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return { status: "dirty", value: inResult.value };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx,
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline,
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) =>
  new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params),
  });
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p =
          typeof params === "function"
            ? params(data)
            : typeof params === "string"
              ? { message: params }
              : params;
        const _fatal =
          (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !==
            null && _b !== void 0
            ? _b
            : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
  ZodFirstPartyTypeKind["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
  cls,
  params = { message: `Input not instance of ${cls.name}` },
) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({ ...arg, coerce: true }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true }),
};
const NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap: setErrorMap,
  getErrorMap: getErrorMap,
  makeIssue: makeIssue,
  EMPTY_PATH: EMPTY_PATH,
  addIssueToContext: addIssueToContext,
  ParseStatus: ParseStatus,
  INVALID: INVALID,
  DIRTY: DIRTY,
  OK: OK,
  isAborted: isAborted,
  isDirty: isDirty,
  isValid: isValid,
  isAsync: isAsync,
  get util() {
    return util$1;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType: ZodParsedType,
  getParsedType: getParsedType,
  ZodType: ZodType,
  ZodString: ZodString,
  ZodNumber: ZodNumber,
  ZodBigInt: ZodBigInt,
  ZodBoolean: ZodBoolean,
  ZodDate: ZodDate,
  ZodSymbol: ZodSymbol,
  ZodUndefined: ZodUndefined,
  ZodNull: ZodNull,
  ZodAny: ZodAny,
  ZodUnknown: ZodUnknown,
  ZodNever: ZodNever,
  ZodVoid: ZodVoid,
  ZodArray: ZodArray,
  ZodObject: ZodObject,
  ZodUnion: ZodUnion,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion,
  ZodIntersection: ZodIntersection,
  ZodTuple: ZodTuple,
  ZodRecord: ZodRecord,
  ZodMap: ZodMap,
  ZodSet: ZodSet,
  ZodFunction: ZodFunction,
  ZodLazy: ZodLazy,
  ZodLiteral: ZodLiteral,
  ZodEnum: ZodEnum,
  ZodNativeEnum: ZodNativeEnum,
  ZodPromise: ZodPromise,
  ZodEffects: ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional: ZodOptional,
  ZodNullable: ZodNullable,
  ZodDefault: ZodDefault,
  ZodCatch: ZodCatch,
  ZodNaN: ZodNaN,
  BRAND: BRAND,
  ZodBranded: ZodBranded,
  ZodPipeline: ZodPipeline,
  ZodReadonly: ZodReadonly,
  custom: custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late: late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean: oboolean,
  onumber: onumber,
  optional: optionalType,
  ostring: ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER: NEVER,
  ZodIssueCode: ZodIssueCode,
  quotelessJson: quotelessJson,
  ZodError: ZodError,
});
const identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
function isNonEmptyArray(value) {
  return value.length !== 0;
}
const MAX_ISSUES_IN_MESSAGE = 99;
const ISSUE_SEPARATOR = "; ";
const UNION_SEPARATOR = ", or ";
const PREFIX = "Validation error";
const PREFIX_SEPARATOR = ": ";
class ValidationError extends Error {
  details;
  name;
  constructor(message, details = []) {
    super(message);
    this.details = details;
    this.name = "ZodValidationError";
  }
  toString() {
    return this.message;
  }
}
function getMessageFromZodIssue(props) {
  const {
    issue: issue,
    issueSeparator: issueSeparator,
    unionSeparator: unionSeparator,
    includePath: includePath,
  } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors
      .reduce((acc, zodError) => {
        const newIssues = zodError.issues
          .map((issue) =>
            getMessageFromZodIssue({
              issue: issue,
              issueSeparator: issueSeparator,
              unionSeparator: unionSeparator,
              includePath: includePath,
            }),
          )
          .join(issueSeparator);
        if (!acc.includes(newIssues)) {
          acc.push(newIssues);
        }
        return acc;
      }, [])
      .join(unionSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function conditionallyPrefixMessage(reason, prefix, prefixSeparator) {
  if (prefix !== null) {
    if (reason.length > 0) {
      return [prefix, reason].join(prefixSeparator);
    }
    return prefix;
  }
  if (reason.length > 0) {
    return reason;
  }
  return PREFIX;
}
function fromZodError(zodError, options = {}) {
  const {
    maxIssuesInMessage: maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator: issueSeparator = ISSUE_SEPARATOR,
    unionSeparator: unionSeparator = UNION_SEPARATOR,
    prefixSeparator: prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix = PREFIX,
    includePath: includePath = true,
  } = options;
  const reason = zodError.errors
    .slice(0, maxIssuesInMessage)
    .map((issue) =>
      getMessageFromZodIssue({
        issue: issue,
        issueSeparator: issueSeparator,
        unionSeparator: unionSeparator,
        includePath: includePath,
      }),
    )
    .join(issueSeparator);
  const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
  return new ValidationError(message, zodError.errors);
}
var ansiStyles$1 = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName) return colorName;
  hasRequiredColorName = 1;
  colorName = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };
  return colorName;
}
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions) return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] },
  };
  conversions = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels: channels, labels: labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [h * 360, s * 100, v * 100];
  };
  convert.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = (1 / 255) * Math.min(r, Math.min(g, b));
    b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function (rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function (keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function (rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + (1 / 3) * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = (hr * 360) / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = (h / 360) * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi =
      30 +
      ((Math.round(b / 255) << 2) |
        (Math.round(g / 255) << 1) |
        Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function (args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round(((r - 8) / 247) * 24) + 232;
    }
    const ansi =
      16 +
      36 * Math.round((r / 255) * 5) +
      6 * Math.round((g / 255) * 5) +
      Math.round((b / 255) * 5);
    return ansi;
  };
  convert.ansi16.rgb = function (args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = (color / 10.5) * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = ((color >> 1) & 1) * mult * 255;
    const b = ((color >> 2) & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function (args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = (Math.floor(args / 36) / 5) * 255;
    const g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
    const b = ((rem % 6) / 5) * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function (args) {
    const integer =
      ((Math.round(args[0]) & 255) << 16) +
      ((Math.round(args[1]) & 255) << 8) +
      (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString
        .split("")
        .map((char) => char + char)
        .join("");
    }
    const integer = parseInt(colorString, 16);
    const r = (integer >> 16) & 255;
    const g = (integer >> 8) & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = ((g - b) / chroma) % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = (h % 1) * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255,
    ];
  };
  convert.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function (apple) {
    return [
      (apple[0] / 65535) * 255,
      (apple[1] / 65535) * 255,
      (apple[2] / 65535) * 255,
    ];
  };
  convert.rgb.apple = function (rgb) {
    return [
      (rgb[0] / 255) * 65535,
      (rgb[1] / 255) * 65535,
      (rgb[2] / 255) * 65535,
    ];
  };
  convert.gray.rgb = function (args) {
    return [
      (args[0] / 100) * 255,
      (args[0] / 100) * 255,
      (args[0] / 100) * 255,
    ];
  };
  convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function (gray) {
    const val = Math.round((gray[0] / 100) * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [(val / 255) * 100];
  };
  return conversions;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const conversions = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = { distance: -1, parent: null };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  route = function (fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  return route;
}
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert) return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions = requireConversions();
  const route = requireRoute();
  const convert = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {
      value: conversions[fromModel].channels,
    });
    Object.defineProperty(convert[fromModel], "labels", {
      value: conversions[fromModel].labels,
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  colorConvert = convert;
  return colorConvert;
}
ansiStyles$1.exports;
(function (module) {
  const wrapAnsi16 =
    (fn, offset) =>
    (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
  const wrapAnsi256 =
    (fn, offset) =>
    (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
  const wrapAnsi16m =
    (fn, offset) =>
    (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
  const ansi2ansi = (n) => n;
  const rgb2rgb = (r, g, b) => [r, g, b];
  const setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value: value,
          enumerable: true,
          configurable: true,
        });
        return value;
      },
      enumerable: true,
      configurable: true,
    });
  };
  let colorConvert;
  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = requireColorConvert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39],
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49],
      },
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = { open: `[${style[0]}m`, close: `[${style[1]}m` };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false,
      });
    }
    Object.defineProperty(styles, "codes", { value: codes, enumerable: false });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () =>
      makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false),
    );
    setLazyProperty(styles.color, "ansi256", () =>
      makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false),
    );
    setLazyProperty(styles.color, "ansi16m", () =>
      makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false),
    );
    setLazyProperty(styles.bgColor, "ansi", () =>
      makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true),
    );
    setLazyProperty(styles.bgColor, "ansi256", () =>
      makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true),
    );
    setLazyProperty(styles.bgColor, "ansi16m", () =>
      makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true),
    );
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles,
  });
})(ansiStyles$1);
var ansiStylesExports = ansiStyles$1.exports;
var hasFlag$1 = (flag, argv = process.argv) => {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return (
    position !== -1 &&
    (terminatorPosition === -1 || position < terminatorPosition)
  );
};
const os = require$$0;
const tty = require$$1;
const hasFlag = hasFlag$1;
const { env: env } = process;
let forceColor;
if (
  hasFlag("no-color") ||
  hasFlag("no-colors") ||
  hasFlag("color=false") ||
  hasFlag("color=never")
) {
  forceColor = 0;
} else if (
  hasFlag("color") ||
  hasFlag("colors") ||
  hasFlag("color=true") ||
  hasFlag("color=always")
) {
  forceColor = 1;
}
if ("FORCE_COLOR" in env) {
  if (env.FORCE_COLOR === "true") {
    forceColor = 1;
  } else if (env.FORCE_COLOR === "false") {
    forceColor = 0;
  } else {
    forceColor =
      env.FORCE_COLOR.length === 0
        ? 1
        : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level: level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}
function supportsColor(haveStream, streamIsTTY) {
  if (forceColor === 0) {
    return 0;
  }
  if (
    hasFlag("color=16m") ||
    hasFlag("color=full") ||
    hasFlag("color=truecolor")
  ) {
    return 3;
  }
  if (hasFlag("color=256")) {
    return 2;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (
      [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
      ].some((sign) => sign in env) ||
      env.CI_NAME === "codeship"
    ) {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = parseInt(
      (env.TERM_PROGRAM_VERSION || "").split(".")[0],
      10,
    );
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (
    /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)
  ) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function getSupportLevel(stream) {
  const level = supportsColor(stream, stream && stream.isTTY);
  return translateLevel(level);
}
var supportsColor_1 = {
  supportsColor: getSupportLevel,
  stdout: translateLevel(supportsColor(true, tty.isatty(1))),
  stderr: translateLevel(supportsColor(true, tty.isatty(2))),
};
const stringReplaceAll$1 = (string, substring, replacer) => {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue +=
      string.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue +=
      string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) +
      prefix +
      (gotCR ? "\r\n" : "\n") +
      postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
var util = {
  stringReplaceAll: stringReplaceAll$1,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1,
};
var templates;
var hasRequiredTemplates;
function requireTemplates() {
  if (hasRequiredTemplates) return templates;
  hasRequiredTemplates = 1;
  const TEMPLATE_REGEX =
    /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX =
    /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", ""],
  ]);
  function unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if ((u && !bracket && c.length === 5) || (c[0] === "x" && c.length === 3)) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if ((matches = chunk.match(STRING_REGEX))) {
        results.push(
          matches[2].replace(ESCAPE_REGEX, (m, escape, character) =>
            escape ? unescape(escape) : character,
          ),
        );
      } else {
        throw new Error(
          `Invalid Chalk template style argument: ${chunk} (in style '${name}')`,
        );
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const [styleName, styles] of Object.entries(enabled)) {
      if (!Array.isArray(styles)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current =
        styles.length > 0 ? current[styleName](...styles) : current[styleName];
    }
    return current;
  }
  templates = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(
      TEMPLATE_REGEX,
      (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(
            styles.length === 0 ? string : buildStyle(chalk, styles)(string),
          );
          styles.push({ inverse: inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      },
    );
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  return templates;
}
const ansiStyles = ansiStylesExports;
const { stdout: stdoutColor, stderr: stderrColor } = supportsColor_1;
const {
  stringReplaceAll: stringReplaceAll,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex,
} = util;
const { isArray: isArray } = Array;
const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
  if (
    options.level &&
    !(
      Number.isInteger(options.level) &&
      options.level >= 0 &&
      options.level <= 3
    )
  ) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk = {};
  applyOptions(chalk, options);
  chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
  Object.setPrototypeOf(chalk, Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);
  chalk.template.constructor = () => {
    throw new Error(
      "`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.",
    );
  };
  chalk.template.Instance = ChalkClass;
  return chalk.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(
        this,
        createStyler(style.open, style.close, this._styler),
        this._isEmpty,
      );
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    },
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  },
};
const usedModels = [
  "rgb",
  "hex",
  "keyword",
  "hsl",
  "hsv",
  "hwb",
  "ansi",
  "ansi256",
];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level: level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          ansiStyles.color[levelMapping[level]][model](...arguments_),
          ansiStyles.color.close,
          this._styler,
        );
        return createBuilder(this, styler, this._isEmpty);
      };
    },
  };
}
for (const model of usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level: level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          ansiStyles.bgColor[levelMapping[level]][model](...arguments_),
          ansiStyles.bgColor.close,
          this._styler,
        );
        return createBuilder(this, styler, this._isEmpty);
      };
    },
  };
}
const proto = Object.defineProperties(() => {}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    },
  },
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open: open,
    close: close,
    openAll: openAll,
    closeAll: closeAll,
    parent: parent,
  };
};
const createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }
    return applyStyle(
      builder,
      arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "),
    );
  };
  Object.setPrototypeOf(builder, proto);
  builder._generator = self;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self._isEmpty ? "" : string;
  }
  let styler = self._styler;
  if (styler === undefined) {
    return string;
  }
  const { openAll: openAll, closeAll: closeAll } = styler;
  if (string.indexOf("") !== -1) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings) => {
  const [firstString] = strings;
  if (!isArray(firstString) || !isArray(firstString.raw)) {
    return strings.join(" ");
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i = 1; i < firstString.length; i++) {
    parts.push(
      String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
      String(firstString.raw[i]),
    );
  }
  if (template === undefined) {
    template = requireTemplates();
  }
  return template(chalk, parts.join(""));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk();
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
chalk.stderr.supportsColor = stderrColor;
var _DisjointSet_entries;
class DisjointSet {
  constructor() {
    _DisjointSet_entries.set(this, new Map());
  }
  union(items) {
    const first = items.shift();
    CompilerError.invariant(first != null, {
      reason: "Expected set to be non-empty",
      description: null,
      loc: null,
      suggestions: null,
    });
    let root = this.find(first);
    if (root == null) {
      root = first;
      __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(first, first);
    }
    for (const item of items) {
      let itemParent = __classPrivateFieldGet(
        this,
        _DisjointSet_entries,
        "f",
      ).get(item);
      if (itemParent == null) {
        __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(item, root);
        continue;
      } else if (itemParent === root) {
        continue;
      } else {
        let current = item;
        while (itemParent !== root) {
          __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
            current,
            root,
          );
          current = itemParent;
          itemParent = __classPrivateFieldGet(
            this,
            _DisjointSet_entries,
            "f",
          ).get(current);
        }
      }
    }
  }
  find(item) {
    if (!__classPrivateFieldGet(this, _DisjointSet_entries, "f").has(item)) {
      return null;
    }
    const parent = __classPrivateFieldGet(this, _DisjointSet_entries, "f").get(
      item,
    );
    if (parent === item) {
      return item;
    }
    const root = this.find(parent);
    __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(item, root);
    return root;
  }
  canonicalize() {
    const entries = new Map();
    for (const item of __classPrivateFieldGet(
      this,
      _DisjointSet_entries,
      "f",
    ).keys()) {
      const root = this.find(item);
      entries.set(item, root);
    }
    return entries;
  }
  forEach(fn) {
    for (const item of __classPrivateFieldGet(
      this,
      _DisjointSet_entries,
      "f",
    ).keys()) {
      const group = this.find(item);
      fn(item, group);
    }
  }
  buildSets() {
    const ids = new Map();
    const sets = new Map();
    this.forEach((identifier, groupIdentifier) => {
      let id = ids.get(groupIdentifier);
      if (id == null) {
        id = ids.size;
        ids.set(groupIdentifier, id);
      }
      let set = sets.get(id);
      if (set === undefined) {
        set = new Set();
        sets.set(id, set);
      }
      set.add(identifier);
    });
    return [...sets.values()];
  }
  get size() {
    return __classPrivateFieldGet(this, _DisjointSet_entries, "f").size;
  }
}
_DisjointSet_entries = new WeakMap();
function findScopesToMerge(fn) {
  const objectMethodDecls = new Set();
  const mergeScopesBuilder = new DisjointSet();
  for (const [_, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      if (value.kind === "ObjectMethod") {
        objectMethodDecls.add(lvalue.identifier);
      } else if (value.kind === "ObjectExpression") {
        for (const operand of eachInstructionValueOperand(value)) {
          if (objectMethodDecls.has(operand.identifier)) {
            const operandScope = operand.identifier.scope;
            const lvalueScope = lvalue.identifier.scope;
            CompilerError.invariant(
              operandScope != null && lvalueScope != null,
              {
                reason:
                  "Internal error: Expected all ObjectExpressions and ObjectMethods to have non-null scope.",
                suggestions: null,
                loc: GeneratedSource,
              },
            );
            mergeScopesBuilder.union([operandScope, lvalueScope]);
          }
        }
      }
    }
  }
  return mergeScopesBuilder;
}
function alignObjectMethodScopes(fn) {
  for (const [_, block] of fn.body.blocks) {
    for (const { value: value } of block.instructions) {
      if (
        value.kind === "ObjectMethod" ||
        value.kind === "FunctionExpression"
      ) {
        alignObjectMethodScopes(value.loweredFunc.func);
      }
    }
  }
  const scopeGroupsMap = findScopesToMerge(fn).canonicalize();
  for (const [scope, root] of scopeGroupsMap) {
    if (scope !== root) {
      root.range.start = makeInstructionId(
        Math.min(scope.range.start, root.range.start),
      );
      root.range.end = makeInstructionId(
        Math.max(scope.range.end, root.range.end),
      );
    }
  }
  for (const [_, block] of fn.body.blocks) {
    for (const {
      lvalue: { identifier: identifier },
    } of block.instructions) {
      if (identifier.scope != null) {
        const root = scopeGroupsMap.get(identifier.scope);
        if (root != null) {
          identifier.scope = root;
        }
      }
    }
  }
}
function visitReactiveFunction(fn, visitor, state) {
  visitor.visitBlock(fn.body, state);
}
class ReactiveFunctionVisitor {
  visitID(_id, _state) {}
  visitParam(_place, _state) {}
  visitLValue(_id, _lvalue, _state) {}
  visitPlace(_id, _place, _state) {}
  visitReactiveFunctionValue(_id, _dependencies, _fn, _state) {}
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        this.visitValue(id, value.value, state);
        break;
      }
      case "LogicalExpression": {
        this.visitValue(id, value.left, state);
        this.visitValue(id, value.right, state);
        break;
      }
      case "ConditionalExpression": {
        this.visitValue(id, value.test, state);
        this.visitValue(id, value.consequent, state);
        this.visitValue(id, value.alternate, state);
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        this.visitValue(value.id, value.value, state);
        break;
      }
      case "ReactiveFunctionValue": {
        this.visitReactiveFunctionValue(
          id,
          value.dependencies,
          value.fn,
          state,
        );
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    this.visitValue(instruction.id, instruction.value, state);
  }
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
  }
  traverseTerminal(stmt, state) {
    const { terminal: terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        if (terminal.update !== null) {
          this.visitValue(terminal.id, terminal.update, state);
        }
        break;
      }
      case "for-of": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        this.visitValue(terminal.id, terminal.test, state);
        break;
      }
      case "while": {
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== undefined) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind '${terminal.kind}'`,
        );
      }
    }
  }
  visitScope(scope, state) {
    this.traverseScope(scope, state);
  }
  traverseScope(scope, state) {
    this.visitBlock(scope.instructions, state);
  }
  visitBlock(block, state) {
    this.traverseBlock(block, state);
  }
  traverseBlock(block, state) {
    for (const instr of block) {
      switch (instr.kind) {
        case "instruction": {
          this.visitInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          this.visitScope(instr, state);
          break;
        }
        case "terminal": {
          this.visitTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind '${instr.kind}'`,
          );
        }
      }
    }
  }
  visitHirFunction(fn, state) {
    for (const param of fn.params) {
      const place = param.kind === "Identifier" ? param : param.place;
      this.visitParam(place, state);
    }
    for (const [, block] of fn.body.blocks) {
      for (const instr of block.instructions) {
        this.visitInstruction(instr, state);
        if (
          instr.value.kind === "FunctionExpression" ||
          instr.value.kind === "ObjectMethod"
        ) {
          this.visitHirFunction(instr.value.loweredFunc.func, state);
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        this.visitPlace(block.terminal.id, operand, state);
      }
    }
  }
}
class ReactiveFunctionTransform extends ReactiveFunctionVisitor {
  traverseBlock(block, state) {
    let nextBlock = null;
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      let transformed;
      switch (instr.kind) {
        case "instruction": {
          transformed = this.transformInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          transformed = this.transformScope(instr, state);
          break;
        }
        case "terminal": {
          transformed = this.transformTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind '${instr.kind}'`,
          );
        }
      }
      switch (transformed.kind) {
        case "keep": {
          if (nextBlock !== null) {
            nextBlock.push(instr);
          }
          break;
        }
        case "remove": {
          if (nextBlock === null) {
            nextBlock = block.slice(0, i);
          }
          break;
        }
        case "replace": {
          nextBlock !== null && nextBlock !== void 0
            ? nextBlock
            : (nextBlock = block.slice(0, i));
          nextBlock.push(transformed.value);
          break;
        }
        case "replace-many": {
          nextBlock !== null && nextBlock !== void 0
            ? nextBlock
            : (nextBlock = block.slice(0, i));
          nextBlock.push(...transformed.value);
          break;
        }
      }
    }
    if (nextBlock !== null) {
      block.length = 0;
      block.push(...nextBlock);
    }
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    return { kind: "keep" };
  }
  transformTerminal(stmt, state) {
    this.visitTerminal(stmt, state);
    return { kind: "keep" };
  }
  transformScope(scope, state) {
    this.visitScope(scope, state);
    return { kind: "keep" };
  }
  transformValue(id, value, state) {
    this.visitValue(id, value, state);
    return { kind: "keep" };
  }
  transformReactiveFunctionValue(id, dependencies, fn, state) {
    this.visitReactiveFunctionValue(id, dependencies, fn, state);
    return { kind: "keep" };
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        const nextValue = this.transformValue(id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      case "LogicalExpression": {
        const left = this.transformValue(id, value.left, state);
        if (left.kind === "replace") {
          value.left = left.value;
        }
        const right = this.transformValue(id, value.right, state);
        if (right.kind === "replace") {
          value.right = right.value;
        }
        break;
      }
      case "ConditionalExpression": {
        const test = this.transformValue(id, value.test, state);
        if (test.kind === "replace") {
          value.test = test.value;
        }
        const consequent = this.transformValue(id, value.consequent, state);
        if (consequent.kind === "replace") {
          value.consequent = consequent.value;
        }
        const alternate = this.transformValue(id, value.alternate, state);
        if (alternate.kind === "replace") {
          value.alternate = alternate.value;
        }
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const nextValue = this.transformValue(value.id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      case "ReactiveFunctionValue": {
        const nextValue = this.transformReactiveFunctionValue(
          id,
          value.dependencies,
          value.fn,
          state,
        );
        if (nextValue.kind === "replace") {
          value.fn = nextValue.value;
        }
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    const nextValue = this.transformValue(
      instruction.id,
      instruction.value,
      state,
    );
    if (nextValue.kind === "replace") {
      instruction.value = nextValue.value;
    }
  }
  traverseTerminal(stmt, state) {
    const { terminal: terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        if (terminal.update !== null) {
          const update = this.transformValue(
            terminal.id,
            terminal.update,
            state,
          );
          if (update.kind === "replace") {
            terminal.update = update.value;
          }
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-of": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        break;
      }
      case "while": {
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== undefined) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        if (terminal.handlerBinding !== null) {
          this.visitPlace(terminal.id, terminal.handlerBinding, state);
        }
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind '${terminal.kind}'`,
        );
      }
    }
  }
}
function* eachReactiveValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "OptionalExpression": {
      yield* eachReactiveValueOperand(instrValue.value);
      break;
    }
    case "LogicalExpression": {
      yield* eachReactiveValueOperand(instrValue.left);
      yield* eachReactiveValueOperand(instrValue.right);
      break;
    }
    case "SequenceExpression": {
      for (const instr of instrValue.instructions) {
        yield* eachReactiveValueOperand(instr.value);
      }
      yield* eachReactiveValueOperand(instrValue.value);
      break;
    }
    case "ConditionalExpression": {
      yield* eachReactiveValueOperand(instrValue.test);
      yield* eachReactiveValueOperand(instrValue.consequent);
      yield* eachReactiveValueOperand(instrValue.alternate);
      break;
    }
    case "ReactiveFunctionValue": {
      yield* instrValue.dependencies;
      break;
    }
    default: {
      yield* eachInstructionValueOperand(instrValue);
    }
  }
}
function mapTerminalBlocks(terminal, fn) {
  switch (terminal.kind) {
    case "break":
    case "continue":
    case "return":
    case "throw": {
      break;
    }
    case "for": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "for-of": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "for-in": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "do-while":
    case "while": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "if": {
      terminal.consequent = fn(terminal.consequent);
      if (terminal.alternate !== null) {
        terminal.alternate = fn(terminal.alternate);
      }
      break;
    }
    case "switch": {
      for (const case_ of terminal.cases) {
        if (case_.block !== undefined) {
          case_.block = fn(case_.block);
        }
      }
      break;
    }
    case "label": {
      terminal.block = fn(terminal.block);
      break;
    }
    case "try": {
      terminal.block = fn(terminal.block);
      terminal.handler = fn(terminal.handler);
      break;
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
var _Context_builders, _Context_scopes$1, _Builder_instructions, _Builder_stack;
function buildReactiveBlocks(fn) {
  const context = new Context$5();
  fn.body = context.enter(() => {
    visitBlock(context, fn.body);
  });
}
let Context$5 = class Context {
  constructor() {
    _Context_builders.set(this, []);
    _Context_scopes$1.set(this, new Set());
  }
  visitId(id) {
    const builder = __classPrivateFieldGet(this, _Context_builders, "f").at(-1);
    builder.visitId(id);
  }
  visitScope(scope) {
    if (__classPrivateFieldGet(this, _Context_scopes$1, "f").has(scope.id)) {
      return;
    }
    __classPrivateFieldGet(this, _Context_scopes$1, "f").add(scope.id);
    __classPrivateFieldGet(this, _Context_builders, "f")
      .at(-1)
      .startScope(scope);
  }
  append(stmt, label) {
    __classPrivateFieldGet(this, _Context_builders, "f")
      .at(-1)
      .append(stmt, label);
  }
  enter(fn) {
    const builder = new Builder();
    __classPrivateFieldGet(this, _Context_builders, "f").push(builder);
    fn();
    const popped = __classPrivateFieldGet(this, _Context_builders, "f").pop();
    CompilerError.invariant(popped === builder, {
      reason: "Expected push/pop to be called 1:1",
      description: null,
      loc: null,
      suggestions: null,
    });
    return builder.complete();
  }
};
(_Context_builders = new WeakMap()), (_Context_scopes$1 = new WeakMap());
class Builder {
  constructor() {
    _Builder_instructions.set(this, void 0);
    _Builder_stack.set(this, void 0);
    const block = [];
    __classPrivateFieldSet(this, _Builder_instructions, block, "f");
    __classPrivateFieldSet(
      this,
      _Builder_stack,
      [{ kind: "block", block: block }],
      "f",
    );
  }
  append(item, label) {
    if (label !== null) {
      CompilerError.invariant(item.kind === "terminal", {
        reason: "Only terminals may have a label",
        description: null,
        loc: null,
        suggestions: null,
      });
      item.label = label;
    }
    __classPrivateFieldGet(this, _Builder_instructions, "f").push(item);
  }
  startScope(scope) {
    const block = { kind: "scope", scope: scope, instructions: [] };
    this.append(block, null);
    __classPrivateFieldSet(
      this,
      _Builder_instructions,
      block.instructions,
      "f",
    );
    __classPrivateFieldGet(this, _Builder_stack, "f").push({
      kind: "scope",
      block: block,
    });
  }
  visitId(id) {
    for (
      let i = 0;
      i < __classPrivateFieldGet(this, _Builder_stack, "f").length;
      i++
    ) {
      const entry = __classPrivateFieldGet(this, _Builder_stack, "f")[i];
      if (entry.kind === "scope" && id >= entry.block.scope.range.end) {
        __classPrivateFieldGet(this, _Builder_stack, "f").length = i;
        break;
      }
    }
    const last = __classPrivateFieldGet(this, _Builder_stack, "f")[
      __classPrivateFieldGet(this, _Builder_stack, "f").length - 1
    ];
    if (last.kind === "block") {
      __classPrivateFieldSet(this, _Builder_instructions, last.block, "f");
    } else {
      __classPrivateFieldSet(
        this,
        _Builder_instructions,
        last.block.instructions,
        "f",
      );
    }
  }
  complete() {
    const first = __classPrivateFieldGet(this, _Builder_stack, "f")[0];
    CompilerError.invariant(first.kind === "block", {
      reason: "Expected first stack item to be a basic block",
      description: null,
      loc: null,
      suggestions: null,
    });
    return first.block;
  }
}
(_Builder_instructions = new WeakMap()), (_Builder_stack = new WeakMap());
function visitBlock(context, block) {
  for (const stmt of block) {
    switch (stmt.kind) {
      case "instruction": {
        context.visitId(stmt.instruction.id);
        const scope = getInstructionScope(stmt.instruction);
        if (scope !== null) {
          context.visitScope(scope);
        }
        context.append(stmt, null);
        break;
      }
      case "terminal": {
        const id = stmt.terminal.id;
        if (id !== null) {
          context.visitId(id);
        }
        mapTerminalBlocks(stmt.terminal, (block) =>
          context.enter(() => {
            visitBlock(context, block);
          }),
        );
        context.append(stmt, stmt.label);
        break;
      }
      case "scope": {
        CompilerError.invariant(false, {
          reason: "Expected the function to not have scopes already assigned",
          description: null,
          loc: null,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive(stmt, `Unexpected statement kind '${stmt.kind}'`);
      }
    }
  }
}
function getInstructionScope(instr) {
  CompilerError.invariant(instr.lvalue !== null, {
    reason:
      "Expected lvalues to not be null when assigning scopes. " +
      "Pruning lvalues too early can result in missing scope information.",
    description: null,
    loc: instr.loc,
    suggestions: null,
  });
  for (const operand of eachInstructionLValue(instr)) {
    const operandScope = getPlaceScope(instr.id, operand);
    if (operandScope !== null) {
      return operandScope;
    }
  }
  for (const operand of eachReactiveValueOperand(instr.value)) {
    const operandScope = getPlaceScope(instr.id, operand);
    if (operandScope !== null) {
      return operandScope;
    }
  }
  return null;
}
function getPlaceScope(id, place) {
  const scope = place.identifier.scope;
  if (scope !== null && isScopeActive(scope, id)) {
    return scope;
  }
  return null;
}
function isScopeActive(scope, id) {
  return id >= scope.range.start && id < scope.range.end;
}
var _Context_blockScopes, _Context_unclosedScopes, _Context_seenScopes;
function alignReactiveScopesToBlockScopes(fn) {
  const context = new Context$4();
  visitReactiveFunction(fn, new Visitor$b(), context);
}
let Visitor$b = class Visitor extends ReactiveFunctionVisitor {
  visitID(id, state) {
    state.visitId(id);
  }
  visitPlace(id, place, state) {
    const scope = getPlaceScope(id, place);
    if (scope !== null) {
      state.visitScope(scope);
    }
  }
  visitLValue(id, lvalue, state) {
    const scope = getPlaceScope(id, lvalue);
    if (scope !== null) {
      state.visitScope(scope);
    }
  }
  visitInstruction(instr, state) {
    switch (instr.value.kind) {
      case "OptionalExpression":
      case "SequenceExpression":
      case "ConditionalExpression":
      case "LogicalExpression": {
        const prevScopeCount = state.currentScopes().length;
        this.traverseInstruction(instr, state);
        const scopes = state.currentScopes();
        for (let i = prevScopeCount; i < scopes.length; i++) {
          const scope = scopes[i];
          scope.scope.range.start = makeInstructionId(
            Math.min(instr.id, scope.scope.range.start),
          );
        }
        break;
      }
      default: {
        this.traverseInstruction(instr, state);
      }
    }
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
};
let Context$4 = class Context {
  constructor() {
    _Context_blockScopes.set(this, []);
    _Context_unclosedScopes.set(this, []);
    _Context_seenScopes.set(this, new Set());
  }
  currentScopes() {
    var _a;
    return (_a = __classPrivateFieldGet(this, _Context_blockScopes, "f").at(
      -1,
    )) !== null && _a !== void 0
      ? _a
      : [];
  }
  enter(fn) {
    __classPrivateFieldGet(this, _Context_blockScopes, "f").push([]);
    fn();
    const lastScope = __classPrivateFieldGet(
      this,
      _Context_blockScopes,
      "f",
    ).pop();
    for (const scope of lastScope) {
      if (scope.active) {
        __classPrivateFieldGet(this, _Context_unclosedScopes, "f").push(scope);
      }
    }
  }
  visitId(id) {
    const currentScopes = __classPrivateFieldGet(
      this,
      _Context_blockScopes,
      "f",
    ).at(-1);
    const scopes = [
      ...currentScopes,
      ...__classPrivateFieldGet(this, _Context_unclosedScopes, "f"),
    ];
    for (const pending of scopes) {
      if (!pending.active) {
        continue;
      }
      if (id >= pending.scope.range.end) {
        pending.active = false;
        pending.scope.range.end = id;
      }
    }
  }
  visitScope(scope) {
    if (!__classPrivateFieldGet(this, _Context_seenScopes, "f").has(scope.id)) {
      const currentScopes = __classPrivateFieldGet(
        this,
        _Context_blockScopes,
        "f",
      ).at(-1);
      __classPrivateFieldGet(this, _Context_seenScopes, "f").add(scope.id);
      currentScopes.push({ active: true, scope: scope });
    }
  }
};
(_Context_blockScopes = new WeakMap()),
  (_Context_unclosedScopes = new WeakMap()),
  (_Context_seenScopes = new WeakMap());
function assertScopeInstructionsWithinScopes(fn) {
  const existingScopes = new Set();
  visitReactiveFunction(fn, new FindAllScopesVisitor(), existingScopes);
  visitReactiveFunction(
    fn,
    new CheckInstructionsAgainstScopesVisitor(),
    existingScopes,
  );
}
class FindAllScopesVisitor extends ReactiveFunctionVisitor {
  visitScope(block, state) {
    this.traverseScope(block, state);
    state.add(block.scope.id);
  }
}
class CheckInstructionsAgainstScopesVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.activeScopes = new Set();
  }
  visitPlace(id, place, state) {
    const scope = getPlaceScope(id, place);
    if (
      scope !== null &&
      state.has(scope.id) &&
      !this.activeScopes.has(scope.id)
    ) {
      CompilerError.invariant(false, {
        description: `Instruction [${id}] is part of scope @${scope.id}, but that scope has already completed.`,
        loc: place.loc,
        reason:
          "Encountered an instruction that should be part of a scope, but where that scope has already completed",
        suggestions: null,
      });
    }
  }
  visitScope(block, state) {
    this.activeScopes.add(block.scope.id);
    this.traverseScope(block, state);
    this.activeScopes.delete(block.scope.id);
  }
}
var _Context_nextScheduleId,
  _Context_scheduled,
  _Context_catchHandlers,
  _Context_controlFlowStack;
function buildReactiveFunction(fn) {
  const cx = new Context$3(fn.body);
  const driver = new Driver(cx);
  const body = driver.traverseBlock(cx.block(fn.body.entry));
  return {
    loc: fn.loc,
    id: fn.id,
    params: fn.params,
    generator: fn.generator,
    async: fn.async,
    body: body,
    env: fn.env,
    directives: fn.directives,
  };
}
class Driver {
  constructor(cx) {
    this.cx = cx;
  }
  traverseBlock(block) {
    const blockValue = [];
    this.visitBlock(block, blockValue);
    return blockValue;
  }
  visitBlock(block, blockValue) {
    var _a;
    CompilerError.invariant(!this.cx.emitted.has(block.id), {
      reason: `Cannot emit the same block twice: bb${block.id}`,
      description: null,
      loc: null,
      suggestions: null,
    });
    this.cx.emitted.add(block.id);
    for (const instruction of block.instructions) {
      blockValue.push({ kind: "instruction", instruction: instruction });
    }
    const terminal = block.terminal;
    const scheduleIds = [];
    switch (terminal.kind) {
      case "return": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "return",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "throw": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "throw",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "if": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const alternateId =
          terminal.alternate !== terminal.fallthrough
            ? terminal.alternate
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'if' where the consequent is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent),
          );
        }
        let alternate = null;
        if (alternateId !== null) {
          if (this.cx.isScheduled(alternateId)) {
            CompilerError.invariant(false, {
              reason: `Unexpected 'if' where the alternate is already scheduled`,
              loc: terminal.loc,
            });
          } else {
            alternate = this.traverseBlock(this.cx.ir.blocks.get(alternateId));
          }
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent:
              consequent !== null && consequent !== void 0
                ? consequent
                : this.emptyBlock(),
            alternate: alternate,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "switch": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "switch");
          scheduleIds.push(scheduleId);
        }
        const cases = [];
        [...terminal.cases].reverse().forEach((case_, _index) => {
          const test = case_.test;
          let consequent;
          if (this.cx.isScheduled(case_.block)) {
            CompilerError.invariant(case_.block === terminal.fallthrough, {
              reason: `Unexpected 'switch' where a case is already scheduled and block is not the fallthrough`,
              loc: terminal.loc,
            });
            return;
          } else {
            consequent = this.traverseBlock(this.cx.ir.blocks.get(case_.block));
            const scheduleId = this.cx.schedule(case_.block, "case");
            scheduleIds.push(scheduleId);
          }
          cases.push({ test: test, block: consequent });
        });
        cases.reverse();
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "switch",
            loc: terminal.loc,
            test: terminal.test,
            cases: cases,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "do-while": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop,
        );
        scheduleIds.push(scheduleId);
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'do-while' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc,
        ).value;
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "do-while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "while": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop,
        );
        scheduleIds.push(scheduleId);
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc,
        ).value;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'while' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          (_a = terminal.update) !== null && _a !== void 0 ? _a : terminal.test,
          terminal.loop,
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc,
        ).value;
        const updateValue =
          terminal.update !== null
            ? this.visitValueBlock(terminal.update, terminal.loc).value
            : null;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for",
            loc: terminal.loc,
            init: initValue,
            test: testValue,
            update: updateValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-of": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop,
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-of' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-of",
            loc: terminal.loc,
            init: initValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-in": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop,
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-in' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-in",
            loc: terminal.loc,
            init: initValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "branch": {
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          const break_ = this.visitBreak(
            terminal.consequent,
            terminal.id,
            terminal.loc,
          );
          if (break_ !== null) {
            consequent = [break_];
          }
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent),
          );
        }
        let alternate = null;
        if (this.cx.isScheduled(terminal.alternate)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'branch' where the alternate is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          alternate = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.alternate),
          );
        }
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent:
              consequent !== null && consequent !== void 0
                ? consequent
                : this.emptyBlock(),
            alternate: alternate,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "label": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let block;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'label' where the block is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "label",
            loc: terminal.loc,
            block: block,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "sequence":
      case "optional":
      case "ternary":
      case "logical": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        const { place: place, value: value } =
          this.visitValueBlockTerminal(terminal);
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "instruction",
          instruction: {
            id: terminal.id,
            lvalue: place,
            value: value,
            loc: terminal.loc,
          },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "goto": {
        switch (terminal.variant) {
          case GotoVariant.Break: {
            const break_ = this.visitBreak(
              terminal.block,
              terminal.id,
              terminal.loc,
            );
            if (break_ !== null) {
              blockValue.push(break_);
            }
            break;
          }
          case GotoVariant.Continue: {
            const continue_ = this.visitContinue(
              terminal.block,
              terminal.id,
              terminal.loc,
            );
            if (continue_ !== null) {
              blockValue.push(continue_);
            }
            break;
          }
          case GotoVariant.Try: {
            break;
          }
          default: {
            assertExhaustive(
              terminal.variant,
              `Unexpected goto variant '${terminal.variant}'`,
            );
          }
        }
        break;
      }
      case "maybe-throw": {
        if (!this.cx.isScheduled(terminal.continuation)) {
          this.visitBlock(
            this.cx.ir.blocks.get(terminal.continuation),
            blockValue,
          );
        }
        break;
      }
      case "try": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        this.cx.scheduleCatchHandler(terminal.handler);
        const block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        const handler = this.traverseBlock(
          this.cx.ir.blocks.get(terminal.handler),
        );
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
          terminal: {
            kind: "try",
            loc: terminal.loc,
            block: block,
            handlerBinding: terminal.handlerBinding,
            handler: handler,
            id: terminal.id,
          },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "scope": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let block;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'scope' where the block is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "scope",
          instructions: block,
          scope: terminal.scope,
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "unsupported": {
        CompilerError.invariant(false, {
          reason: "Unexpected unsupported terminal",
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive(terminal, "Unexpected terminal");
      }
    }
  }
  visitValueBlock(id, loc) {
    const defaultBlock = this.cx.ir.blocks.get(id);
    if (defaultBlock.terminal.kind === "branch") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: {
            kind: "LoadLocal",
            place: defaultBlock.terminal.test,
            loc: defaultBlock.terminal.test.loc,
          },
          id: defaultBlock.terminal.id,
        };
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        CompilerError.invariant(
          instr.lvalue.identifier.id ===
            defaultBlock.terminal.test.identifier.id,
          {
            reason:
              "Expected branch block to end in an instruction that sets the test value",
            description: null,
            loc: instr.lvalue.loc,
            suggestions: null,
          },
        );
        return {
          block: defaultBlock.id,
          place: instr.lvalue,
          value: instr.value,
          id: instr.id,
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value: instr.value,
          loc: loc,
        };
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: sequence,
          id: defaultBlock.terminal.id,
        };
      }
    } else if (defaultBlock.terminal.kind === "goto") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        CompilerError.invariant(false, {
          reason: "Expected goto value block to have at least one instruction",
          description: null,
          loc: null,
          suggestions: null,
        });
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        let place = instr.lvalue;
        let value = instr.value;
        if (instr.value.kind === "StoreLocal") {
          place = instr.value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: instr.value.value,
            loc: instr.value.value.loc,
          };
        }
        return {
          block: defaultBlock.id,
          place: place,
          value: value,
          id: instr.id,
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        let place = instr.lvalue;
        let value = instr.value;
        if (instr.value.kind === "StoreLocal") {
          place = instr.value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: instr.value.value,
            loc: instr.value.value.loc,
          };
        }
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value: value,
          loc: loc,
        };
        return {
          block: defaultBlock.id,
          place: place,
          value: sequence,
          id: instr.id,
        };
      }
    } else {
      const init = this.visitValueBlockTerminal(defaultBlock.terminal);
      const final = this.visitValueBlock(init.fallthrough, loc);
      const sequence = {
        kind: "SequenceExpression",
        instructions: [
          ...defaultBlock.instructions,
          { id: init.id, loc: loc, lvalue: init.place, value: init.value },
        ],
        id: final.id,
        value: final.value,
        loc: loc,
      };
      return {
        block: init.fallthrough,
        value: sequence,
        place: final.place,
        id: final.id,
      };
    }
  }
  visitValueBlockTerminal(terminal) {
    switch (terminal.kind) {
      case "sequence": {
        const block = this.visitValueBlock(terminal.block, terminal.loc);
        return {
          value: block.value,
          place: block.place,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "optional": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind '${testBlock.terminal.kind}' for optional test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc,
        );
        const call = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: testBlock.terminal.loc,
              lvalue: test.place,
              value: test.value,
            },
          ],
          id: consequent.id,
          value: consequent.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, consequent.place),
          value: {
            kind: "OptionalExpression",
            optional: terminal.optional,
            value: call,
            id: terminal.id,
            loc: terminal.loc,
          },
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "logical": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind '${testBlock.terminal.kind}' for logical test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const leftFinal = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc,
        );
        const left = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: terminal.loc,
              lvalue: test.place,
              value: test.value,
            },
          ],
          id: leftFinal.id,
          value: leftFinal.value,
          loc: terminal.loc,
        };
        const right = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc,
        );
        const value = {
          kind: "LogicalExpression",
          operator: terminal.operator,
          left: left,
          right: right.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, leftFinal.place),
          value: value,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "ternary": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind '${testBlock.terminal.kind}' for ternary test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc,
        );
        const alternate = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc,
        );
        const value = {
          kind: "ConditionalExpression",
          test: test.value,
          consequent: consequent.value,
          alternate: alternate.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, consequent.place),
          value: value,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "maybe-throw": {
        CompilerError.throwTodo({
          reason: `Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      case "label": {
        CompilerError.throwTodo({
          reason: `Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      default: {
        CompilerError.throwTodo({
          reason: `Support '${terminal.kind}' as a value block terminal (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
    }
  }
  emptyBlock() {
    return [];
  }
  visitBreak(block, id, loc) {
    const target = this.cx.getBreakTarget(block);
    if (target === null) {
      CompilerError.invariant(false, {
        reason: "Expected a break target",
        description: null,
        loc: null,
        suggestions: null,
      });
    }
    return {
      kind: "terminal",
      terminal: {
        kind: "break",
        loc: loc,
        target: target.block,
        id: id,
        targetKind: target.type,
      },
      label: null,
    };
  }
  visitContinue(block, id, loc) {
    const target = this.cx.getContinueTarget(block);
    CompilerError.invariant(target !== null, {
      reason: `Expected continue target to be scheduled for bb${block}`,
      description: null,
      loc: null,
      suggestions: null,
    });
    return {
      kind: "terminal",
      terminal: {
        kind: "continue",
        loc: loc,
        target: target.block,
        id: id,
        targetKind: target.type,
      },
      label: null,
    };
  }
}
let Context$3 = class Context {
  constructor(ir) {
    _Context_nextScheduleId.set(this, 0);
    this.emitted = new Set();
    _Context_scheduled.set(this, new Set());
    _Context_catchHandlers.set(this, new Set());
    _Context_controlFlowStack.set(this, []);
    this.ir = ir;
  }
  block(id) {
    return this.ir.blocks.get(id);
  }
  scheduleCatchHandler(block) {
    __classPrivateFieldGet(this, _Context_catchHandlers, "f").add(block);
  }
  schedule(block, type) {
    var _a, _b;
    const id =
      (__classPrivateFieldSet(
        this,
        _Context_nextScheduleId,
        ((_b = __classPrivateFieldGet(this, _Context_nextScheduleId, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a);
    CompilerError.invariant(
      !__classPrivateFieldGet(this, _Context_scheduled, "f").has(block),
      {
        reason: `Break block is already scheduled: bb${block}`,
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(block);
    __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
      block: block,
      id: id,
      type: type,
    });
    return id;
  }
  scheduleLoop(fallthroughBlock, continueBlock, loopBlock) {
    var _a, _b;
    const id =
      (__classPrivateFieldSet(
        this,
        _Context_nextScheduleId,
        ((_b = __classPrivateFieldGet(this, _Context_nextScheduleId, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a);
    const ownsBlock = !__classPrivateFieldGet(
      this,
      _Context_scheduled,
      "f",
    ).has(fallthroughBlock);
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(fallthroughBlock);
    CompilerError.invariant(
      !__classPrivateFieldGet(this, _Context_scheduled, "f").has(continueBlock),
      {
        reason: `Continue block is already scheduled: bb${continueBlock}`,
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(continueBlock);
    let ownsLoop = false;
    if (loopBlock !== null) {
      ownsLoop = !__classPrivateFieldGet(this, _Context_scheduled, "f").has(
        loopBlock,
      );
      __classPrivateFieldGet(this, _Context_scheduled, "f").add(loopBlock);
    }
    __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
      block: fallthroughBlock,
      ownsBlock: ownsBlock,
      id: id,
      type: "loop",
      continueBlock: continueBlock,
      loopBlock: loopBlock,
      ownsLoop: ownsLoop,
    });
    return id;
  }
  unschedule(scheduleId) {
    const last = __classPrivateFieldGet(
      this,
      _Context_controlFlowStack,
      "f",
    ).pop();
    CompilerError.invariant(last !== undefined && last.id === scheduleId, {
      reason: "Can only unschedule the last target",
      description: null,
      loc: null,
      suggestions: null,
    });
    if (last.type !== "loop" || last.ownsBlock !== null) {
      __classPrivateFieldGet(this, _Context_scheduled, "f").delete(last.block);
    }
    if (last.type === "loop") {
      __classPrivateFieldGet(this, _Context_scheduled, "f").delete(
        last.continueBlock,
      );
      if (last.ownsLoop && last.loopBlock !== null) {
        __classPrivateFieldGet(this, _Context_scheduled, "f").delete(
          last.loopBlock,
        );
      }
    }
  }
  unscheduleAll(scheduleIds) {
    for (let i = scheduleIds.length - 1; i >= 0; i--) {
      this.unschedule(scheduleIds[i]);
    }
  }
  isScheduled(block) {
    return (
      __classPrivateFieldGet(this, _Context_scheduled, "f").has(block) ||
      __classPrivateFieldGet(this, _Context_catchHandlers, "f").has(block)
    );
  }
  getBreakTarget(block) {
    let hasPrecedingLoop = false;
    for (
      let i =
        __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const target = __classPrivateFieldGet(
        this,
        _Context_controlFlowStack,
        "f",
      )[i];
      if (target.block === block) {
        let type;
        if (target.type === "loop") {
          type = hasPrecedingLoop ? "labeled" : "unlabeled";
        } else if (
          i ===
          __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length -
            1
        ) {
          type = "implicit";
        } else {
          type = "labeled";
        }
        return { block: target.block, type: type };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    return null;
  }
  getContinueTarget(block) {
    let hasPrecedingLoop = false;
    for (
      let i =
        __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const target = __classPrivateFieldGet(
        this,
        _Context_controlFlowStack,
        "f",
      )[i];
      if (target.type == "loop" && target.continueBlock === block) {
        let type;
        if (hasPrecedingLoop) {
          type = "labeled";
        } else if (
          i ===
          __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length -
            1
        ) {
          type = "implicit";
        } else {
          type = "unlabeled";
        }
        return { block: target.block, type: type };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    return null;
  }
  debugBreakTargets() {
    return __classPrivateFieldGet(this, _Context_controlFlowStack, "f").map(
      (target) => Object.assign({}, target),
    );
  }
};
(_Context_nextScheduleId = new WeakMap()),
  (_Context_scheduled = new WeakMap()),
  (_Context_catchHandlers = new WeakMap()),
  (_Context_controlFlowStack = new WeakMap());
var GuardKind;
(function (GuardKind) {
  GuardKind[(GuardKind["PushHookGuard"] = 0)] = "PushHookGuard";
  GuardKind[(GuardKind["PopHookGuard"] = 1)] = "PopHookGuard";
  GuardKind[(GuardKind["AllowHook"] = 2)] = "AllowHook";
  GuardKind[(GuardKind["DisallowHook"] = 3)] = "DisallowHook";
})(GuardKind || (GuardKind = {}));
function memoizeFbtOperandsInSameScope(fn) {
  const fbtValues = new Set();
  while (true) {
    let size = fbtValues.size;
    visit$1(fn, fbtValues);
    if (size === fbtValues.size) {
      break;
    }
  }
}
const FBT_TAGS = new Set(["fbt", "fbt:param"]);
const SINGLE_CHILD_FBT_TAGS = new Set(["fbt:param"]);
function visit$1(fn, fbtValues) {
  for (const [, block] of fn.body.blocks) {
    for (const instruction of block.instructions) {
      const { lvalue: lvalue, value: value } = instruction;
      if (lvalue === null) {
        return;
      }
      if (
        value.kind === "Primitive" &&
        typeof value.value === "string" &&
        FBT_TAGS.has(value.value)
      ) {
        fbtValues.add(lvalue.identifier.id);
      } else if (value.kind === "LoadGlobal" && FBT_TAGS.has(value.name)) {
        fbtValues.add(lvalue.identifier.id);
      } else if (isFbtCallExpression(fbtValues, value)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          return;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          fbtScope.range.start = makeInstructionId(
            Math.min(
              fbtScope.range.start,
              operand.identifier.mutableRange.start,
            ),
          );
        }
      } else if (
        isFbtJsxExpression(fbtValues, value) ||
        isFbtJsxChild(fbtValues, lvalue, value)
      ) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          return;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          fbtScope.range.start = makeInstructionId(
            Math.min(
              fbtScope.range.start,
              operand.identifier.mutableRange.start,
            ),
          );
          fbtValues.add(operand.identifier.id);
        }
      }
    }
  }
}
function isFbtCallExpression(fbtValues, value) {
  return (
    value.kind === "CallExpression" && fbtValues.has(value.callee.identifier.id)
  );
}
function isFbtJsxExpression(fbtValues, value) {
  return (
    value.kind === "JsxExpression" &&
    ((value.tag.kind === "Identifier" &&
      fbtValues.has(value.tag.identifier.id)) ||
      (value.tag.kind === "BuiltinTag" && FBT_TAGS.has(value.tag.name)))
  );
}
function isFbtJsxChild(fbtValues, lvalue, value) {
  return (
    (value.kind === "JsxExpression" || value.kind === "JsxFragment") &&
    lvalue !== null &&
    fbtValues.has(lvalue.identifier.id)
  );
}
var _Context_nextCacheIndex, _Context_declarations$1;
const MEMO_CACHE_SENTINEL = "react.memo_cache_sentinel";
const EARLY_RETURN_SENTINEL = "react.early_return_sentinel";
function codegenFunction(fn, uniqueIdentifiers) {
  var _a, _b;
  const cx = new Context$2(
    fn.env,
    (_a = fn.id) !== null && _a !== void 0 ? _a : "[[ anonymous ]]",
    uniqueIdentifiers,
    null,
  );
  const compileResult = codegenReactiveFunction(cx, fn);
  if (compileResult.isErr()) {
    return compileResult;
  }
  const compiled = compileResult.unwrap();
  const hookGuard = fn.env.config.enableEmitHookGuards;
  if (hookGuard != null) {
    compiled.body = t__namespace.blockStatement([
      createHookGuard(
        hookGuard,
        compiled.body.body,
        GuardKind.PushHookGuard,
        GuardKind.PopHookGuard,
      ),
    ]);
  }
  const cacheCount = compiled.memoSlotsUsed;
  if (cacheCount !== 0) {
    compiled.body.body.unshift(
      t__namespace.variableDeclaration("const", [
        t__namespace.variableDeclarator(
          t__namespace.identifier(cx.synthesizeName("$")),
          t__namespace.callExpression(t__namespace.identifier("useMemoCache"), [
            t__namespace.numericLiteral(cacheCount),
          ]),
        ),
      ]),
    );
  }
  const emitInstrumentForget = fn.env.config.enableEmitInstrumentForget;
  if (emitInstrumentForget != null && fn.id != null) {
    let gating;
    if (
      emitInstrumentForget.gating != null &&
      emitInstrumentForget.globalGating != null
    ) {
      gating = t__namespace.logicalExpression(
        "&&",
        t__namespace.identifier(emitInstrumentForget.globalGating),
        t__namespace.identifier(
          emitInstrumentForget.gating.importSpecifierName,
        ),
      );
    } else if (emitInstrumentForget.gating != null) {
      gating = t__namespace.identifier(
        emitInstrumentForget.gating.importSpecifierName,
      );
    } else {
      CompilerError.invariant(emitInstrumentForget.globalGating != null, {
        reason:
          "Bad config not caught! Expected at least one of gating or globalGating",
        loc: null,
        suggestions: null,
      });
      gating = t__namespace.identifier(emitInstrumentForget.globalGating);
    }
    const test = t__namespace.ifStatement(
      gating,
      t__namespace.expressionStatement(
        t__namespace.callExpression(
          t__namespace.identifier(emitInstrumentForget.fn.importSpecifierName),
          [
            t__namespace.stringLiteral(fn.id),
            t__namespace.stringLiteral(
              (_b = fn.env.filename) !== null && _b !== void 0 ? _b : "",
            ),
          ],
        ),
      ),
    );
    compiled.body.body.unshift(test);
  }
  return compileResult;
}
function codegenReactiveFunction(cx, fn) {
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      cx.temp.set(param.identifier.id, null);
    } else {
      cx.temp.set(param.place.identifier.id, null);
    }
  }
  const params = fn.params.map((param) => convertParameter(param));
  const body = codegenBlock(cx, fn.body);
  body.directives = fn.directives.map((d) =>
    t__namespace.directive(t__namespace.directiveLiteral(d)),
  );
  const statements = body.body;
  if (statements.length !== 0) {
    const last = statements[statements.length - 1];
    if (last.type === "ReturnStatement" && last.argument == null) {
      statements.pop();
    }
  }
  if (cx.errors.hasErrors()) {
    return Err(cx.errors);
  }
  const countMemoBlockVisitor = new CountMemoBlockVisitor();
  visitReactiveFunction(fn, countMemoBlockVisitor, undefined);
  return Ok({
    type: "CodegenFunction",
    loc: fn.loc,
    id: fn.id !== null ? t__namespace.identifier(fn.id) : null,
    params: params,
    body: body,
    generator: fn.generator,
    async: fn.async,
    memoSlotsUsed: cx.nextCacheIndex,
    memoBlocks: countMemoBlockVisitor.count,
  });
}
class CountMemoBlockVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.count = 0;
  }
  visitScope(scope, state) {
    this.count += 1;
    this.traverseScope(scope, state);
  }
}
function convertParameter(param) {
  if (param.kind === "Identifier") {
    return convertIdentifier(param.identifier);
  } else {
    return t__namespace.restElement(convertIdentifier(param.place.identifier));
  }
}
let Context$2 = class Context {
  constructor(env, fnName, uniqueIdentifiers, temporaries = null) {
    _Context_nextCacheIndex.set(this, 0);
    _Context_declarations$1.set(this, new Set());
    this.errors = new CompilerError();
    this.objectMethods = new Map();
    this.synthesizedNames = new Map();
    this.env = env;
    this.fnName = fnName;
    this.uniqueIdentifiers = uniqueIdentifiers;
    this.temp = temporaries !== null ? new Map(temporaries) : new Map();
  }
  get nextCacheIndex() {
    var _a, _b;
    return (
      __classPrivateFieldSet(
        this,
        _Context_nextCacheIndex,
        ((_b = __classPrivateFieldGet(this, _Context_nextCacheIndex, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a
    );
  }
  declare(identifier) {
    __classPrivateFieldGet(this, _Context_declarations$1, "f").add(
      identifier.id,
    );
  }
  hasDeclared(identifier) {
    return __classPrivateFieldGet(this, _Context_declarations$1, "f").has(
      identifier.id,
    );
  }
  synthesizeName(name) {
    const previous = this.synthesizedNames.get(name);
    if (previous !== undefined) {
      return previous;
    }
    let validated = makeIdentifierName(name).value;
    let index = 0;
    while (this.uniqueIdentifiers.has(validated)) {
      validated = makeIdentifierName(`${name}${index++}`).value;
    }
    this.uniqueIdentifiers.add(validated);
    this.synthesizedNames.set(name, validated);
    return validated;
  }
};
(_Context_nextCacheIndex = new WeakMap()),
  (_Context_declarations$1 = new WeakMap());
function codegenBlock(cx, block) {
  const temp = new Map(cx.temp);
  const result = codegenBlockNoReset(cx, block);
  for (const [key, value] of cx.temp) {
    if (!temp.has(key)) {
      continue;
    }
    CompilerError.invariant(temp.get(key) === value, {
      loc: null,
      reason: "Expected temporary value to be unchanged",
      description: null,
      suggestions: null,
    });
  }
  cx.temp = temp;
  return result;
}
function codegenBlockNoReset(cx, block) {
  const statements = [];
  for (const item of block) {
    switch (item.kind) {
      case "instruction": {
        const statement = codegenInstructionNullable(cx, item.instruction);
        if (statement !== null) {
          statements.push(statement);
        }
        break;
      }
      case "scope": {
        const temp = new Map(cx.temp);
        codegenReactiveScope(cx, statements, item.scope, item.instructions);
        cx.temp = temp;
        break;
      }
      case "terminal": {
        const statement = codegenTerminal(cx, item.terminal);
        if (statement === null) {
          break;
        }
        if (item.label !== null && !item.label.implicit) {
          const block =
            statement.type === "BlockStatement" && statement.body.length === 1
              ? statement.body[0]
              : statement;
          statements.push(
            t__namespace.labeledStatement(
              t__namespace.identifier(codegenLabel(item.label.id)),
              block,
            ),
          );
        } else if (statement.type === "BlockStatement") {
          statements.push(...statement.body);
        } else {
          statements.push(statement);
        }
        break;
      }
      default: {
        assertExhaustive(item, `Unexpected item kind '${item.kind}'`);
      }
    }
  }
  return t__namespace.blockStatement(statements);
}
function wrapCacheDep(cx, value) {
  if (cx.env.config.enableEmitFreeze != null) {
    return t__namespace.conditionalExpression(
      t__namespace.identifier("__DEV__"),
      t__namespace.callExpression(
        t__namespace.identifier(
          cx.env.config.enableEmitFreeze.importSpecifierName,
        ),
        [value, t__namespace.stringLiteral(cx.fnName)],
      ),
      value,
    );
  } else {
    return value;
  }
}
function codegenReactiveScope(cx, statements, scope, block) {
  const cacheStoreStatements = [];
  const cacheLoadStatements = [];
  const changeExpressions = [];
  const changeExpressionComments = [];
  const outputComments = [];
  for (const dep of scope.dependencies) {
    const index = cx.nextCacheIndex;
    changeExpressionComments.push(printDependencyComment(dep));
    const comparison = t__namespace.binaryExpression(
      "!==",
      t__namespace.memberExpression(
        t__namespace.identifier(cx.synthesizeName("$")),
        t__namespace.numericLiteral(index),
        true,
      ),
      codegenDependency(cx, dep),
    );
    if (cx.env.config.enableChangeVariableCodegen) {
      const changeIdentifier = t__namespace.identifier(
        cx.synthesizeName(`c_${index}`),
      );
      statements.push(
        t__namespace.variableDeclaration("const", [
          t__namespace.variableDeclarator(changeIdentifier, comparison),
        ]),
      );
      changeExpressions.push(changeIdentifier);
    } else {
      changeExpressions.push(comparison);
    }
    cacheStoreStatements.push(
      t__namespace.expressionStatement(
        t__namespace.assignmentExpression(
          "=",
          t__namespace.memberExpression(
            t__namespace.identifier(cx.synthesizeName("$")),
            t__namespace.numericLiteral(index),
            true,
          ),
          codegenDependency(cx, dep),
        ),
      ),
    );
  }
  let firstOutputIndex = null;
  for (const [, { identifier: identifier }] of scope.declarations) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    CompilerError.invariant(identifier.name != null, {
      reason: `Expected identifier '@${identifier.id}' to be named`,
      description: null,
      loc: null,
      suggestions: null,
    });
    const name = convertIdentifier(identifier);
    outputComments.push(name.name);
    if (!cx.hasDeclared(identifier)) {
      statements.push(
        t__namespace.variableDeclaration("let", [
          t__namespace.variableDeclarator(name),
        ]),
      );
    }
    cacheStoreStatements.push(
      t__namespace.expressionStatement(
        t__namespace.assignmentExpression(
          "=",
          t__namespace.memberExpression(
            t__namespace.identifier(cx.synthesizeName("$")),
            t__namespace.numericLiteral(index),
            true,
          ),
          wrapCacheDep(cx, name),
        ),
      ),
    );
    cacheLoadStatements.push(
      t__namespace.expressionStatement(
        t__namespace.assignmentExpression(
          "=",
          name,
          t__namespace.memberExpression(
            t__namespace.identifier(cx.synthesizeName("$")),
            t__namespace.numericLiteral(index),
            true,
          ),
        ),
      ),
    );
    cx.declare(identifier);
  }
  for (const reassignment of scope.reassignments) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    const name = convertIdentifier(reassignment);
    outputComments.push(name.name);
    cacheStoreStatements.push(
      t__namespace.expressionStatement(
        t__namespace.assignmentExpression(
          "=",
          t__namespace.memberExpression(
            t__namespace.identifier(cx.synthesizeName("$")),
            t__namespace.numericLiteral(index),
            true,
          ),
          wrapCacheDep(cx, name),
        ),
      ),
    );
    cacheLoadStatements.push(
      t__namespace.expressionStatement(
        t__namespace.assignmentExpression(
          "=",
          name,
          t__namespace.memberExpression(
            t__namespace.identifier(cx.synthesizeName("$")),
            t__namespace.numericLiteral(index),
            true,
          ),
        ),
      ),
    );
  }
  let testCondition = changeExpressions.reduce((acc, ident) => {
    if (acc == null) {
      return ident;
    }
    return t__namespace.logicalExpression("||", acc, ident);
  }, null);
  if (testCondition === null) {
    CompilerError.invariant(firstOutputIndex !== null, {
      reason: `Expected scope to have at least one declaration`,
      description: `Scope '@${scope.id}' has no declarations`,
      loc: null,
      suggestions: null,
    });
    testCondition = t__namespace.binaryExpression(
      "===",
      t__namespace.memberExpression(
        t__namespace.identifier(cx.synthesizeName("$")),
        t__namespace.numericLiteral(firstOutputIndex),
        true,
      ),
      t__namespace.callExpression(
        t__namespace.memberExpression(
          t__namespace.identifier("Symbol"),
          t__namespace.identifier("for"),
        ),
        [t__namespace.stringLiteral(MEMO_CACHE_SENTINEL)],
      ),
    );
  }
  let computationBlock = codegenBlock(cx, block);
  computationBlock.body.push(...cacheStoreStatements);
  const memoBlock = t__namespace.blockStatement(cacheLoadStatements);
  const memoStatement = t__namespace.ifStatement(
    testCondition,
    computationBlock,
    memoBlock,
  );
  if (cx.env.config.enableMemoizationComments) {
    if (changeExpressionComments.length) {
      t__namespace.addComment(
        memoStatement,
        "leading",
        ` check if ${printDelimitedCommentList(changeExpressionComments, "or")} changed`,
        true,
      );
      t__namespace.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true,
      );
    } else {
      t__namespace.addComment(
        memoStatement,
        "leading",
        " cache value with no dependencies",
        true,
      );
      t__namespace.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true,
      );
    }
    if (computationBlock.body.length > 0) {
      t__namespace.addComment(
        computationBlock.body[0],
        "leading",
        ` Inputs changed, recompute`,
        true,
      );
    }
    if (memoBlock.body.length > 0) {
      t__namespace.addComment(
        memoBlock.body[0],
        "leading",
        ` Inputs did not change, use cached value`,
        true,
      );
    }
  }
  statements.push(memoStatement);
  const earlyReturnValue = scope.earlyReturnValue;
  if (earlyReturnValue !== null) {
    CompilerError.invariant(
      earlyReturnValue.value.name !== null &&
        earlyReturnValue.value.name.kind === "named",
      {
        reason: `Expected early return value to be promoted to a named variable`,
        loc: earlyReturnValue.loc,
        description: null,
        suggestions: null,
      },
    );
    const name = earlyReturnValue.value.name.value;
    statements.push(
      t__namespace.ifStatement(
        t__namespace.binaryExpression(
          "!==",
          t__namespace.identifier(name),
          t__namespace.callExpression(
            t__namespace.memberExpression(
              t__namespace.identifier("Symbol"),
              t__namespace.identifier("for"),
            ),
            [t__namespace.stringLiteral(EARLY_RETURN_SENTINEL)],
          ),
        ),
        t__namespace.blockStatement([
          t__namespace.returnStatement(t__namespace.identifier(name)),
        ]),
      ),
    );
  }
}
function codegenTerminal(cx, terminal) {
  switch (terminal.kind) {
    case "break": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return t__namespace.breakStatement(
        terminal.targetKind === "labeled"
          ? t__namespace.identifier(codegenLabel(terminal.target))
          : null,
      );
    }
    case "continue": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return t__namespace.continueStatement(
        terminal.targetKind === "labeled"
          ? t__namespace.identifier(codegenLabel(terminal.target))
          : null,
      );
    }
    case "for": {
      return t__namespace.forStatement(
        codegenForInit(cx, terminal.init),
        codegenInstructionValueToExpression(cx, terminal.test),
        terminal.update !== null
          ? codegenInstructionValueToExpression(cx, terminal.update)
          : null,
        codegenBlock(cx, terminal.loop),
      );
    }
    case "for-in":
    case "for-of": {
      CompilerError.invariant(terminal.init.kind === "SequenceExpression", {
        reason: `Expected a sequence expression init for ForOf`,
        description: `Got '${terminal.init.kind}' expression instead`,
        loc: terminal.init.loc,
        suggestions: null,
      });
      if (terminal.init.instructions.length !== 2) {
        CompilerError.throwTodo({
          reason: "Support non-trivial ForOf inits",
          description: null,
          loc: terminal.init.loc,
          suggestions: null,
        });
      }
      const iterableCollection = terminal.init.instructions[0];
      const iterableItem = terminal.init.instructions[1];
      let lval;
      switch (iterableItem.value.kind) {
        case "StoreLocal": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.place);
          break;
        }
        case "Destructure": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
          break;
        }
        default:
          CompilerError.invariant(false, {
            reason: `Expected a StoreLocal or Destructure to be assigned to the collection`,
            description: `Found ${iterableItem.value.kind}`,
            loc: iterableItem.value.loc,
            suggestions: null,
          });
      }
      let varDeclKind;
      switch (iterableItem.value.lvalue.kind) {
        case InstructionKind.Const:
          varDeclKind = "const";
          break;
        case InstructionKind.Let:
          varDeclKind = "let";
          break;
        case InstructionKind.Reassign:
          CompilerError.invariant(false, {
            reason:
              "Destructure should never be Reassign as it would be an Object/ArrayPattern",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.Catch:
          CompilerError.invariant(false, {
            reason: "Unexpected catch variable as for-of collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.HoistedConst:
          CompilerError.invariant(false, {
            reason: "Unexpected HoistedConst variable in for-of collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        default:
          assertExhaustive(
            iterableItem.value.lvalue.kind,
            `Unhandled lvalue kind: ${iterableItem.value.lvalue.kind}`,
          );
      }
      if (terminal.kind === "for-of") {
        return t__namespace.forOfStatement(
          createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
            t__namespace.variableDeclarator(lval, null),
          ]),
          codegenInstructionValueToExpression(cx, iterableCollection.value),
          codegenBlock(cx, terminal.loop),
        );
      } else {
        return t__namespace.forInStatement(
          createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
            t__namespace.variableDeclarator(lval, null),
          ]),
          codegenInstructionValueToExpression(cx, iterableCollection.value),
          codegenBlock(cx, terminal.loop),
        );
      }
    }
    case "if": {
      const test = codegenPlaceToExpression(cx, terminal.test);
      const consequent = codegenBlock(cx, terminal.consequent);
      let alternate = null;
      if (terminal.alternate !== null) {
        const block = codegenBlock(cx, terminal.alternate);
        if (block.body.length !== 0) {
          alternate = block;
        }
      }
      return t__namespace.ifStatement(test, consequent, alternate);
    }
    case "return": {
      const value = codegenPlaceToExpression(cx, terminal.value);
      if (value.type === "Identifier" && value.name === "undefined") {
        return t__namespace.returnStatement();
      }
      return t__namespace.returnStatement(value);
    }
    case "switch": {
      return t__namespace.switchStatement(
        codegenPlaceToExpression(cx, terminal.test),
        terminal.cases.map((case_) => {
          const test =
            case_.test !== null
              ? codegenPlaceToExpression(cx, case_.test)
              : null;
          const block = codegenBlock(cx, case_.block);
          return t__namespace.switchCase(test, [block]);
        }),
      );
    }
    case "throw": {
      return t__namespace.throwStatement(
        codegenPlaceToExpression(cx, terminal.value),
      );
    }
    case "do-while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return t__namespace.doWhileStatement(
        test,
        codegenBlock(cx, terminal.loop),
      );
    }
    case "while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return t__namespace.whileStatement(test, codegenBlock(cx, terminal.loop));
    }
    case "label": {
      return codegenBlock(cx, terminal.block);
    }
    case "try": {
      let catchParam = null;
      if (terminal.handlerBinding !== null) {
        catchParam = convertIdentifier(terminal.handlerBinding.identifier);
        cx.temp.set(terminal.handlerBinding.identifier.id, null);
      }
      return t__namespace.tryStatement(
        codegenBlock(cx, terminal.block),
        t__namespace.catchClause(
          catchParam,
          codegenBlock(cx, terminal.handler),
        ),
      );
    }
    default: {
      assertExhaustive(terminal, `Unexpected terminal kind '${terminal.kind}'`);
    }
  }
}
function codegenInstructionNullable(cx, instr) {
  if (
    instr.value.kind === "StoreLocal" ||
    instr.value.kind === "StoreContext" ||
    instr.value.kind === "Destructure" ||
    instr.value.kind === "DeclareLocal" ||
    instr.value.kind === "DeclareContext"
  ) {
    let kind = instr.value.lvalue.kind;
    let lvalue;
    let value;
    if (instr.value.kind === "StoreLocal") {
      kind = cx.hasDeclared(instr.value.lvalue.place.identifier)
        ? InstructionKind.Reassign
        : kind;
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (instr.value.kind === "StoreContext") {
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (
      instr.value.kind === "DeclareLocal" ||
      instr.value.kind === "DeclareContext"
    ) {
      if (cx.hasDeclared(instr.value.lvalue.place.identifier)) {
        return null;
      }
      kind = instr.value.lvalue.kind;
      lvalue = instr.value.lvalue.place;
      value = null;
    } else {
      lvalue = instr.value.lvalue.pattern;
      let hasReasign = false;
      let hasDeclaration = false;
      for (const place of eachPatternOperand(lvalue)) {
        if (
          kind !== InstructionKind.Reassign &&
          place.identifier.name === null
        ) {
          cx.temp.set(place.identifier.id, null);
        }
        const isDeclared = cx.hasDeclared(place.identifier);
        hasReasign || (hasReasign = isDeclared);
        hasDeclaration || (hasDeclaration = !isDeclared);
      }
      if (hasReasign && hasDeclaration) {
        CompilerError.invariant(false, {
          reason:
            "Encountered a destructuring operation where some identifiers are already declared (reassignments) but others are not (declarations)",
          description: null,
          loc: instr.loc,
          suggestions: null,
        });
      } else if (hasReasign) {
        kind = InstructionKind.Reassign;
      }
      value = codegenPlaceToExpression(cx, instr.value.value);
    }
    switch (kind) {
      case InstructionKind.Const: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        return createVariableDeclaration(instr.loc, "const", [
          t__namespace.variableDeclarator(codegenLValue(cx, lvalue), value),
        ]);
      }
      case InstructionKind.Let: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        return createVariableDeclaration(instr.loc, "let", [
          t__namespace.variableDeclarator(codegenLValue(cx, lvalue), value),
        ]);
      }
      case InstructionKind.Reassign: {
        CompilerError.invariant(value !== null, {
          reason: "Expected a value for reassignment",
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        const expr = t__namespace.assignmentExpression(
          "=",
          codegenLValue(cx, lvalue),
          value,
        );
        if (instr.lvalue !== null) {
          if (instr.value.kind !== "StoreContext") {
            cx.temp.set(instr.lvalue.identifier.id, expr);
            return null;
          } else {
            const statement = codegenInstruction(cx, instr, expr);
            if (statement.type === "EmptyStatement") {
              return null;
            }
            return statement;
          }
        } else {
          return createExpressionStatement(instr.loc, expr);
        }
      }
      case InstructionKind.Catch: {
        return t__namespace.emptyStatement();
      }
      case InstructionKind.HoistedConst: {
        CompilerError.invariant(false, {
          reason:
            "Expected HoistedConsts to have been pruned in PruneHoistedContexts",
          description: null,
          loc: instr.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive(kind, `Unexpected instruction kind '${kind}'`);
      }
    }
  } else if (
    instr.value.kind === "StartMemoize" ||
    instr.value.kind === "FinishMemoize"
  ) {
    return null;
  } else if (instr.value.kind === "Debugger") {
    return t__namespace.debuggerStatement();
  } else if (instr.value.kind === "ObjectMethod") {
    CompilerError.invariant(instr.lvalue, {
      reason: "Expected object methods to have a temp lvalue",
      loc: null,
      suggestions: null,
    });
    cx.objectMethods.set(instr.lvalue.identifier.id, instr.value);
    return null;
  } else {
    const value = codegenInstructionValue(cx, instr.value);
    const statement = codegenInstruction(cx, instr, value);
    if (statement.type === "EmptyStatement") {
      return null;
    }
    return statement;
  }
}
function codegenForInit(cx, init) {
  if (init.kind === "SequenceExpression") {
    for (const instr of init.instructions) {
      if (instr.value.kind === "DeclareContext") {
        CompilerError.throwTodo({
          reason: `Support for loops where the index variable is a context variable`,
          loc: instr.loc,
          description:
            instr.value.lvalue.place.identifier.name != null
              ? `'${instr.value.lvalue.place.identifier.name.value}' is a context variable`
              : null,
          suggestions: null,
        });
      }
    }
    const body = codegenBlock(
      cx,
      init.instructions.map((instruction) => ({
        kind: "instruction",
        instruction: instruction,
      })),
    ).body;
    const declarators = [];
    let kind = "const";
    body.forEach((instr) => {
      CompilerError.invariant(
        instr.type === "VariableDeclaration" &&
          (instr.kind === "let" || instr.kind === "const"),
        {
          reason: "Expected a variable declaration",
          loc: init.loc,
          description: `Got ${instr.type}`,
          suggestions: null,
        },
      );
      if (instr.kind === "let") {
        kind = "let";
      }
      declarators.push(...instr.declarations);
    });
    CompilerError.invariant(declarators.length > 0, {
      reason: "Expected a variable declaration",
      loc: init.loc,
      description: null,
      suggestions: null,
    });
    return t__namespace.variableDeclaration(kind, declarators);
  } else {
    return codegenInstructionValueToExpression(cx, init);
  }
}
function printDependencyComment(dependency) {
  const identifier = convertIdentifier(dependency.identifier);
  let name = identifier.name;
  if (dependency.path !== null) {
    for (const path of dependency.path) {
      name += `.${path}`;
    }
  }
  return name;
}
function printDelimitedCommentList(items, finalCompletion) {
  if (items.length === 2) {
    return items.join(` ${finalCompletion} `);
  } else if (items.length <= 1) {
    return items.join("");
  }
  let output = [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (i < items.length - 2) {
      output.push(`${item}, `);
    } else if (i === items.length - 2) {
      output.push(`${item}, ${finalCompletion} `);
    } else {
      output.push(item);
    }
  }
  return output.join("");
}
function codegenDependency(cx, dependency) {
  let object = convertIdentifier(dependency.identifier);
  if (dependency.path !== null) {
    for (const path of dependency.path) {
      object = t__namespace.memberExpression(
        object,
        t__namespace.identifier(path),
      );
    }
  }
  return object;
}
function withLoc(fn) {
  return (loc, ...args) => {
    const node = fn(...args);
    if (loc != null && loc != GeneratedSource) {
      node.loc = loc;
    }
    return node;
  };
}
const createBinaryExpression = withLoc(t__namespace.binaryExpression);
const createExpressionStatement = withLoc(t__namespace.expressionStatement);
const createVariableDeclaration = withLoc(t__namespace.variableDeclaration);
const createTaggedTemplateExpression = withLoc(
  t__namespace.taggedTemplateExpression,
);
const createLogicalExpression = withLoc(t__namespace.logicalExpression);
const createSequenceExpression = withLoc(t__namespace.sequenceExpression);
const createConditionalExpression = withLoc(t__namespace.conditionalExpression);
const createTemplateLiteral = withLoc(t__namespace.templateLiteral);
const createJsxNamespacedName = withLoc(t__namespace.jsxNamespacedName);
const createJsxElement = withLoc(t__namespace.jsxElement);
const createJsxAttribute = withLoc(t__namespace.jsxAttribute);
const createJsxIdentifier = withLoc(t__namespace.jsxIdentifier);
const createJsxExpressionContainer = withLoc(
  t__namespace.jsxExpressionContainer,
);
const createJsxText = withLoc(t__namespace.jsxText);
const createJsxClosingElement = withLoc(t__namespace.jsxClosingElement);
const createJsxOpeningElement = withLoc(t__namespace.jsxOpeningElement);
const createStringLiteral = withLoc(t__namespace.stringLiteral);
function createHookGuard(guard, stmts, before, after) {
  function createHookGuardImpl(kind) {
    return t__namespace.expressionStatement(
      t__namespace.callExpression(
        t__namespace.identifier(guard.importSpecifierName),
        [t__namespace.numericLiteral(kind)],
      ),
    );
  }
  return t__namespace.tryStatement(
    t__namespace.blockStatement([createHookGuardImpl(before), ...stmts]),
    null,
    t__namespace.blockStatement([createHookGuardImpl(after)]),
  );
}
function createCallExpression(config, callee, args, loc, isHook) {
  const callExpr = t__namespace.callExpression(callee, args);
  if (loc != null && loc != GeneratedSource) {
    callExpr.loc = loc;
  }
  const hookGuard = config.enableEmitHookGuards;
  if (hookGuard != null && isHook) {
    const iife = t__namespace.functionExpression(
      null,
      [],
      t__namespace.blockStatement([
        createHookGuard(
          hookGuard,
          [t__namespace.returnStatement(callExpr)],
          GuardKind.AllowHook,
          GuardKind.DisallowHook,
        ),
      ]),
    );
    return t__namespace.callExpression(iife, []);
  } else {
    return callExpr;
  }
}
function codegenLabel(id) {
  return `bb${id}`;
}
function codegenInstruction(cx, instr, value) {
  if (t__namespace.isStatement(value)) {
    return value;
  }
  if (instr.lvalue === null) {
    return t__namespace.expressionStatement(convertValueToExpression(value));
  }
  if (instr.lvalue.identifier.name === null) {
    cx.temp.set(instr.lvalue.identifier.id, value);
    return t__namespace.emptyStatement();
  } else {
    const expressionValue = convertValueToExpression(value);
    if (cx.hasDeclared(instr.lvalue.identifier)) {
      return createExpressionStatement(
        instr.loc,
        t__namespace.assignmentExpression(
          "=",
          convertIdentifier(instr.lvalue.identifier),
          expressionValue,
        ),
      );
    } else {
      return createVariableDeclaration(instr.loc, "const", [
        t__namespace.variableDeclarator(
          convertIdentifier(instr.lvalue.identifier),
          expressionValue,
        ),
      ]);
    }
  }
}
function convertValueToExpression(value) {
  if (value.type === "JSXText") {
    return createStringLiteral(value.loc, value.value);
  }
  return value;
}
function codegenInstructionValueToExpression(cx, instrValue) {
  const value = codegenInstructionValue(cx, instrValue);
  return convertValueToExpression(value);
}
function codegenInstructionValue(cx, instrValue) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let value;
  switch (instrValue.kind) {
    case "ArrayExpression": {
      const elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return codegenPlaceToExpression(cx, element);
        } else if (element.kind === "Spread") {
          return t__namespace.spreadElement(
            codegenPlaceToExpression(cx, element.place),
          );
        } else {
          return null;
        }
      });
      value = t__namespace.arrayExpression(elements);
      break;
    }
    case "BinaryExpression": {
      const left = codegenPlaceToExpression(cx, instrValue.left);
      const right = codegenPlaceToExpression(cx, instrValue.right);
      value = createBinaryExpression(
        instrValue.loc,
        instrValue.operator,
        left,
        right,
      );
      break;
    }
    case "UnaryExpression": {
      value = t__namespace.unaryExpression(
        instrValue.operator,
        codegenPlaceToExpression(cx, instrValue.value),
      );
      break;
    }
    case "Primitive": {
      value = codegenValue(cx, instrValue.loc, instrValue.value);
      break;
    }
    case "CallExpression": {
      if (cx.env.config.enableForest) {
        const callee = codegenPlaceToExpression(cx, instrValue.callee);
        const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
        value = t__namespace.callExpression(callee, args);
        if (instrValue.typeArguments != null) {
          value.typeArguments = t__namespace.typeParameterInstantiation(
            instrValue.typeArguments,
          );
        }
        break;
      }
      const isHook = getHookKind(cx.env, instrValue.callee.identifier) != null;
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env.config,
        callee,
        args,
        instrValue.loc,
        isHook,
      );
      break;
    }
    case "OptionalExpression": {
      const optionalValue = codegenInstructionValueToExpression(
        cx,
        instrValue.value,
      );
      switch (optionalValue.type) {
        case "OptionalCallExpression":
        case "CallExpression": {
          CompilerError.invariant(
            t__namespace.isExpression(optionalValue.callee),
            {
              reason: "v8 intrinsics are validated during lowering",
              description: null,
              loc:
                (_a = optionalValue.callee.loc) !== null && _a !== void 0
                  ? _a
                  : null,
              suggestions: null,
            },
          );
          value = t__namespace.optionalCallExpression(
            optionalValue.callee,
            optionalValue.arguments,
            instrValue.optional,
          );
          break;
        }
        case "OptionalMemberExpression":
        case "MemberExpression": {
          const property = optionalValue.property;
          CompilerError.invariant(t__namespace.isExpression(property), {
            reason: "Private names are validated during lowering",
            description: null,
            loc: (_b = property.loc) !== null && _b !== void 0 ? _b : null,
            suggestions: null,
          });
          value = t__namespace.optionalMemberExpression(
            optionalValue.object,
            property,
            optionalValue.computed,
            instrValue.optional,
          );
          break;
        }
        default: {
          CompilerError.invariant(false, {
            reason:
              "Expected an optional value to resolve to a call expression or member expression",
            description: `Got a '${optionalValue.type}'`,
            loc: instrValue.loc,
            suggestions: null,
          });
        }
      }
      break;
    }
    case "MethodCall": {
      const isHook =
        getHookKind(cx.env, instrValue.property.identifier) != null;
      const memberExpr = codegenPlaceToExpression(cx, instrValue.property);
      CompilerError.invariant(
        t__namespace.isMemberExpression(memberExpr) ||
          t__namespace.isOptionalMemberExpression(memberExpr),
        {
          reason:
            "[Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. " +
            `Got a '${memberExpr.type}'`,
          description: null,
          loc: (_c = memberExpr.loc) !== null && _c !== void 0 ? _c : null,
          suggestions: null,
        },
      );
      CompilerError.invariant(
        t__namespace.isNodesEquivalent(
          memberExpr.object,
          codegenPlaceToExpression(cx, instrValue.receiver),
        ),
        {
          reason:
            "[Codegen] Internal error: Forget should always generate MethodCall::property " +
            "as a MemberExpression of MethodCall::receiver",
          description: null,
          loc: (_d = memberExpr.loc) !== null && _d !== void 0 ? _d : null,
          suggestions: null,
        },
      );
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env.config,
        memberExpr,
        args,
        instrValue.loc,
        isHook,
      );
      break;
    }
    case "NewExpression": {
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = t__namespace.newExpression(callee, args);
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      for (const property of instrValue.properties) {
        if (property.kind === "ObjectProperty") {
          const key = codegenObjectPropertyKey(cx, property.key);
          switch (property.type) {
            case "property": {
              const value = codegenPlaceToExpression(cx, property.place);
              properties.push(
                t__namespace.objectProperty(
                  key,
                  value,
                  property.key.kind === "computed",
                  key.type === "Identifier" &&
                    value.type === "Identifier" &&
                    value.name === key.name,
                ),
              );
              break;
            }
            case "method": {
              const method = cx.objectMethods.get(property.place.identifier.id);
              CompilerError.invariant(method, {
                reason: "Expected ObjectMethod instruction",
                loc: null,
                suggestions: null,
              });
              const loweredFunc = method.loweredFunc;
              const reactiveFunction = buildReactiveFunction(loweredFunc.func);
              pruneUnusedLabels(reactiveFunction);
              pruneTemporaryLValues(reactiveFunction);
              const fn = codegenReactiveFunction(
                new Context$2(
                  cx.env,
                  (_e = reactiveFunction.id) !== null && _e !== void 0
                    ? _e
                    : "[[ anonymous ]]",
                  cx.uniqueIdentifiers,
                  cx.temp,
                ),
                reactiveFunction,
              ).unwrap();
              const babelNode = t__namespace.objectMethod(
                "method",
                key,
                fn.params,
                fn.body,
                false,
              );
              babelNode.async = fn.async;
              babelNode.generator = fn.generator;
              properties.push(babelNode);
              break;
            }
            default:
              assertExhaustive(
                property.type,
                `Unexpected property type: ${property.type}`,
              );
          }
        } else {
          properties.push(
            t__namespace.spreadElement(
              codegenPlaceToExpression(cx, property.place),
            ),
          );
        }
      }
      value = t__namespace.objectExpression(properties);
      break;
    }
    case "JSXText": {
      value = createJsxText(instrValue.loc, instrValue.value);
      break;
    }
    case "JsxExpression": {
      const attributes = [];
      for (const attribute of instrValue.props) {
        attributes.push(codegenJsxAttribute(cx, attribute));
      }
      let tagValue =
        instrValue.tag.kind === "Identifier"
          ? codegenPlaceToExpression(cx, instrValue.tag)
          : t__namespace.stringLiteral(instrValue.tag.name);
      let tag;
      if (tagValue.type === "Identifier") {
        tag = createJsxIdentifier(instrValue.tag.loc, tagValue.name);
      } else if (tagValue.type === "MemberExpression") {
        tag = convertMemberExpressionToJsx(tagValue);
      } else {
        CompilerError.invariant(tagValue.type === "StringLiteral", {
          reason: `Expected JSX tag to be an identifier or string, got '${tagValue.type}'`,
          description: null,
          loc: (_f = tagValue.loc) !== null && _f !== void 0 ? _f : null,
          suggestions: null,
        });
        if (tagValue.value.indexOf(":") >= 0) {
          const [namespace, name] = tagValue.value.split(":", 2);
          tag = createJsxNamespacedName(
            instrValue.tag.loc,
            createJsxIdentifier(instrValue.tag.loc, namespace),
            createJsxIdentifier(instrValue.tag.loc, name),
          );
        } else {
          tag = createJsxIdentifier(instrValue.loc, tagValue.value);
        }
      }
      let children;
      if (
        tagValue.type === "StringLiteral" &&
        SINGLE_CHILD_FBT_TAGS.has(tagValue.value)
      ) {
        CompilerError.invariant(instrValue.children != null, {
          loc: instrValue.loc,
          reason: "Expected fbt element to have children",
          suggestions: null,
          description: null,
        });
        children = instrValue.children.map((child) =>
          codegenJsxFbtChildElement(cx, child),
        );
      } else {
        children =
          instrValue.children !== null
            ? instrValue.children.map((child) => codegenJsxElement(cx, child))
            : [];
      }
      value = createJsxElement(
        instrValue.loc,
        createJsxOpeningElement(
          instrValue.openingLoc,
          tag,
          attributes,
          instrValue.children === null,
        ),
        instrValue.children !== null
          ? createJsxClosingElement(instrValue.closingLoc, tag)
          : null,
        children,
        instrValue.children === null,
      );
      break;
    }
    case "JsxFragment": {
      value = t__namespace.jsxFragment(
        t__namespace.jsxOpeningFragment(),
        t__namespace.jsxClosingFragment(),
        instrValue.children.map((child) => codegenJsxElement(cx, child)),
      );
      break;
    }
    case "UnsupportedNode": {
      const node = instrValue.node;
      if (!t__namespace.isExpression(node)) {
        return node;
      }
      value = node;
      break;
    }
    case "PropertyStore": {
      value = t__namespace.assignmentExpression(
        "=",
        t__namespace.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          t__namespace.identifier(instrValue.property),
        ),
        codegenPlaceToExpression(cx, instrValue.value),
      );
      break;
    }
    case "PropertyLoad": {
      const object = codegenPlaceToExpression(cx, instrValue.object);
      value = t__namespace.memberExpression(
        object,
        t__namespace.identifier(instrValue.property),
        undefined,
      );
      break;
    }
    case "PropertyDelete": {
      value = t__namespace.unaryExpression(
        "delete",
        t__namespace.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          t__namespace.identifier(instrValue.property),
        ),
      );
      break;
    }
    case "ComputedStore": {
      value = t__namespace.assignmentExpression(
        "=",
        t__namespace.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true,
        ),
        codegenPlaceToExpression(cx, instrValue.value),
      );
      break;
    }
    case "ComputedLoad": {
      const object = codegenPlaceToExpression(cx, instrValue.object);
      const property = codegenPlaceToExpression(cx, instrValue.property);
      value = t__namespace.memberExpression(object, property, true);
      break;
    }
    case "ComputedDelete": {
      value = t__namespace.unaryExpression(
        "delete",
        t__namespace.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true,
        ),
      );
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      value = codegenPlaceToExpression(cx, instrValue.place);
      break;
    }
    case "FunctionExpression": {
      const loweredFunc = instrValue.loweredFunc.func;
      const reactiveFunction = buildReactiveFunction(loweredFunc);
      pruneUnusedLabels(reactiveFunction);
      pruneTemporaryLValues(reactiveFunction);
      pruneHoistedContexts(reactiveFunction);
      const fn = codegenReactiveFunction(
        new Context$2(
          cx.env,
          (_g = reactiveFunction.id) !== null && _g !== void 0
            ? _g
            : "[[ anonymous ]]",
          cx.uniqueIdentifiers,
          cx.temp,
        ),
        reactiveFunction,
      ).unwrap();
      if (instrValue.expr.type === "ArrowFunctionExpression") {
        let body = fn.body;
        if (body.body.length === 1 && loweredFunc.directives.length == 0) {
          const stmt = body.body[0];
          if (stmt.type === "ReturnStatement" && stmt.argument != null) {
            body = stmt.argument;
          }
        }
        value = t__namespace.arrowFunctionExpression(fn.params, body, fn.async);
      } else {
        value = t__namespace.functionExpression(
          (_h = fn.id) !== null && _h !== void 0
            ? _h
            : instrValue.name != null
              ? t__namespace.identifier(instrValue.name)
              : null,
          fn.params,
          fn.body,
          fn.generator,
          fn.async,
        );
      }
      break;
    }
    case "TaggedTemplateExpression": {
      value = createTaggedTemplateExpression(
        instrValue.loc,
        codegenPlaceToExpression(cx, instrValue.tag),
        t__namespace.templateLiteral(
          [t__namespace.templateElement(instrValue.value)],
          [],
        ),
      );
      break;
    }
    case "TypeCastExpression": {
      if (t__namespace.isTSType(instrValue.typeAnnotation)) {
        value = t__namespace.tsAsExpression(
          codegenPlaceToExpression(cx, instrValue.value),
          instrValue.typeAnnotation,
        );
      } else {
        value = t__namespace.typeCastExpression(
          codegenPlaceToExpression(cx, instrValue.value),
          t__namespace.typeAnnotation(instrValue.typeAnnotation),
        );
      }
      break;
    }
    case "LogicalExpression": {
      value = createLogicalExpression(
        instrValue.loc,
        instrValue.operator,
        codegenInstructionValueToExpression(cx, instrValue.left),
        codegenInstructionValueToExpression(cx, instrValue.right),
      );
      break;
    }
    case "ConditionalExpression": {
      value = createConditionalExpression(
        instrValue.loc,
        codegenInstructionValueToExpression(cx, instrValue.test),
        codegenInstructionValueToExpression(cx, instrValue.consequent),
        codegenInstructionValueToExpression(cx, instrValue.alternate),
      );
      break;
    }
    case "SequenceExpression": {
      const body = codegenBlockNoReset(
        cx,
        instrValue.instructions.map((instruction) => ({
          kind: "instruction",
          instruction: instruction,
        })),
      ).body;
      const expressions = body.map((stmt) => {
        var _a, _b;
        if (stmt.type === "ExpressionStatement") {
          return stmt.expression;
        } else {
          if (t__namespace.isVariableDeclaration(stmt)) {
            const declarator = stmt.declarations[0];
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Cannot declare variables in a value block, tried to declare '${declarator.id.name}'`,
              severity: exports.ErrorSeverity.Todo,
              loc: (_a = declarator.loc) !== null && _a !== void 0 ? _a : null,
              suggestions: null,
            });
            return t__namespace.stringLiteral(`TODO handle ${declarator.id}`);
          } else {
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Handle conversion of ${stmt.type} to expression`,
              severity: exports.ErrorSeverity.Todo,
              loc: (_b = stmt.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
            return t__namespace.stringLiteral(`TODO handle ${stmt.type}`);
          }
        }
      });
      if (expressions.length === 0) {
        value = codegenInstructionValueToExpression(cx, instrValue.value);
      } else {
        value = createSequenceExpression(instrValue.loc, [
          ...expressions,
          codegenInstructionValueToExpression(cx, instrValue.value),
        ]);
      }
      break;
    }
    case "TemplateLiteral": {
      value = createTemplateLiteral(
        instrValue.loc,
        instrValue.quasis.map((q) => t__namespace.templateElement(q)),
        instrValue.subexprs.map((p) => codegenPlaceToExpression(cx, p)),
      );
      break;
    }
    case "LoadGlobal": {
      value = t__namespace.identifier(instrValue.name);
      break;
    }
    case "RegExpLiteral": {
      value = t__namespace.regExpLiteral(instrValue.pattern, instrValue.flags);
      break;
    }
    case "Await": {
      value = t__namespace.awaitExpression(
        codegenPlaceToExpression(cx, instrValue.value),
      );
      break;
    }
    case "NextIterableOf": {
      value = codegenPlaceToExpression(cx, instrValue.value);
      break;
    }
    case "NextPropertyOf": {
      value = codegenPlaceToExpression(cx, instrValue.value);
      break;
    }
    case "PostfixUpdate": {
      value = t__namespace.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        false,
      );
      break;
    }
    case "PrefixUpdate": {
      value = t__namespace.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        true,
      );
      break;
    }
    case "StoreLocal": {
      CompilerError.invariant(
        instrValue.lvalue.kind === InstructionKind.Reassign,
        {
          reason: `Unexpected StoreLocal in codegenInstructionValue`,
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        },
      );
      value = t__namespace.assignmentExpression(
        "=",
        codegenLValue(cx, instrValue.lvalue.place),
        codegenPlaceToExpression(cx, instrValue.value),
      );
      break;
    }
    case "ReactiveFunctionValue":
    case "StartMemoize":
    case "FinishMemoize":
    case "Debugger":
    case "DeclareLocal":
    case "DeclareContext":
    case "Destructure":
    case "ObjectMethod":
    case "StoreContext": {
      CompilerError.invariant(false, {
        reason: `Unexpected ${instrValue.kind} in codegenInstructionValue`,
        description: null,
        loc: instrValue.loc,
        suggestions: null,
      });
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction value kind '${instrValue.kind}'`,
      );
    }
  }
  return value;
}
function codegenJsxAttribute(cx, attribute) {
  switch (attribute.kind) {
    case "JsxAttribute": {
      let propName;
      if (attribute.name.indexOf(":") === -1) {
        propName = createJsxIdentifier(attribute.place.loc, attribute.name);
      } else {
        const [namespace, name] = attribute.name.split(":", 2);
        propName = createJsxNamespacedName(
          attribute.place.loc,
          createJsxIdentifier(attribute.place.loc, namespace),
          createJsxIdentifier(attribute.place.loc, name),
        );
      }
      const innerValue = codegenPlaceToExpression(cx, attribute.place);
      let value;
      switch (innerValue.type) {
        case "StringLiteral": {
          value = innerValue;
          break;
        }
        default: {
          value = createJsxExpressionContainer(attribute.place.loc, innerValue);
          break;
        }
      }
      return createJsxAttribute(attribute.place.loc, propName, value);
    }
    case "JsxSpreadAttribute": {
      return t__namespace.jsxSpreadAttribute(
        codegenPlaceToExpression(cx, attribute.argument),
      );
    }
    default: {
      assertExhaustive(
        attribute,
        `Unexpected attribute kind '${attribute.kind}'`,
      );
    }
  }
}
function codegenJsxElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    case "JSXText": {
      return createJsxText(place.loc, value.value);
    }
    case "JSXElement":
    case "JSXFragment": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function codegenJsxFbtChildElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    case "JSXText":
    case "JSXElement": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function convertMemberExpressionToJsx(expr) {
  var _a, _b;
  CompilerError.invariant(expr.property.type === "Identifier", {
    reason: "Expected JSX member expression property to be a string",
    description: null,
    loc: (_a = expr.loc) !== null && _a !== void 0 ? _a : null,
    suggestions: null,
  });
  const property = t__namespace.jsxIdentifier(expr.property.name);
  if (expr.object.type === "Identifier") {
    return t__namespace.jsxMemberExpression(
      t__namespace.jsxIdentifier(expr.object.name),
      property,
    );
  } else {
    CompilerError.invariant(expr.object.type === "MemberExpression", {
      reason:
        "Expected JSX member expression to be an identifier or nested member expression",
      description: null,
      loc: (_b = expr.object.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
    const object = convertMemberExpressionToJsx(expr.object);
    return t__namespace.jsxMemberExpression(object, property);
  }
}
function codegenObjectPropertyKey(cx, key) {
  switch (key.kind) {
    case "string": {
      return t__namespace.stringLiteral(key.name);
    }
    case "identifier": {
      return t__namespace.identifier(key.name);
    }
    case "computed": {
      const expr = codegenPlace(cx, key.name);
      CompilerError.invariant(t__namespace.isExpression(expr), {
        reason: "Expected object property key to be an expression",
        description: null,
        loc: key.name.loc,
        suggestions: null,
      });
      return expr;
    }
  }
}
function codegenArrayPattern(cx, pattern) {
  const hasHoles = !pattern.items.every((e) => e.kind !== "Hole");
  if (hasHoles) {
    const result = t__namespace.arrayPattern([]);
    for (const item of pattern.items) {
      if (item.kind === "Hole") {
        result.elements.push(null);
      } else {
        result.elements.push(codegenLValue(cx, item));
      }
    }
    return result;
  } else {
    return t__namespace.arrayPattern(
      pattern.items.map((item) => {
        if (item.kind === "Hole") {
          return null;
        }
        return codegenLValue(cx, item);
      }),
    );
  }
}
function codegenLValue(cx, pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return codegenArrayPattern(cx, pattern);
    }
    case "ObjectPattern": {
      return t__namespace.objectPattern(
        pattern.properties.map((property) => {
          if (property.kind === "ObjectProperty") {
            const key = codegenObjectPropertyKey(cx, property.key);
            const value = codegenLValue(cx, property.place);
            return t__namespace.objectProperty(
              key,
              value,
              property.key.kind === "computed",
              key.type === "Identifier" &&
                value.type === "Identifier" &&
                value.name === key.name,
            );
          } else {
            return t__namespace.restElement(codegenLValue(cx, property.place));
          }
        }),
      );
    }
    case "Spread": {
      return t__namespace.restElement(codegenLValue(cx, pattern.place));
    }
    case "Identifier": {
      return convertIdentifier(pattern.identifier);
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
}
function codegenValue(cx, loc, value) {
  if (typeof value === "number") {
    return t__namespace.numericLiteral(value);
  } else if (typeof value === "boolean") {
    return t__namespace.booleanLiteral(value);
  } else if (typeof value === "string") {
    return createStringLiteral(loc, value);
  } else if (value === null) {
    return t__namespace.nullLiteral();
  } else if (value === undefined) {
    return t__namespace.identifier("undefined");
  } else {
    assertExhaustive(value, "Unexpected primitive value kind");
  }
}
function codegenArgument(cx, arg) {
  if (arg.kind === "Identifier") {
    return codegenPlaceToExpression(cx, arg);
  } else {
    return t__namespace.spreadElement(codegenPlaceToExpression(cx, arg.place));
  }
}
function codegenPlaceToExpression(cx, place) {
  const value = codegenPlace(cx, place);
  return convertValueToExpression(value);
}
function codegenPlace(cx, place) {
  let tmp = cx.temp.get(place.identifier.id);
  if (tmp != null) {
    return tmp;
  }
  CompilerError.invariant(place.identifier.name !== null || tmp !== undefined, {
    reason: `[Codegen] No value found for temporary`,
    description: `Value for '${printPlace(place)}' was not set in the codegen context`,
    loc: place.loc,
    suggestions: null,
  });
  const identifier = convertIdentifier(place.identifier);
  identifier.loc = place.loc;
  return identifier;
}
function convertIdentifier(identifier) {
  CompilerError.invariant(
    identifier.name !== null && identifier.name.kind === "named",
    {
      reason: `Expected temporaries to be promoted to named identifiers in an earlier pass`,
      loc: GeneratedSource,
      description: `identifier ${identifier.id} is unnamed`,
      suggestions: null,
    },
  );
  return t__namespace.identifier(identifier.name.value);
}
function extractScopeDeclarationsFromDestructuring(fn) {
  const state = new State$2(fn.env);
  visitReactiveFunction(fn, new Visitor$a(), state);
}
let State$2 = class State {
  constructor(env) {
    this.declared = new Set();
    this.env = env;
  }
};
let Visitor$a = class Visitor extends ReactiveFunctionTransform {
  visitScope(scope, state) {
    for (const [, declaration] of scope.scope.declarations) {
      state.declared.add(declaration.identifier.id);
    }
    this.traverseScope(scope, state);
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    if (instruction.value.kind === "Destructure") {
      const transformed = transformDestructuring(
        state,
        instruction,
        instruction.value,
      );
      if (transformed) {
        return {
          kind: "replace-many",
          value: transformed.map((instruction) => ({
            kind: "instruction",
            instruction: instruction,
          })),
        };
      }
    }
    return { kind: "keep" };
  }
};
function transformDestructuring(state, instr, destructure) {
  let reassigned = new Set();
  let hasDeclaration = false;
  for (const place of eachPatternOperand(destructure.lvalue.pattern)) {
    const isDeclared = state.declared.has(place.identifier.id);
    if (isDeclared) {
      reassigned.add(place.identifier.id);
    }
    hasDeclaration || (hasDeclaration = !isDeclared);
  }
  if (reassigned.size === 0 || !hasDeclaration) {
    return null;
  }
  const instructions = [];
  const renamed = new Map();
  mapPatternOperands(destructure.lvalue.pattern, (place) => {
    if (!reassigned.has(place.identifier.id)) {
      return place;
    }
    const tempId = state.env.nextIdentifierId;
    const temporary = Object.assign(Object.assign({}, place), {
      identifier: Object.assign(Object.assign({}, place.identifier), {
        id: tempId,
        name: null,
      }),
    });
    promoteTemporary(temporary.identifier);
    renamed.set(place, temporary);
    return temporary;
  });
  instructions.push(instr);
  for (const [original, temporary] of renamed) {
    instructions.push({
      id: instr.id,
      lvalue: null,
      value: {
        kind: "StoreLocal",
        lvalue: { kind: InstructionKind.Reassign, place: original },
        value: temporary,
        type: null,
        loc: destructure.loc,
      },
      loc: instr.loc,
    });
  }
  return instructions;
}
function flattenReactiveLoops(fn) {
  visitReactiveFunction(fn, new Transform$6(), false);
}
let Transform$6 = class Transform extends ReactiveFunctionTransform {
  transformScope(scope, isWithinLoop) {
    this.visitScope(scope, isWithinLoop);
    if (isWithinLoop) {
      return { kind: "replace-many", value: scope.instructions };
    } else {
      return { kind: "keep" };
    }
  }
  visitTerminal(stmt, isWithinLoop) {
    switch (stmt.terminal.kind) {
      case "do-while":
      case "while":
      case "for":
      case "for-of":
      case "for-in": {
        this.traverseTerminal(stmt, true);
        break;
      }
      case "try":
      case "label":
      case "break":
      case "continue":
      case "if":
      case "return":
      case "switch":
      case "throw": {
        this.traverseTerminal(stmt, isWithinLoop);
        break;
      }
      default: {
        assertExhaustive(
          stmt.terminal,
          `Unexpected terminal kind '${stmt.terminal.kind}'`,
        );
      }
    }
  }
};
function flattenScopesWithHooksOrUse(fn) {
  visitReactiveFunction(fn, new Transform$5(), { env: fn.env, hasHook: false });
}
let Transform$5 = class Transform extends ReactiveFunctionTransform {
  transformScope(scope, outerState) {
    const innerState = { env: outerState.env, hasHook: false };
    this.visitScope(scope, innerState);
    outerState.hasHook || (outerState.hasHook = innerState.hasHook);
    if (innerState.hasHook) {
      return { kind: "replace-many", value: scope.instructions };
    } else {
      return { kind: "keep" };
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    switch (value.kind) {
      case "CallExpression": {
        if (
          getHookKind(state.env, value.callee.identifier) != null ||
          isUseOperator(value.callee.identifier)
        ) {
          state.hasHook = true;
        }
        break;
      }
      case "MethodCall": {
        if (
          getHookKind(state.env, value.property.identifier) != null ||
          isUseOperator(value.property.identifier)
        ) {
          state.hasHook = true;
        }
        break;
      }
    }
  }
};
function inferReactiveScopeVariables(fn) {
  const scopeIdentifiers = findDisjointMutableValues(fn);
  const scopes = new Map();
  scopeIdentifiers.forEach((identifier, groupIdentifier) => {
    let scope = scopes.get(groupIdentifier);
    if (scope === undefined) {
      scope = {
        id: fn.env.nextScopeId,
        range: identifier.mutableRange,
        dependencies: new Set(),
        declarations: new Map(),
        reassignments: new Set(),
        earlyReturnValue: null,
        merged: new Set(),
      };
      scopes.set(groupIdentifier, scope);
    } else {
      scope.range.start = makeInstructionId(
        Math.min(scope.range.start, identifier.mutableRange.start),
      );
      scope.range.end = makeInstructionId(
        Math.max(scope.range.end, identifier.mutableRange.end),
      );
    }
    identifier.scope = scope;
    identifier.mutableRange = scope.range;
  });
  let maxInstruction = 0;
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      maxInstruction = makeInstructionId(Math.max(maxInstruction, instr.id));
    }
    maxInstruction = makeInstructionId(
      Math.max(maxInstruction, block.terminal.id),
    );
  }
  for (const [, scope] of scopes) {
    if (
      scope.range.start === 0 ||
      scope.range.end === 0 ||
      maxInstruction === 0 ||
      scope.range.end > maxInstruction + 1
    ) {
      CompilerError.invariant(false, {
        reason: `Invalid mutable range for scope`,
        loc: GeneratedSource,
        description: `Scope @${scope.id} has range [${scope.range.start}:${scope.range.end}] but the valid range is [1:${maxInstruction + 1}]`,
      });
    }
  }
}
function isMutable({ id: id }, place) {
  const range = place.identifier.mutableRange;
  return id >= range.start && id < range.end;
}
function mayAllocate(env, instruction) {
  const { value: value } = instruction;
  switch (value.kind) {
    case "Destructure": {
      return doesPatternContainSpreadElement(value.lvalue.pattern);
    }
    case "PostfixUpdate":
    case "PrefixUpdate":
    case "Await":
    case "DeclareLocal":
    case "DeclareContext":
    case "StoreLocal":
    case "LoadGlobal":
    case "TypeCastExpression":
    case "LoadLocal":
    case "LoadContext":
    case "StoreContext":
    case "PropertyDelete":
    case "ComputedLoad":
    case "ComputedDelete":
    case "JSXText":
    case "TemplateLiteral":
    case "Primitive":
    case "NextIterableOf":
    case "NextPropertyOf":
    case "Debugger":
    case "StartMemoize":
    case "FinishMemoize":
    case "UnaryExpression":
    case "BinaryExpression":
    case "PropertyLoad": {
      return false;
    }
    case "CallExpression":
    case "MethodCall": {
      return instruction.lvalue.identifier.type.kind !== "Primitive";
    }
    case "RegExpLiteral":
    case "PropertyStore":
    case "ComputedStore":
    case "ArrayExpression":
    case "JsxExpression":
    case "JsxFragment":
    case "NewExpression":
    case "ObjectExpression":
    case "UnsupportedNode":
    case "ObjectMethod":
    case "FunctionExpression":
    case "TaggedTemplateExpression": {
      return true;
    }
    default: {
      assertExhaustive(value, `Unexpected value kind '${value.kind}'`);
    }
  }
}
function findDisjointMutableValues(fn) {
  var _a, _b;
  const scopeIdentifiers = new DisjointSet();
  for (const [_, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (
        phi.id.mutableRange.start + 1 !== phi.id.mutableRange.end &&
        phi.id.mutableRange.end >
          ((_b =
            (_a = block.instructions.at(0)) === null || _a === void 0
              ? void 0
              : _a.id) !== null && _b !== void 0
            ? _b
            : block.terminal.id)
      ) {
        for (const [, phiId] of phi.operands) {
          scopeIdentifiers.union([phi.id, phiId]);
        }
      } else if (fn.env.config.enableForest) {
        for (const [, phiId] of phi.operands) {
          scopeIdentifiers.union([phi.id, phiId]);
        }
      }
    }
    for (const instr of block.instructions) {
      const operands = [];
      const range = instr.lvalue.identifier.mutableRange;
      if (range.end > range.start + 1 || mayAllocate(fn.env, instr)) {
        operands.push(instr.lvalue.identifier);
      }
      if (
        instr.value.kind === "StoreLocal" ||
        instr.value.kind === "StoreContext"
      ) {
        if (
          instr.value.lvalue.place.identifier.mutableRange.end >
          instr.value.lvalue.place.identifier.mutableRange.start + 1
        ) {
          operands.push(instr.value.lvalue.place.identifier);
        }
        if (
          isMutable(instr, instr.value.value) &&
          instr.value.value.identifier.mutableRange.start > 0
        ) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "Destructure") {
        for (const place of eachPatternOperand(instr.value.lvalue.pattern)) {
          if (
            place.identifier.mutableRange.end >
            place.identifier.mutableRange.start + 1
          ) {
            operands.push(place.identifier);
          }
        }
        if (
          isMutable(instr, instr.value.value) &&
          instr.value.value.identifier.mutableRange.start > 0
        ) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "MethodCall") {
        for (const operand of eachInstructionOperand(instr)) {
          if (
            isMutable(instr, operand) &&
            operand.identifier.mutableRange.start > 0
          ) {
            operands.push(operand.identifier);
          }
        }
        operands.push(instr.value.property.identifier);
      } else {
        for (const operand of eachInstructionOperand(instr)) {
          if (
            isMutable(instr, operand) &&
            operand.identifier.mutableRange.start > 0
          ) {
            operands.push(operand.identifier);
          }
        }
      }
      if (operands.length !== 0) {
        scopeIdentifiers.union(operands);
      }
    }
  }
  return scopeIdentifiers;
}
function mergeOverlappingReactiveScopes(fn) {
  const context = new Context$1();
  visitReactiveFunction(fn, new Visitor$9(), context);
  context.complete();
}
let Visitor$9 = class Visitor extends ReactiveFunctionVisitor {
  visitID(id, state) {
    state.visitId(id);
  }
  visitPlace(id, place, state) {
    state.visitPlace(id, place);
  }
  visitLValue(id, lvalue, state) {
    state.visitPlace(id, lvalue);
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
  visitInstruction(instruction, state) {
    if (
      instruction.value.kind === "ConditionalExpression" ||
      instruction.value.kind === "LogicalExpression" ||
      instruction.value.kind === "OptionalExpression"
    ) {
      state.enter(() => {
        super.visitInstruction(instruction, state);
      });
    } else {
      super.visitInstruction(instruction, state);
    }
  }
};
class BlockScope {
  constructor() {
    this.seen = new Set();
    this.scopes = [];
  }
}
let Context$1 = class Context {
  constructor() {
    this.scopes = [];
    this.seenScopes = new Set();
    this.joinedScopes = new DisjointSet();
    this.operandScopes = new Map();
  }
  visitId(id) {
    const currentBlock = this.scopes[this.scopes.length - 1];
    retainWhere(currentBlock.scopes, (pending) => {
      if (pending.scope.range.end > id) {
        return true;
      } else {
        currentBlock.seen.delete(pending.scope.id);
        return false;
      }
    });
  }
  visitPlace(id, place) {
    const scope = getPlaceScope(id, place);
    if (scope === null) {
      return;
    }
    this.operandScopes.set(place, scope);
    const currentBlock = this.scopes[this.scopes.length - 1];
    if (!this.seenScopes.has(scope.id)) {
      this.seenScopes.add(scope.id);
      currentBlock.seen.add(scope.id);
      currentBlock.scopes.push({ shadowedBy: null, scope: scope });
      return;
    }
    let index = this.scopes.length - 1;
    let nextBlock = currentBlock;
    while (!nextBlock.seen.has(scope.id)) {
      this.joinedScopes.union([scope, ...nextBlock.scopes.map((s) => s.scope)]);
      index--;
      if (index < 0) {
        currentBlock.seen.add(scope.id);
        currentBlock.scopes.push({ shadowedBy: null, scope: scope });
        return;
      }
      nextBlock = this.scopes[index];
    }
    let found = false;
    for (let i = 0; i < nextBlock.scopes.length; i++) {
      const current = nextBlock.scopes[i];
      if (current.scope.id === scope.id) {
        found = true;
        if (current.shadowedBy !== null) {
          this.joinedScopes.union([current.shadowedBy, current.scope]);
        }
      } else if (found && current.shadowedBy === null) {
        current.shadowedBy = scope;
        if (current.scope.range.end > scope.range.end) {
          const end = makeInstructionId(
            Math.max(current.scope.range.end, scope.range.end),
          );
          current.scope.range.end = end;
          scope.range.end = end;
          this.joinedScopes.union([current.scope, scope]);
        }
      }
    }
    if (!currentBlock.seen.has(scope.id)) {
      currentBlock.seen.add(scope.id);
      currentBlock.scopes.push({ shadowedBy: null, scope: scope });
    }
  }
  enter(fn) {
    this.scopes.push(new BlockScope());
    fn();
    this.scopes.pop();
  }
  complete() {
    this.joinedScopes.forEach((scope, groupScope) => {
      if (scope !== groupScope) {
        groupScope.range.start = makeInstructionId(
          Math.min(groupScope.range.start, scope.range.start),
        );
        groupScope.range.end = makeInstructionId(
          Math.max(groupScope.range.end, scope.range.end),
        );
      }
    });
    for (const [operand, originalScope] of this.operandScopes) {
      const mergedScope = this.joinedScopes.find(originalScope);
      if (mergedScope !== null) {
        operand.identifier.scope = mergedScope;
      }
    }
  }
};
function mergeReactiveScopesThatInvalidateTogether(fn) {
  const lastUsageVisitor = new FindLastUsageVisitor();
  visitReactiveFunction(fn, lastUsageVisitor, undefined);
  visitReactiveFunction(fn, new Transform$4(lastUsageVisitor.lastUsage), null);
}
function log$1(msg) {}
class FindLastUsageVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.lastUsage = new Map();
  }
  visitPlace(id, place, _state) {
    const previousUsage = this.lastUsage.get(place.identifier.id);
    const lastUsage =
      previousUsage !== undefined
        ? makeInstructionId(Math.max(previousUsage, id))
        : id;
    this.lastUsage.set(place.identifier.id, lastUsage);
  }
}
let Transform$4 = class Transform extends ReactiveFunctionTransform {
  constructor(lastUsage) {
    super();
    this.lastUsage = lastUsage;
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, scopeBlock.scope.dependencies);
    if (
      state !== null &&
      areEqualDependencies(state, scopeBlock.scope.dependencies)
    ) {
      return { kind: "replace-many", value: scopeBlock.instructions };
    } else {
      return { kind: "keep" };
    }
  }
  visitBlock(block, state) {
    this.traverseBlock(block, state);
    let current = null;
    const merged = [];
    function reset() {
      CompilerError.invariant(current !== null, {
        loc: null,
        reason:
          "MergeConsecutiveScopes: expected current scope to be non-null if reset()",
        suggestions: null,
        description: null,
      });
      if (current.to > current.from + 1) {
        merged.push(current);
      }
      current = null;
    }
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      switch (instr.kind) {
        case "terminal": {
          if (current !== null) {
            log$1(
              `Reset scope @${current.block.scope.id} from terminal [${instr.terminal.id}]`,
            );
            reset();
          }
          break;
        }
        case "instruction": {
          switch (instr.instruction.value.kind) {
            case "ComputedLoad":
            case "JSXText":
            case "LoadLocal":
            case "Primitive":
            case "PropertyLoad": {
              if (current !== null && instr.instruction.lvalue !== null) {
                current.lvalues.add(instr.instruction.lvalue.identifier.id);
              }
              break;
            }
            default: {
              if (current !== null) {
                log$1(
                  `Reset scope @${current.block.scope.id} from instruction [${instr.instruction.id}]`,
                );
                reset();
              }
            }
          }
          break;
        }
        case "scope": {
          if (
            current !== null &&
            canMergeScopes(current.block, instr) &&
            areLValuesLastUsedByScope(
              instr.scope,
              current.lvalues,
              this.lastUsage,
            )
          ) {
            log$1(
              `Can merge scope @${current.block.scope.id} with @${instr.scope.id}`,
            );
            current.block.scope.range.end = makeInstructionId(
              Math.max(current.block.scope.range.end, instr.scope.range.end),
            );
            for (const [key, value] of instr.scope.declarations) {
              current.block.scope.declarations.set(key, value);
            }
            updateScopeDeclarations(current.block.scope, this.lastUsage);
            current.to = i + 1;
            current.lvalues.clear();
            if (!scopeIsEligibleForMerging(instr)) {
              log$1(
                `  but scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`,
              );
              reset();
            }
          } else {
            if (current !== null) {
              log$1(
                `Reset scope @${current.block.scope.id}, not mergeable with subsequent scope @${instr.scope.id}`,
              );
              reset();
            }
            if (scopeIsEligibleForMerging(instr)) {
              current = {
                block: instr,
                from: i,
                to: i + 1,
                lvalues: new Set(),
              };
            } else {
              log$1(
                `scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`,
              );
            }
          }
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind '${instr.kind}'`,
          );
        }
      }
    }
    if (current !== null) {
      reset();
    }
    if (merged.length) {
      log$1(`merged ${merged.length} scopes:`);
      for (const entry of merged) {
        log$1(
          printReactiveScopeSummary(entry.block.scope) +
            ` from=${entry.from} to=${entry.to}`,
        );
      }
    }
    if (merged.length === 0) {
      return;
    }
    const nextInstructions = [];
    let index = 0;
    for (const entry of merged) {
      if (index < entry.from) {
        nextInstructions.push(...block.slice(index, entry.from));
        index = entry.from;
      }
      const mergedScope = block[entry.from];
      CompilerError.invariant(mergedScope.kind === "scope", {
        loc: null,
        reason:
          "MergeConsecutiveScopes: Expected scope starting index to be a scope",
        description: null,
        suggestions: null,
      });
      nextInstructions.push(mergedScope);
      index++;
      while (index < entry.to) {
        const instr = block[index++];
        if (instr.kind === "scope") {
          mergedScope.instructions.push(...instr.instructions);
          mergedScope.scope.merged.add(instr.scope.id);
        } else {
          mergedScope.instructions.push(instr);
        }
      }
    }
    while (index < block.length) {
      nextInstructions.push(block[index++]);
    }
    block.length = 0;
    block.push(...nextInstructions);
  }
};
function updateScopeDeclarations(scope, lastUsage) {
  for (const [key] of scope.declarations) {
    const lastUsedAt = lastUsage.get(key);
    if (lastUsedAt < scope.range.end) {
      scope.declarations.delete(key);
    }
  }
}
function areLValuesLastUsedByScope(scope, lvalues, lastUsage) {
  for (const lvalue of lvalues) {
    const lastUsedAt = lastUsage.get(lvalue);
    if (lastUsedAt >= scope.range.end) {
      log$1(`  lvalue ${lvalue} used after scope @${scope.id}, cannot merge`);
      return false;
    }
  }
  return true;
}
function canMergeScopes(current, next) {
  if (
    current.scope.reassignments.size !== 0 ||
    next.scope.reassignments.size !== 0
  ) {
    return false;
  }
  if (
    areEqualDependencies(current.scope.dependencies, next.scope.dependencies)
  ) {
    return true;
  }
  if (
    areEqualDependencies(
      new Set(
        [...current.scope.declarations.values()].map((declaration) => ({
          identifier: declaration.identifier,
          path: [],
        })),
      ),
      next.scope.dependencies,
    )
  ) {
    return true;
  }
  log$1(`  ${printReactiveScopeSummary(current.scope)}`);
  log$1(`  ${printReactiveScopeSummary(next.scope)}`);
  return false;
}
function areEqualDependencies(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const aValue of a) {
    let found = false;
    for (const bValue of b) {
      if (
        aValue.identifier === bValue.identifier &&
        areEqualPaths(aValue.path, bValue.path)
      ) {
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function areEqualPaths(a, b) {
  return a.length === b.length && a.every((item, ix) => item === b[ix]);
}
function scopeIsEligibleForMerging(scopeBlock) {
  if (scopeBlock.scope.dependencies.size === 0) {
    return true;
  }
  const visitor = new DeclarationTypeVisitor(scopeBlock.scope);
  visitor.visitScope(scopeBlock, undefined);
  return visitor.alwaysInvalidatesOnInputChange;
}
class DeclarationTypeVisitor extends ReactiveFunctionVisitor {
  constructor(scope) {
    super();
    this.alwaysInvalidatesOnInputChange = false;
    this.scope = scope;
  }
  visitScope(scopeBlock, state) {
    if (scopeBlock.scope.id !== this.scope.id) {
      return;
    }
    this.traverseScope(scopeBlock, state);
  }
  visitInstruction(instruction, state) {
    var _a;
    this.traverseInstruction(instruction, state);
    if (
      instruction.lvalue === null ||
      !this.scope.declarations.has(instruction.lvalue.identifier.id)
    ) {
      log$1(
        `    skip instruction lvalue=${(_a = instruction.lvalue) === null || _a === void 0 ? void 0 : _a.identifier.id} declaration?=${instruction.lvalue != null && this.scope.declarations.has(instruction.lvalue.identifier.id)} scope=${printReactiveScopeSummary(this.scope)}`,
      );
      return;
    }
    switch (instruction.value.kind) {
      case "FunctionExpression":
      case "ArrayExpression":
      case "JsxExpression":
      case "JsxFragment":
      case "ObjectExpression": {
        this.alwaysInvalidatesOnInputChange = true;
        break;
      }
    }
  }
}
let Visitor$8 = class Visitor extends ReactiveFunctionVisitor {
  visitScope(block, state) {
    this.traverseScope(block, state);
    for (const dep of block.scope.dependencies) {
      const { identifier: identifier } = dep;
      if (identifier.name == null) {
        promoteIdentifier(identifier, state);
      }
    }
    for (const [, declaration] of block.scope.declarations) {
      if (declaration.identifier.name == null) {
        promoteIdentifier(declaration.identifier, state);
      }
    }
  }
  visitParam(place, state) {
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, fn, state) {
    for (const operand of fn.params) {
      const place = operand.kind === "Identifier" ? operand : operand.place;
      if (place.identifier.name === null) {
        promoteIdentifier(place.identifier, state);
      }
    }
    visitReactiveFunction(fn, this, state);
  }
};
class CollectJsxTagsVisitor extends ReactiveFunctionVisitor {
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "JsxExpression" && value.tag.kind === "Identifier") {
      state.add(value.tag.identifier.id);
    }
  }
}
function promoteUsedTemporaries(fn) {
  const tags = new Set();
  visitReactiveFunction(fn, new CollectJsxTagsVisitor(), tags);
  const state = { tags: tags };
  for (const operand of fn.params) {
    const place = operand.kind === "Identifier" ? operand : operand.place;
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitReactiveFunction(fn, new Visitor$8(), state);
}
function promoteIdentifier(identifier, state) {
  CompilerError.invariant(identifier.name === null, {
    reason:
      "promoteTemporary: Expected to be called only for temporary variables",
    description: null,
    loc: GeneratedSource,
    suggestions: null,
  });
  if (state.tags.has(identifier.id)) {
    promoteTemporaryJsxTag(identifier);
  } else {
    promoteTemporary(identifier);
  }
}
function propagateEarlyReturns(fn) {
  visitReactiveFunction(fn, new Transform$3(fn.env), {
    withinReactiveScope: false,
    earlyReturnValue: null,
  });
}
let Transform$3 = class Transform extends ReactiveFunctionTransform {
  constructor(env) {
    super();
    this.env = env;
  }
  visitScope(scopeBlock, parentState) {
    const innerState = {
      withinReactiveScope: true,
      earlyReturnValue: parentState.earlyReturnValue,
    };
    this.traverseScope(scopeBlock, innerState);
    const earlyReturnValue = innerState.earlyReturnValue;
    if (earlyReturnValue !== null) {
      if (!parentState.withinReactiveScope) {
        scopeBlock.scope.earlyReturnValue = earlyReturnValue;
        scopeBlock.scope.declarations.set(earlyReturnValue.value.id, {
          identifier: earlyReturnValue.value,
          scope: scopeBlock.scope,
        });
        const instructions = scopeBlock.instructions;
        const loc = earlyReturnValue.loc;
        const sentinelTemp = createTemporaryPlace(this.env);
        const symbolTemp = createTemporaryPlace(this.env);
        const forTemp = createTemporaryPlace(this.env);
        const argTemp = createTemporaryPlace(this.env);
        scopeBlock.instructions = [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, symbolTemp),
              value: { kind: "LoadGlobal", name: "Symbol", loc: loc },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, forTemp),
              value: {
                kind: "PropertyLoad",
                object: Object.assign({}, symbolTemp),
                property: "for",
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, argTemp),
              value: {
                kind: "Primitive",
                value: EARLY_RETURN_SENTINEL,
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, sentinelTemp),
              value: {
                kind: "MethodCall",
                receiver: symbolTemp,
                property: forTemp,
                args: [argTemp],
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc: loc,
                type: null,
                lvalue: {
                  kind: InstructionKind.Let,
                  place: {
                    kind: "Identifier",
                    effect: exports.Effect.ConditionallyMutate,
                    loc: loc,
                    reactive: true,
                    identifier: earlyReturnValue.value,
                  },
                },
                value: Object.assign({}, sentinelTemp),
              },
            },
          },
          {
            kind: "terminal",
            label: { id: earlyReturnValue.label, implicit: false },
            terminal: {
              kind: "label",
              id: makeInstructionId(0),
              loc: GeneratedSource,
              block: instructions,
            },
          },
        ];
      } else {
        parentState.earlyReturnValue = earlyReturnValue;
      }
    }
  }
  transformTerminal(stmt, state) {
    if (state.withinReactiveScope && stmt.terminal.kind === "return") {
      const loc = stmt.terminal.value.loc;
      let earlyReturnValue;
      if (state.earlyReturnValue !== null) {
        earlyReturnValue = state.earlyReturnValue;
      } else {
        const identifier = createTemporaryPlace(this.env).identifier;
        promoteTemporary(identifier);
        earlyReturnValue = {
          label: this.env.nextBlockId,
          loc: loc,
          value: identifier,
        };
      }
      state.earlyReturnValue = earlyReturnValue;
      return {
        kind: "replace-many",
        value: [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc: loc,
                type: null,
                lvalue: {
                  kind: InstructionKind.Reassign,
                  place: {
                    kind: "Identifier",
                    identifier: earlyReturnValue.value,
                    effect: exports.Effect.Capture,
                    loc: loc,
                    reactive: true,
                  },
                },
                value: stmt.terminal.value,
              },
            },
          },
          {
            kind: "terminal",
            label: null,
            terminal: {
              kind: "break",
              id: makeInstructionId(0),
              loc: loc,
              targetKind: "labeled",
              target: earlyReturnValue.label,
            },
          },
        ],
      };
    }
    this.traverseTerminal(stmt, state);
    return { kind: "keep" };
  }
};
var _Node_value, _Node_next;
function empty() {
  return EMPTY;
}
class Node {
  constructor(value, next = EMPTY) {
    _Node_value.set(this, void 0);
    _Node_next.set(this, void 0);
    __classPrivateFieldSet(this, _Node_value, value, "f");
    __classPrivateFieldSet(this, _Node_next, next, "f");
  }
  push(value) {
    return new Node(value, this);
  }
  pop() {
    return __classPrivateFieldGet(this, _Node_next, "f");
  }
  find(fn) {
    return fn(__classPrivateFieldGet(this, _Node_value, "f"))
      ? true
      : __classPrivateFieldGet(this, _Node_next, "f").find(fn);
  }
  contains(value) {
    return (
      value === __classPrivateFieldGet(this, _Node_value, "f") ||
      (__classPrivateFieldGet(this, _Node_next, "f") !== null &&
        __classPrivateFieldGet(this, _Node_next, "f").contains(value))
    );
  }
  each(fn) {
    fn(__classPrivateFieldGet(this, _Node_value, "f"));
    __classPrivateFieldGet(this, _Node_next, "f").each(fn);
  }
  get value() {
    return __classPrivateFieldGet(this, _Node_value, "f");
  }
  print(fn) {
    return (
      fn(__classPrivateFieldGet(this, _Node_value, "f")) +
      __classPrivateFieldGet(this, _Node_next, "f").print(fn)
    );
  }
}
(_Node_value = new WeakMap()), (_Node_next = new WeakMap());
class Empty {
  push(value) {
    return new Node(value, this);
  }
  pop() {
    return this;
  }
  find(_fn) {
    return false;
  }
  contains(_value) {
    return false;
  }
  each(_fn) {
    return;
  }
  get value() {
    return null;
  }
  print(_) {
    return "";
  }
}
const EMPTY = new Empty();
var _ReactiveScopeDependencyTree_instances,
  _ReactiveScopeDependencyTree_roots,
  _ReactiveScopeDependencyTree_getOrCreateRoot;
class ReactiveScopeDependencyTree {
  constructor() {
    _ReactiveScopeDependencyTree_instances.add(this);
    _ReactiveScopeDependencyTree_roots.set(this, new Map());
  }
  add(dep, inConditional) {
    const { path: path, optionalPath: optionalPath } = dep;
    let currNode = __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_instances,
      "m",
      _ReactiveScopeDependencyTree_getOrCreateRoot,
    ).call(this, dep.identifier);
    const accessType = inConditional
      ? PropertyAccessType.ConditionalAccess
      : PropertyAccessType.UnconditionalAccess;
    for (const property of path) {
      let currChild = getOrMakeProperty(currNode, property);
      currChild.accessType = merge$1(currChild.accessType, accessType);
      currNode = currChild;
    }
    if (optionalPath.length === 0) {
      const depType = inConditional
        ? PropertyAccessType.ConditionalDependency
        : PropertyAccessType.UnconditionalDependency;
      currNode.accessType = merge$1(currNode.accessType, depType);
    } else {
      for (const property of optionalPath) {
        let currChild = getOrMakeProperty(currNode, property);
        currChild.accessType = merge$1(
          currChild.accessType,
          PropertyAccessType.ConditionalAccess,
        );
        currNode = currChild;
      }
      currNode.accessType = merge$1(
        currNode.accessType,
        PropertyAccessType.ConditionalDependency,
      );
    }
  }
  deriveMinimalDependencies() {
    const results = new Set();
    for (const [rootId, rootNode] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f",
    ).entries()) {
      const deps = deriveMinimalDependenciesInSubtree(rootNode);
      CompilerError.invariant(
        deps.every(
          (dep) =>
            dep.accessType === PropertyAccessType.UnconditionalDependency,
        ),
        {
          reason:
            "[PropagateScopeDependencies] All dependencies must be reduced to unconditional dependencies.",
          description: null,
          loc: null,
          suggestions: null,
        },
      );
      for (const dep of deps) {
        results.add({ identifier: rootId, path: dep.relativePath });
      }
    }
    return results;
  }
  addDepsFromInnerScope(
    depsFromInnerScope,
    innerScopeInConditionalWithinParent,
    checkValidDepIdFn,
  ) {
    for (const [id, otherRoot] of __classPrivateFieldGet(
      depsFromInnerScope,
      _ReactiveScopeDependencyTree_roots,
      "f",
    )) {
      if (!checkValidDepIdFn({ identifier: id, path: [] })) {
        continue;
      }
      let currRoot = __classPrivateFieldGet(
        this,
        _ReactiveScopeDependencyTree_instances,
        "m",
        _ReactiveScopeDependencyTree_getOrCreateRoot,
      ).call(this, id);
      addSubtree(currRoot, otherRoot, innerScopeInConditionalWithinParent);
      if (!isUnconditional(currRoot.accessType)) {
        currRoot.accessType = isDependency(currRoot.accessType)
          ? PropertyAccessType.UnconditionalDependency
          : PropertyAccessType.UnconditionalAccess;
      }
    }
  }
  promoteDepsFromExhaustiveConditionals(trees) {
    CompilerError.invariant(trees.length > 1, {
      reason: "Expected trees to be at least 2 elements long.",
      description: null,
      loc: null,
      suggestions: null,
    });
    for (const [id, root] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f",
    )) {
      const nodesForRootId = mapNonNull(trees, (tree) => {
        const node = __classPrivateFieldGet(
          tree,
          _ReactiveScopeDependencyTree_roots,
          "f",
        ).get(id);
        if (node != null && isUnconditional(node.accessType)) {
          return node;
        } else {
          return null;
        }
      });
      if (nodesForRootId) {
        addSubtreeIntersection(
          root.properties,
          nodesForRootId.map((root) => root.properties),
        );
      }
    }
  }
  printDeps(includeAccesses) {
    let res = [];
    for (const [rootId, rootNode] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f",
    ).entries()) {
      const rootResults = printSubtree(rootNode, includeAccesses).map(
        (result) => `${printIdentifier(rootId)}.${result}`,
      );
      res.push(rootResults);
    }
    return res.flat().join("\n");
  }
}
(_ReactiveScopeDependencyTree_roots = new WeakMap()),
  (_ReactiveScopeDependencyTree_instances = new WeakSet()),
  (_ReactiveScopeDependencyTree_getOrCreateRoot =
    function _ReactiveScopeDependencyTree_getOrCreateRoot(identifier) {
      let rootNode = __classPrivateFieldGet(
        this,
        _ReactiveScopeDependencyTree_roots,
        "f",
      ).get(identifier);
      if (rootNode === undefined) {
        rootNode = {
          properties: new Map(),
          accessType: PropertyAccessType.UnconditionalAccess,
        };
        __classPrivateFieldGet(
          this,
          _ReactiveScopeDependencyTree_roots,
          "f",
        ).set(identifier, rootNode);
      }
      return rootNode;
    });
var PropertyAccessType;
(function (PropertyAccessType) {
  PropertyAccessType["ConditionalAccess"] = "ConditionalAccess";
  PropertyAccessType["UnconditionalAccess"] = "UnconditionalAccess";
  PropertyAccessType["ConditionalDependency"] = "ConditionalDependency";
  PropertyAccessType["UnconditionalDependency"] = "UnconditionalDependency";
})(PropertyAccessType || (PropertyAccessType = {}));
const MIN_ACCESS_TYPE = PropertyAccessType.ConditionalAccess;
function isUnconditional(access) {
  return (
    access === PropertyAccessType.UnconditionalAccess ||
    access === PropertyAccessType.UnconditionalDependency
  );
}
function isDependency(access) {
  return (
    access === PropertyAccessType.ConditionalDependency ||
    access === PropertyAccessType.UnconditionalDependency
  );
}
function merge$1(access1, access2) {
  const resultIsUnconditional =
    isUnconditional(access1) || isUnconditional(access2);
  const resultIsDependency = isDependency(access1) || isDependency(access2);
  if (resultIsUnconditional) {
    if (resultIsDependency) {
      return PropertyAccessType.UnconditionalDependency;
    } else {
      return PropertyAccessType.UnconditionalAccess;
    }
  } else {
    if (resultIsDependency) {
      return PropertyAccessType.ConditionalDependency;
    } else {
      return PropertyAccessType.ConditionalAccess;
    }
  }
}
const promoteUncondResult = [
  { relativePath: [], accessType: PropertyAccessType.UnconditionalDependency },
];
const promoteCondResult = [
  { relativePath: [], accessType: PropertyAccessType.ConditionalDependency },
];
function deriveMinimalDependenciesInSubtree(dep) {
  const results = [];
  for (const [childName, childNode] of dep.properties) {
    const childResult = deriveMinimalDependenciesInSubtree(childNode).map(
      ({ relativePath: relativePath, accessType: accessType }) => ({
        relativePath: [childName, ...relativePath],
        accessType: accessType,
      }),
    );
    results.push(...childResult);
  }
  switch (dep.accessType) {
    case PropertyAccessType.UnconditionalDependency: {
      return promoteUncondResult;
    }
    case PropertyAccessType.UnconditionalAccess: {
      if (
        results.every(
          ({ accessType: accessType }) =>
            accessType === PropertyAccessType.UnconditionalDependency,
        )
      ) {
        return results;
      } else {
        return promoteUncondResult;
      }
    }
    case PropertyAccessType.ConditionalAccess:
    case PropertyAccessType.ConditionalDependency: {
      if (
        results.every(
          ({ accessType: accessType }) =>
            accessType === PropertyAccessType.ConditionalDependency,
        )
      ) {
        return promoteCondResult;
      } else {
        return promoteUncondResult;
      }
    }
    default: {
      assertExhaustive(
        dep.accessType,
        "[PropgateScopeDependencies] Unhandled access type!",
      );
    }
  }
}
function demoteSubtreeToConditional(subtree) {
  const stack = [subtree];
  let node;
  while ((node = stack.pop()) !== undefined) {
    const { accessType: accessType, properties: properties } = node;
    if (!isUnconditional(accessType)) {
      continue;
    }
    node.accessType = isDependency(accessType)
      ? PropertyAccessType.ConditionalDependency
      : PropertyAccessType.ConditionalAccess;
    for (const childNode of properties.values()) {
      if (isUnconditional(accessType)) {
        stack.push(childNode);
      }
    }
  }
}
function addSubtree(currNode, otherNode, demoteOtherNode) {
  let otherType = otherNode.accessType;
  if (demoteOtherNode) {
    otherType = isDependency(otherType)
      ? PropertyAccessType.ConditionalDependency
      : PropertyAccessType.ConditionalAccess;
  }
  currNode.accessType = merge$1(currNode.accessType, otherType);
  for (const [propertyName, otherChild] of otherNode.properties) {
    const currChild = currNode.properties.get(propertyName);
    if (currChild) {
      addSubtree(currChild, otherChild, demoteOtherNode);
    } else {
      if (demoteOtherNode) {
        demoteSubtreeToConditional(otherChild);
      }
      currNode.properties.set(propertyName, otherChild);
    }
  }
}
function addSubtreeIntersection(currProperties, otherProperties) {
  CompilerError.invariant(otherProperties.length > 1, {
    reason:
      "[DeriveMinimalDependencies] Expected otherProperties to be at least 2 elements long.",
    description: null,
    loc: null,
    suggestions: null,
  });
  for (const [propertyName, currNode] of currProperties) {
    const otherNodes = mapNonNull(otherProperties, (properties) => {
      const node = properties.get(propertyName);
      if (node != null && isUnconditional(node.accessType)) {
        return node;
      } else {
        return null;
      }
    });
    if (otherNodes) {
      addSubtreeIntersection(
        currNode.properties,
        otherNodes.map((node) => node.properties),
      );
      const isDep = otherNodes.some((tree) => isDependency(tree.accessType));
      const externalAccessType = isDep
        ? PropertyAccessType.UnconditionalDependency
        : PropertyAccessType.UnconditionalAccess;
      currNode.accessType = merge$1(externalAccessType, currNode.accessType);
    }
  }
}
function printSubtree(node, includeAccesses) {
  const results = [];
  for (const [propertyName, propertyNode] of node.properties) {
    if (includeAccesses || isDependency(propertyNode.accessType)) {
      results.push(`${propertyName} (${propertyNode.accessType})`);
    }
    const propertyResults = printSubtree(propertyNode, includeAccesses);
    results.push(
      ...propertyResults.map((result) => `${propertyName}.${result}`),
    );
  }
  return results;
}
function getOrMakeProperty(node, property) {
  let child = node.properties.get(property);
  if (child == null) {
    child = { properties: new Map(), accessType: MIN_ACCESS_TYPE };
    node.properties.set(property, child);
  }
  return child;
}
function mapNonNull(arr, fn) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const element = fn(arr[i]);
    if (element) {
      result.push(element);
    } else {
      return null;
    }
  }
  return result;
}
var _PoisonState_instances,
  _PoisonState_invalidate,
  _Context_instances,
  _Context_temporariesUsedOutsideScope,
  _Context_declarations,
  _Context_reassignments,
  _Context_dependencies,
  _Context_properties,
  _Context_temporaries,
  _Context_inConditionalWithinScope,
  _Context_depsInCurrentConditional,
  _Context_scopes,
  _Context_getProperty,
  _Context_checkValidDependency,
  _Context_isScopeActive;
function propagateScopeDependencies(fn) {
  const escapingTemporaries = {
    declarations: new Map(),
    usedOutsideDeclaringScope: new Set(),
  };
  visitReactiveFunction(fn, new FindPromotedTemporaries(), escapingTemporaries);
  const context = new Context(escapingTemporaries.usedOutsideDeclaringScope);
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      context.declare(param.identifier, {
        id: makeInstructionId(0),
        scope: empty(),
      });
    } else {
      context.declare(param.place.identifier, {
        id: makeInstructionId(0),
        scope: empty(),
      });
    }
  }
  visitReactiveFunction(
    fn,
    new PropagationVisitor(fn.env.config.enableTreatFunctionDepsAsConditional),
    context,
  );
}
class FindPromotedTemporaries extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  visitScope(scope, state) {
    this.scopes.push(scope.scope.id);
    this.traverseScope(scope, state);
    this.scopes.pop();
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    const scope = this.scopes.at(-1);
    if (instruction.lvalue === null || scope === undefined) {
      return;
    }
    switch (instruction.value.kind) {
      case "LoadLocal":
      case "LoadContext":
      case "PropertyLoad": {
        state.declarations.set(instruction.lvalue.identifier.id, scope);
        break;
      }
    }
  }
  visitPlace(_id, place, state) {
    const declaringScope = state.declarations.get(place.identifier.id);
    if (declaringScope === undefined) {
      return;
    }
    if (this.scopes.indexOf(declaringScope) === -1) {
      state.usedOutsideDeclaringScope.add(place.identifier.id);
    }
  }
}
class PoisonState {
  constructor(poisonedBlocks, poisonedScopes, isPoisoned) {
    _PoisonState_instances.add(this);
    this.poisonedBlocks = new Set();
    this.poisonedScopes = new Set();
    this.isPoisoned = false;
    this.poisonedBlocks = poisonedBlocks;
    this.poisonedScopes = poisonedScopes;
    this.isPoisoned = isPoisoned;
  }
  clone() {
    return new PoisonState(
      new Set(this.poisonedBlocks),
      new Set(this.poisonedScopes),
      this.isPoisoned,
    );
  }
  take(other) {
    const copy = new PoisonState(
      this.poisonedBlocks,
      this.poisonedScopes,
      this.isPoisoned,
    );
    this.poisonedBlocks = other.poisonedBlocks;
    this.poisonedScopes = other.poisonedScopes;
    this.isPoisoned = other.isPoisoned;
    return copy;
  }
  merge(others, currentScope) {
    for (const other of others) {
      for (const id of other.poisonedBlocks) {
        this.poisonedBlocks.add(id);
      }
      for (const id of other.poisonedScopes) {
        this.poisonedScopes.add(id);
      }
    }
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate,
    ).call(this, currentScope);
  }
  addPoisonTarget(target, activeScopes) {
    const currentScope = activeScopes.value;
    if (target == null && currentScope != null) {
      let cursor = activeScopes;
      while (true) {
        const next = cursor.pop();
        if (next.value == null) {
          const poisonedScope = cursor.value.value.id;
          this.poisonedScopes.add(poisonedScope);
          if (
            poisonedScope ===
            (currentScope === null || currentScope === void 0
              ? void 0
              : currentScope.value.id)
          ) {
            this.isPoisoned = true;
          }
          break;
        } else {
          cursor = next;
        }
      }
    } else if (target != null) {
      this.poisonedBlocks.add(target);
      if (
        !this.isPoisoned &&
        (currentScope === null || currentScope === void 0
          ? void 0
          : currentScope.ownBlocks.find((blockId) => blockId === target))
      ) {
        this.isPoisoned = true;
      }
    }
  }
  removeMaybePoisonedScope(id, currentScope) {
    this.poisonedScopes.delete(id);
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate,
    ).call(this, currentScope);
  }
  removeMaybePoisonedBlock(id, currentScope) {
    this.poisonedBlocks.delete(id);
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate,
    ).call(this, currentScope);
  }
}
(_PoisonState_instances = new WeakSet()),
  (_PoisonState_invalidate = function _PoisonState_invalidate(currentScope) {
    if (currentScope != null) {
      if (this.poisonedScopes.has(currentScope.value.id)) {
        this.isPoisoned = true;
        return;
      } else if (
        currentScope.ownBlocks.find((blockId) =>
          this.poisonedBlocks.has(blockId),
        )
      ) {
        this.isPoisoned = true;
        return;
      }
    }
    this.isPoisoned = false;
  });
class Context {
  constructor(temporariesUsedOutsideScope) {
    _Context_instances.add(this);
    _Context_temporariesUsedOutsideScope.set(this, void 0);
    _Context_declarations.set(this, new Map());
    _Context_reassignments.set(this, new Map());
    _Context_dependencies.set(this, new ReactiveScopeDependencyTree());
    _Context_properties.set(this, new Map());
    _Context_temporaries.set(this, new Map());
    _Context_inConditionalWithinScope.set(this, false);
    _Context_depsInCurrentConditional.set(
      this,
      new ReactiveScopeDependencyTree(),
    );
    _Context_scopes.set(this, empty());
    this.poisonState = new PoisonState(new Set(), new Set(), false);
    __classPrivateFieldSet(
      this,
      _Context_temporariesUsedOutsideScope,
      temporariesUsedOutsideScope,
      "f",
    );
  }
  enter(scope, fn) {
    const prevInConditional = __classPrivateFieldGet(
      this,
      _Context_inConditionalWithinScope,
      "f",
    );
    const previousDependencies = __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f",
    );
    const prevDepsInConditional = this.isPoisoned
      ? __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f")
      : null;
    if (prevDepsInConditional != null) {
      __classPrivateFieldSet(
        this,
        _Context_depsInCurrentConditional,
        new ReactiveScopeDependencyTree(),
        "f",
      );
    }
    const scopedDependencies = new ReactiveScopeDependencyTree();
    __classPrivateFieldSet(this, _Context_inConditionalWithinScope, false, "f");
    __classPrivateFieldSet(
      this,
      _Context_dependencies,
      scopedDependencies,
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Context_scopes,
      __classPrivateFieldGet(this, _Context_scopes, "f").push({
        value: scope,
        ownBlocks: empty(),
      }),
      "f",
    );
    this.poisonState.isPoisoned = false;
    fn();
    __classPrivateFieldSet(
      this,
      _Context_scopes,
      __classPrivateFieldGet(this, _Context_scopes, "f").pop(),
      "f",
    );
    this.poisonState.removeMaybePoisonedScope(
      scope.id,
      __classPrivateFieldGet(this, _Context_scopes, "f").value,
    );
    __classPrivateFieldSet(
      this,
      _Context_dependencies,
      previousDependencies,
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Context_inConditionalWithinScope,
      prevInConditional,
      "f",
    );
    const minInnerScopeDependencies =
      scopedDependencies.deriveMinimalDependencies();
    __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f",
    ).addDepsFromInnerScope(
      scopedDependencies,
      __classPrivateFieldGet(this, _Context_inConditionalWithinScope, "f") ||
        this.isPoisoned,
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency,
      ).bind(this),
    );
    if (prevDepsInConditional != null) {
      prevDepsInConditional.addDepsFromInnerScope(
        __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f"),
        true,
        __classPrivateFieldGet(
          this,
          _Context_instances,
          "m",
          _Context_checkValidDependency,
        ).bind(this),
      );
      __classPrivateFieldSet(
        this,
        _Context_depsInCurrentConditional,
        prevDepsInConditional,
        "f",
      );
    }
    return minInnerScopeDependencies;
  }
  isUsedOutsideDeclaringScope(place) {
    return __classPrivateFieldGet(
      this,
      _Context_temporariesUsedOutsideScope,
      "f",
    ).has(place.identifier.id);
  }
  printDeps(includeAccesses = false) {
    return __classPrivateFieldGet(this, _Context_dependencies, "f").printDeps(
      includeAccesses,
    );
  }
  enterConditional(fn) {
    const prevInConditional = __classPrivateFieldGet(
      this,
      _Context_inConditionalWithinScope,
      "f",
    );
    const prevUncondAccessed = __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f",
    );
    __classPrivateFieldSet(this, _Context_inConditionalWithinScope, true, "f");
    __classPrivateFieldSet(
      this,
      _Context_depsInCurrentConditional,
      new ReactiveScopeDependencyTree(),
      "f",
    );
    fn();
    const result = __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Context_inConditionalWithinScope,
      prevInConditional,
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Context_depsInCurrentConditional,
      prevUncondAccessed,
      "f",
    );
    return result;
  }
  promoteDepsFromExhaustiveConditionals(depsInConditionals) {
    __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f",
    ).promoteDepsFromExhaustiveConditionals(depsInConditionals);
    __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f",
    ).promoteDepsFromExhaustiveConditionals(depsInConditionals);
  }
  declare(identifier, decl) {
    if (
      !__classPrivateFieldGet(this, _Context_declarations, "f").has(
        identifier.id,
      )
    ) {
      __classPrivateFieldGet(this, _Context_declarations, "f").set(
        identifier.id,
        decl,
      );
    }
    __classPrivateFieldGet(this, _Context_reassignments, "f").set(
      identifier,
      decl,
    );
  }
  declareTemporary(lvalue, place) {
    __classPrivateFieldGet(this, _Context_temporaries, "f").set(
      lvalue.identifier,
      place,
    );
  }
  resolveTemporary(place) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _Context_temporaries, "f").get(
      place.identifier,
    )) !== null && _a !== void 0
      ? _a
      : place;
  }
  declareProperty(lvalue, object, property) {
    const nextDependency = __classPrivateFieldGet(
      this,
      _Context_instances,
      "m",
      _Context_getProperty,
    ).call(this, object, property, false);
    __classPrivateFieldGet(this, _Context_properties, "f").set(
      lvalue.identifier,
      nextDependency,
    );
  }
  get currentScope() {
    return __classPrivateFieldGet(this, _Context_scopes, "f");
  }
  get isPoisoned() {
    return this.poisonState.isPoisoned;
  }
  visitOperand(place) {
    const resolved = this.resolveTemporary(place);
    let dependency = {
      identifier: resolved.identifier,
      path: [],
      optionalPath: [],
    };
    if (resolved.identifier.name === null) {
      const propertyDependency = __classPrivateFieldGet(
        this,
        _Context_properties,
        "f",
      ).get(resolved.identifier);
      if (propertyDependency !== undefined) {
        dependency = Object.assign({}, propertyDependency);
      }
    }
    this.visitDependency(dependency);
  }
  visitProperty(object, property) {
    const nextDependency = __classPrivateFieldGet(
      this,
      _Context_instances,
      "m",
      _Context_getProperty,
    ).call(this, object, property, false);
    this.visitDependency(nextDependency);
  }
  visitDependency(maybeDependency) {
    const originalDeclaration = __classPrivateFieldGet(
      this,
      _Context_declarations,
      "f",
    ).get(maybeDependency.identifier.id);
    if (
      originalDeclaration !== undefined &&
      originalDeclaration.scope.value !== null
    ) {
      originalDeclaration.scope.each((scope) => {
        if (
          !__classPrivateFieldGet(
            this,
            _Context_instances,
            "m",
            _Context_isScopeActive,
          ).call(this, scope.value)
        ) {
          scope.value.declarations.set(maybeDependency.identifier.id, {
            identifier: maybeDependency.identifier,
            scope: originalDeclaration.scope.value.value,
          });
        }
      });
    }
    if (
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency,
      ).call(this, maybeDependency)
    ) {
      const isPoisoned = this.isPoisoned;
      __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f").add(
        maybeDependency,
        isPoisoned,
      );
      __classPrivateFieldGet(this, _Context_dependencies, "f").add(
        maybeDependency,
        __classPrivateFieldGet(this, _Context_inConditionalWithinScope, "f") ||
          isPoisoned,
      );
    }
  }
  visitReassignment(place) {
    var _a;
    const currentScope =
      (_a = this.currentScope.value) === null || _a === void 0
        ? void 0
        : _a.value;
    if (
      currentScope != null &&
      !Array.from(currentScope.reassignments).some(
        (identifier) => identifier.id === place.identifier.id,
      ) &&
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency,
      ).call(this, { identifier: place.identifier, path: [] })
    ) {
      currentScope.reassignments.add(place.identifier);
    }
  }
  pushLabeledBlock(id) {
    const currentScope = __classPrivateFieldGet(
      this,
      _Context_scopes,
      "f",
    ).value;
    if (currentScope != null) {
      currentScope.ownBlocks = currentScope.ownBlocks.push(id);
    }
  }
  popLabeledBlock(id) {
    const currentScope = __classPrivateFieldGet(
      this,
      _Context_scopes,
      "f",
    ).value;
    if (currentScope != null) {
      const last = currentScope.ownBlocks.value;
      currentScope.ownBlocks = currentScope.ownBlocks.pop();
      CompilerError.invariant(last != null && last === id, {
        reason: "[PropagateScopeDependencies] Misformed block stack",
        loc: GeneratedSource,
      });
    }
    this.poisonState.removeMaybePoisonedBlock(id, currentScope);
  }
}
(_Context_temporariesUsedOutsideScope = new WeakMap()),
  (_Context_declarations = new WeakMap()),
  (_Context_reassignments = new WeakMap()),
  (_Context_dependencies = new WeakMap()),
  (_Context_properties = new WeakMap()),
  (_Context_temporaries = new WeakMap()),
  (_Context_inConditionalWithinScope = new WeakMap()),
  (_Context_depsInCurrentConditional = new WeakMap()),
  (_Context_scopes = new WeakMap()),
  (_Context_instances = new WeakSet()),
  (_Context_getProperty = function _Context_getProperty(
    object,
    property,
    isConditional,
  ) {
    const resolvedObject = this.resolveTemporary(object);
    const resolvedDependency = __classPrivateFieldGet(
      this,
      _Context_properties,
      "f",
    ).get(resolvedObject.identifier);
    let objectDependency;
    if (resolvedDependency === undefined) {
      objectDependency = {
        identifier: resolvedObject.identifier,
        path: [],
        optionalPath: [],
      };
    } else {
      objectDependency = {
        identifier: resolvedDependency.identifier,
        path: [...resolvedDependency.path],
        optionalPath: [...resolvedDependency.optionalPath],
      };
    }
    if (objectDependency.optionalPath.length > 0) {
      objectDependency.optionalPath.push(property);
    } else if (isConditional) {
      objectDependency.optionalPath.push(property);
    } else {
      objectDependency.path.push(property);
    }
    return objectDependency;
  }),
  (_Context_checkValidDependency = function _Context_checkValidDependency(
    maybeDependency,
  ) {
    var _a, _b, _c;
    if (
      isUseRefType(maybeDependency.identifier) &&
      maybeDependency.path.at(0) === "current"
    ) {
      return false;
    }
    if (isRefValueType(maybeDependency.identifier)) {
      return false;
    }
    if (isObjectMethodType(maybeDependency.identifier)) {
      return false;
    }
    const identifier = maybeDependency.identifier;
    const currentDeclaration =
      (_a = __classPrivateFieldGet(this, _Context_reassignments, "f").get(
        identifier,
      )) !== null && _a !== void 0
        ? _a
        : __classPrivateFieldGet(this, _Context_declarations, "f").get(
            identifier.id,
          );
    const currentScope =
      (_b = this.currentScope.value) === null || _b === void 0
        ? void 0
        : _b.value;
    return (
      currentScope != null &&
      currentDeclaration !== undefined &&
      currentDeclaration.id < currentScope.range.start &&
      (currentDeclaration.scope == null ||
        ((_c = currentDeclaration.scope.value) === null || _c === void 0
          ? void 0
          : _c.value) !== currentScope)
    );
  }),
  (_Context_isScopeActive = function _Context_isScopeActive(scope) {
    if (__classPrivateFieldGet(this, _Context_scopes, "f") === null) {
      return false;
    }
    return __classPrivateFieldGet(this, _Context_scopes, "f").find(
      (state) => state.value === scope,
    );
  });
class PropagationVisitor extends ReactiveFunctionVisitor {
  constructor(enableTreatFunctionDepsAsConditional) {
    super();
    this.enableTreatFunctionDepsAsConditional = false;
    this.enableTreatFunctionDepsAsConditional =
      enableTreatFunctionDepsAsConditional;
  }
  visitScope(scope, context) {
    const scopeDependencies = context.enter(scope.scope, () => {
      this.visitBlock(scope.instructions, context);
    });
    scope.scope.dependencies = scopeDependencies;
  }
  visitInstruction(instruction, context) {
    const { id: id, value: value, lvalue: lvalue } = instruction;
    this.visitInstructionValue(context, id, value, lvalue);
    if (lvalue == null) {
      return;
    }
    context.declare(lvalue.identifier, { id: id, scope: context.currentScope });
  }
  visitReactiveValue(context, id, value) {
    switch (value.kind) {
      case "OptionalExpression": {
        const inner = value.value;
        CompilerError.invariant(inner.kind === "SequenceExpression", {
          reason:
            "Expected OptionalExpression value to be a SequenceExpression",
          description: `Found a '${value.kind}'`,
          loc: value.loc,
          suggestions: null,
        });
        for (const instr of inner.instructions) {
          this.visitInstruction(instr, context);
        }
        context.enterConditional(() => {
          this.visitReactiveValue(context, id, inner.value);
        });
        break;
      }
      case "LogicalExpression": {
        this.visitReactiveValue(context, id, value.left);
        context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.right);
        });
        break;
      }
      case "ConditionalExpression": {
        this.visitReactiveValue(context, id, value.test);
        const consequentDeps = context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.consequent);
        });
        const alternateDeps = context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.alternate);
        });
        context.promoteDepsFromExhaustiveConditionals([
          consequentDeps,
          alternateDeps,
        ]);
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, context);
        }
        this.visitInstructionValue(context, id, value.value, null);
        break;
      }
      case "FunctionExpression": {
        if (this.enableTreatFunctionDepsAsConditional) {
          context.enterConditional(() => {
            for (const operand of eachInstructionValueOperand(value)) {
              context.visitOperand(operand);
            }
          });
        } else {
          for (const operand of eachInstructionValueOperand(value)) {
            context.visitOperand(operand);
          }
        }
        break;
      }
      case "ReactiveFunctionValue": {
        CompilerError.invariant(false, {
          reason: `Unexpected ReactiveFunctionValue`,
          loc: value.loc,
          description: null,
          suggestions: null,
        });
      }
      default: {
        for (const operand of eachInstructionValueOperand(value)) {
          context.visitOperand(operand);
        }
      }
    }
  }
  visitInstructionValue(context, id, value, lvalue) {
    if (value.kind === "LoadLocal" && lvalue !== null) {
      if (
        value.place.identifier.name !== null &&
        lvalue.identifier.name === null &&
        !context.isUsedOutsideDeclaringScope(lvalue)
      ) {
        context.declareTemporary(lvalue, value.place);
      } else {
        context.visitOperand(value.place);
      }
    } else if (value.kind === "PropertyLoad") {
      if (lvalue !== null && !context.isUsedOutsideDeclaringScope(lvalue)) {
        context.declareProperty(lvalue, value.object, value.property);
      } else {
        context.visitProperty(value.object, value.property);
      }
    } else if (value.kind === "StoreLocal") {
      context.visitOperand(value.value);
      if (value.lvalue.kind === InstructionKind.Reassign) {
        context.visitReassignment(value.lvalue.place);
      }
      context.declare(value.lvalue.place.identifier, {
        id: id,
        scope: context.currentScope,
      });
    } else if (
      value.kind === "DeclareLocal" ||
      value.kind === "DeclareContext"
    ) {
      context.declare(value.lvalue.place.identifier, {
        id: id,
        scope: context.currentScope,
      });
    } else if (value.kind === "Destructure") {
      context.visitOperand(value.value);
      for (const place of eachPatternOperand(value.lvalue.pattern)) {
        if (value.lvalue.kind === InstructionKind.Reassign) {
          context.visitReassignment(place);
        }
        context.declare(place.identifier, {
          id: id,
          scope: context.currentScope,
        });
      }
    } else {
      this.visitReactiveValue(context, id, value);
    }
  }
  enterTerminal(stmt, context) {
    if (stmt.label != null) {
      context.pushLabeledBlock(stmt.label.id);
    }
    const terminal = stmt.terminal;
    switch (terminal.kind) {
      case "continue":
      case "break": {
        context.poisonState.addPoisonTarget(
          terminal.target,
          context.currentScope,
        );
        break;
      }
      case "throw":
      case "return": {
        context.poisonState.addPoisonTarget(null, context.currentScope);
        break;
      }
    }
  }
  exitTerminal(stmt, context) {
    if (stmt.label != null) {
      context.popLabeledBlock(stmt.label.id);
    }
  }
  visitTerminal(stmt, context) {
    this.enterTerminal(stmt, context);
    const terminal = stmt.terminal;
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        context.visitOperand(terminal.value);
        break;
      }
      case "throw": {
        context.visitOperand(terminal.value);
        break;
      }
      case "for": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        this.visitReactiveValue(context, terminal.id, terminal.test);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
          if (terminal.update !== null) {
            this.visitReactiveValue(context, terminal.id, terminal.update);
          }
        });
        break;
      }
      case "for-of": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "for-in": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, context);
        context.enterConditional(() => {
          this.visitReactiveValue(context, terminal.id, terminal.test);
        });
        break;
      }
      case "while": {
        this.visitReactiveValue(context, terminal.id, terminal.test);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "if": {
        context.visitOperand(terminal.test);
        const { consequent: consequent, alternate: alternate } = terminal;
        const prevPoisonState = context.poisonState.clone();
        const depsInIf = context.enterConditional(() => {
          this.visitBlock(consequent, context);
        });
        if (alternate !== null) {
          const ifPoisonState = context.poisonState.take(prevPoisonState);
          const depsInElse = context.enterConditional(() => {
            this.visitBlock(alternate, context);
          });
          context.poisonState.merge(
            [ifPoisonState],
            context.currentScope.value,
          );
          context.promoteDepsFromExhaustiveConditionals([depsInIf, depsInElse]);
        }
        break;
      }
      case "switch": {
        context.visitOperand(terminal.test);
        const isDefaultOnly =
          terminal.cases.length === 1 && terminal.cases[0].test == null;
        if (isDefaultOnly) {
          const case_ = terminal.cases[0];
          if (case_.block != null) {
            this.visitBlock(case_.block, context);
            break;
          }
        }
        const depsInCases = [];
        let foundDefault = false;
        const prevPoisonState = context.poisonState.clone();
        const mutExPoisonStates = [];
        for (const { test: test, block: block } of terminal.cases) {
          if (test !== null) {
            context.visitOperand(test);
          } else {
            foundDefault = true;
          }
          if (block !== undefined) {
            mutExPoisonStates.push(
              context.poisonState.take(prevPoisonState.clone()),
            );
            depsInCases.push(
              context.enterConditional(() => {
                this.visitBlock(block, context);
              }),
            );
          }
        }
        if (foundDefault) {
          context.promoteDepsFromExhaustiveConditionals(depsInCases);
        }
        context.poisonState.merge(
          mutExPoisonStates,
          context.currentScope.value,
        );
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, context);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, context);
        this.visitBlock(terminal.handler, context);
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind '${terminal.kind}'`,
        );
      }
    }
    this.exitTerminal(stmt, context);
  }
}
function pruneHoistedContexts(fn) {
  const hoistedIdentifiers = new Set();
  visitReactiveFunction(fn, new Visitor$7(), hoistedIdentifiers);
}
let Visitor$7 = class Visitor extends ReactiveFunctionTransform {
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    if (
      instruction.value.kind === "DeclareContext" &&
      instruction.value.lvalue.kind === "HoistedConst"
    ) {
      state.add(instruction.value.lvalue.place.identifier);
      return { kind: "remove" };
    }
    if (
      instruction.value.kind === "StoreContext" &&
      state.has(instruction.value.lvalue.place.identifier)
    ) {
      return {
        kind: "replace",
        value: {
          kind: "instruction",
          instruction: Object.assign(Object.assign({}, instruction), {
            value: Object.assign(Object.assign({}, instruction.value), {
              lvalue: Object.assign(
                Object.assign({}, instruction.value.lvalue),
                { kind: InstructionKind.Const },
              ),
              type: null,
              kind: "StoreLocal",
            }),
          }),
        },
      };
    }
    return { kind: "keep" };
  }
};
function validateMemoizedEffectDependencies(fn) {
  const errors = new CompilerError();
  visitReactiveFunction(fn, new Visitor$6(), errors);
  if (errors.hasErrors()) {
    throw errors;
  }
}
let Visitor$6 = class Visitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = new Set();
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    let areDependenciesMemoized = true;
    for (const dep of scopeBlock.scope.dependencies) {
      if (isUnmemoized$1(dep.identifier, this.scopes)) {
        areDependenciesMemoized = false;
        break;
      }
    }
    if (areDependenciesMemoized) {
      this.scopes.add(scopeBlock.scope.id);
      for (const id of scopeBlock.scope.merged) {
        this.scopes.add(id);
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (
      instruction.value.kind === "CallExpression" &&
      isEffectHook(instruction.value.callee.identifier) &&
      instruction.value.args.length >= 2
    ) {
      const deps = instruction.value.args[1];
      if (
        deps.kind === "Identifier" &&
        (isMutable(instruction, deps) ||
          isUnmemoized$1(deps.identifier, this.scopes))
      ) {
        state.push({
          reason:
            "This effect may trigger an infinite loop: one or more of its dependencies could not be memoized due to a later mutation",
          description: null,
          severity: exports.ErrorSeverity.InvalidReact,
          loc: typeof instruction.loc !== "symbol" ? instruction.loc : null,
          suggestions: null,
        });
      }
    }
  }
};
function isUnmemoized$1(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}
function isEffectHook(identifier) {
  return (
    isUseEffectHookType(identifier) ||
    isUseLayoutEffectHookType(identifier) ||
    isUseInsertionEffectHookType(identifier)
  );
}
var _InferenceState_env, _InferenceState_values, _InferenceState_variables;
const UndefinedValue = {
  kind: "Primitive",
  loc: GeneratedSource,
  value: undefined,
};
function inferReferenceEffects(fn, options = { isFunctionExpression: false }) {
  var _a;
  const initialState = InferenceState.empty(fn.env);
  const value = { kind: "Primitive", loc: fn.loc, value: undefined };
  initialState.initialize(value, {
    kind: exports.ValueKind.Frozen,
    reason: new Set([ValueReason.Other]),
  });
  for (const ref of fn.context) {
    const value = { kind: "ObjectExpression", properties: [], loc: ref.loc };
    initialState.initialize(value, {
      kind: exports.ValueKind.Context,
      reason: new Set([ValueReason.Other]),
    });
    initialState.define(ref, value);
  }
  const paramKind = options.isFunctionExpression
    ? { kind: exports.ValueKind.Mutable, reason: new Set([ValueReason.Other]) }
    : {
        kind: exports.ValueKind.Frozen,
        reason: new Set([ValueReason.ReactiveFunctionArgument]),
      };
  if (fn.fnType === "Component") {
    CompilerError.invariant(fn.params.length <= 2, {
      reason:
        "Expected React component to have not more than two parameters: one for props and for ref",
      description: null,
      loc: fn.loc,
      suggestions: null,
    });
    const [props, ref] = fn.params;
    let value;
    let place;
    if (props) {
      inferParam(props, initialState, paramKind);
    }
    if (ref) {
      if (ref.kind === "Identifier") {
        place = ref;
        value = { kind: "ObjectExpression", properties: [], loc: ref.loc };
      } else {
        place = ref.place;
        value = {
          kind: "ObjectExpression",
          properties: [],
          loc: ref.place.loc,
        };
      }
      initialState.initialize(value, {
        kind: exports.ValueKind.Mutable,
        reason: new Set([ValueReason.Other]),
      });
      initialState.define(place, value);
    }
  } else {
    for (const param of fn.params) {
      inferParam(param, initialState, paramKind);
    }
  }
  const statesByBlock = new Map();
  const queuedStates = new Map();
  function queue(blockId, state) {
    var _a;
    let queuedState = queuedStates.get(blockId);
    if (queuedState != null) {
      state =
        (_a = queuedState.merge(state)) !== null && _a !== void 0 ? _a : state;
      queuedStates.set(blockId, state);
    } else {
      const prevState = statesByBlock.get(blockId);
      const nextState = prevState != null ? prevState.merge(state) : state;
      if (nextState != null) {
        queuedStates.set(blockId, nextState);
      }
    }
  }
  queue(fn.body.entry, initialState);
  const functionEffects = (_a = fn.effects) !== null && _a !== void 0 ? _a : [];
  while (queuedStates.size !== 0) {
    for (const [blockId, block] of fn.body.blocks) {
      const incomingState = queuedStates.get(blockId);
      queuedStates.delete(blockId);
      if (incomingState == null) {
        continue;
      }
      statesByBlock.set(blockId, incomingState);
      const state = incomingState.clone();
      inferBlock(fn.env, functionEffects, state, block);
      for (const nextBlockId of eachTerminalSuccessor(block.terminal)) {
        queue(nextBlockId, state);
      }
    }
  }
  if (!options.isFunctionExpression) {
    functionEffects.forEach((eff) => {
      switch (eff.kind) {
        case "GlobalMutation":
          CompilerError.throw(eff.error);
        default:
          assertExhaustive(
            eff.kind,
            `Unexpected function effect kind '${eff.kind}'`,
          );
      }
    });
  } else {
    fn.effects = functionEffects;
  }
}
class InferenceState {
  constructor(env, values, variables) {
    _InferenceState_env.set(this, void 0);
    _InferenceState_values.set(this, void 0);
    _InferenceState_variables.set(this, void 0);
    __classPrivateFieldSet(this, _InferenceState_env, env, "f");
    __classPrivateFieldSet(this, _InferenceState_values, values, "f");
    __classPrivateFieldSet(this, _InferenceState_variables, variables, "f");
  }
  static empty(env) {
    return new InferenceState(env, new Map(), new Map());
  }
  initialize(value, kind) {
    CompilerError.invariant(value.kind !== "LoadLocal", {
      reason:
        "Expected all top-level identifiers to be defined as variables, not values",
      description: null,
      loc: value.loc,
      suggestions: null,
    });
    __classPrivateFieldGet(this, _InferenceState_values, "f").set(value, kind);
  }
  values(place) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    ).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null,
    });
    return Array.from(values);
  }
  kind(place) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    ).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null,
    });
    let mergedKind = null;
    for (const value of values) {
      const kind = __classPrivateFieldGet(
        this,
        _InferenceState_values,
        "f",
      ).get(value);
      mergedKind =
        mergedKind !== null ? mergeAbstractValues(mergedKind, kind) : kind;
    }
    CompilerError.invariant(mergedKind !== null, {
      reason: `InferReferenceEffects::kind: Expected at least one value`,
      description: `No value found at '${printPlace(place)}'`,
      loc: place.loc,
      suggestions: null,
    });
    return mergedKind;
  }
  alias(place, value) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    ).get(value.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value for identifier to be initialized`,
      description: `${printIdentifier(value.identifier)}`,
      loc: value.loc,
      suggestions: null,
    });
    __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
      place.identifier.id,
      new Set(values),
    );
  }
  define(place, value) {
    CompilerError.invariant(
      __classPrivateFieldGet(this, _InferenceState_values, "f").has(value),
      {
        reason: `Expected value to be initialized at '${printSourceLocation(value.loc)}'`,
        description: null,
        loc: value.loc,
        suggestions: null,
      },
    );
    __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
      place.identifier.id,
      new Set([value]),
    );
  }
  isDefined(place) {
    return __classPrivateFieldGet(this, _InferenceState_variables, "f").has(
      place.identifier.id,
    );
  }
  reference(place, functionEffects, effectKind, reason) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    ).get(place.identifier.id);
    if (values === undefined) {
      CompilerError.invariant(effectKind !== exports.Effect.Store, {
        reason: "[InferReferenceEffects] Unhandled store reference effect",
        description: null,
        loc: place.loc,
        suggestions: null,
      });
      place.effect =
        effectKind === exports.Effect.ConditionallyMutate
          ? exports.Effect.ConditionallyMutate
          : exports.Effect.Read;
      return;
    }
    for (const value of values) {
      if (
        (value.kind === "FunctionExpression" ||
          value.kind === "ObjectMethod") &&
        value.loweredFunc.func.effects != null
      ) {
        functionEffects.push(...value.loweredFunc.func.effects);
      }
    }
    let valueKind = this.kind(place);
    let effect = null;
    switch (effectKind) {
      case exports.Effect.Freeze: {
        if (
          valueKind.kind === exports.ValueKind.Mutable ||
          valueKind.kind === exports.ValueKind.Context ||
          valueKind.kind === exports.ValueKind.MaybeFrozen
        ) {
          const reasonSet = new Set([reason]);
          effect = exports.Effect.Freeze;
          valueKind = { kind: exports.ValueKind.Frozen, reason: reasonSet };
          values.forEach((value) => {
            __classPrivateFieldGet(this, _InferenceState_values, "f").set(
              value,
              { kind: exports.ValueKind.Frozen, reason: reasonSet },
            );
            if (
              __classPrivateFieldGet(this, _InferenceState_env, "f").config
                .enablePreserveExistingMemoizationGuarantees ||
              __classPrivateFieldGet(this, _InferenceState_env, "f").config
                .enableTransitivelyFreezeFunctionExpressions
            ) {
              if (value.kind === "FunctionExpression") {
                for (const operand of eachInstructionValueOperand(value)) {
                  this.reference(
                    operand,
                    functionEffects,
                    exports.Effect.Freeze,
                    ValueReason.Other,
                  );
                }
              }
            }
          });
        } else {
          effect = exports.Effect.Read;
        }
        break;
      }
      case exports.Effect.ConditionallyMutate: {
        if (
          valueKind.kind === exports.ValueKind.Mutable ||
          valueKind.kind === exports.ValueKind.Context
        ) {
          effect = exports.Effect.ConditionallyMutate;
        } else {
          effect = exports.Effect.Read;
        }
        break;
      }
      case exports.Effect.Mutate: {
        if (
          valueKind.kind !== exports.ValueKind.Mutable &&
          valueKind.kind !== exports.ValueKind.Context
        ) {
          let reason = getWriteErrorReason(valueKind);
          functionEffects.push({
            kind: "GlobalMutation",
            error: {
              reason: reason,
              description:
                place.identifier.name !== null
                  ? `Found mutation of ${place.identifier.name}`
                  : null,
              loc: place.loc,
              suggestions: null,
              severity: exports.ErrorSeverity.InvalidReact,
            },
          });
        }
        effect = exports.Effect.Mutate;
        break;
      }
      case exports.Effect.Store: {
        if (
          valueKind.kind !== exports.ValueKind.Mutable &&
          valueKind.kind !== exports.ValueKind.Context
        ) {
          let reason = getWriteErrorReason(valueKind);
          functionEffects.push({
            kind: "GlobalMutation",
            error: {
              reason: reason,
              description:
                place.identifier.name !== null
                  ? `Found mutation of ${place.identifier.name}`
                  : null,
              loc: place.loc,
              suggestions: null,
              severity: exports.ErrorSeverity.InvalidReact,
            },
          });
        }
        effect = isObjectType(place.identifier)
          ? exports.Effect.Store
          : exports.Effect.Mutate;
        break;
      }
      case exports.Effect.Capture: {
        if (
          valueKind.kind === exports.ValueKind.Immutable ||
          valueKind.kind === exports.ValueKind.Frozen ||
          valueKind.kind === exports.ValueKind.MaybeFrozen
        ) {
          effect = exports.Effect.Read;
        } else {
          effect = exports.Effect.Capture;
        }
        break;
      }
      case exports.Effect.Read: {
        effect = exports.Effect.Read;
        break;
      }
      case exports.Effect.Unknown: {
        CompilerError.invariant(false, {
          reason:
            "Unexpected unknown effect, expected to infer a precise effect kind",
          description: null,
          loc: place.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive(
          effectKind,
          `Unexpected reference kind '${effectKind}'`,
        );
      }
    }
    CompilerError.invariant(effect !== null, {
      reason: "Expected effect to be set",
      description: null,
      loc: place.loc,
      suggestions: null,
    });
    place.effect = effect;
  }
  merge(other) {
    let nextValues = null;
    let nextVariables = null;
    for (const [id, thisValue] of __classPrivateFieldGet(
      this,
      _InferenceState_values,
      "f",
    )) {
      const otherValue = __classPrivateFieldGet(
        other,
        _InferenceState_values,
        "f",
      ).get(id);
      if (otherValue !== undefined) {
        const mergedValue = mergeAbstractValues(thisValue, otherValue);
        if (mergedValue !== thisValue) {
          nextValues =
            nextValues !== null && nextValues !== void 0
              ? nextValues
              : new Map(
                  __classPrivateFieldGet(this, _InferenceState_values, "f"),
                );
          nextValues.set(id, mergedValue);
        }
      }
    }
    for (const [id, otherValue] of __classPrivateFieldGet(
      other,
      _InferenceState_values,
      "f",
    )) {
      if (__classPrivateFieldGet(this, _InferenceState_values, "f").has(id)) {
        continue;
      }
      nextValues =
        nextValues !== null && nextValues !== void 0
          ? nextValues
          : new Map(__classPrivateFieldGet(this, _InferenceState_values, "f"));
      nextValues.set(id, otherValue);
    }
    for (const [id, thisValues] of __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    )) {
      const otherValues = __classPrivateFieldGet(
        other,
        _InferenceState_variables,
        "f",
      ).get(id);
      if (otherValues !== undefined) {
        let mergedValues = null;
        for (const otherValue of otherValues) {
          if (!thisValues.has(otherValue)) {
            mergedValues =
              mergedValues !== null && mergedValues !== void 0
                ? mergedValues
                : new Set(thisValues);
            mergedValues.add(otherValue);
          }
        }
        if (mergedValues !== null) {
          nextVariables =
            nextVariables !== null && nextVariables !== void 0
              ? nextVariables
              : new Map(
                  __classPrivateFieldGet(this, _InferenceState_variables, "f"),
                );
          nextVariables.set(id, mergedValues);
        }
      }
    }
    for (const [id, otherValues] of __classPrivateFieldGet(
      other,
      _InferenceState_variables,
      "f",
    )) {
      if (
        __classPrivateFieldGet(this, _InferenceState_variables, "f").has(id)
      ) {
        continue;
      }
      nextVariables =
        nextVariables !== null && nextVariables !== void 0
          ? nextVariables
          : new Map(
              __classPrivateFieldGet(this, _InferenceState_variables, "f"),
            );
      nextVariables.set(id, new Set(otherValues));
    }
    if (nextVariables === null && nextValues === null) {
      return null;
    } else {
      return new InferenceState(
        __classPrivateFieldGet(this, _InferenceState_env, "f"),
        nextValues !== null && nextValues !== void 0
          ? nextValues
          : new Map(__classPrivateFieldGet(this, _InferenceState_values, "f")),
        nextVariables !== null && nextVariables !== void 0
          ? nextVariables
          : new Map(
              __classPrivateFieldGet(this, _InferenceState_variables, "f"),
            ),
      );
    }
  }
  clone() {
    return new InferenceState(
      __classPrivateFieldGet(this, _InferenceState_env, "f"),
      new Map(__classPrivateFieldGet(this, _InferenceState_values, "f")),
      new Map(__classPrivateFieldGet(this, _InferenceState_variables, "f")),
    );
  }
  debug() {
    const result = { values: {}, variables: {} };
    const objects = new Map();
    function identify(value) {
      let id = objects.get(value);
      if (id == null) {
        id = objects.size;
        objects.set(value, id);
      }
      return id;
    }
    for (const [value, kind] of __classPrivateFieldGet(
      this,
      _InferenceState_values,
      "f",
    )) {
      const id = identify(value);
      result.values[id] = { kind: kind, value: printMixedHIR(value) };
    }
    for (const [variable, values] of __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f",
    )) {
      result.variables[variable] = [...values].map(identify);
    }
    return result;
  }
  inferPhi(phi) {
    const values = new Set();
    for (const [_, operand] of phi.operands) {
      const operandValues = __classPrivateFieldGet(
        this,
        _InferenceState_variables,
        "f",
      ).get(operand.id);
      if (operandValues === undefined) continue;
      for (const v of operandValues) {
        values.add(v);
      }
    }
    if (values.size > 0) {
      __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
        phi.id.id,
        values,
      );
    }
  }
}
(_InferenceState_env = new WeakMap()),
  (_InferenceState_values = new WeakMap()),
  (_InferenceState_variables = new WeakMap());
function inferParam(param, initialState, paramKind) {
  let value;
  let place;
  if (param.kind === "Identifier") {
    place = param;
    value = { kind: "Primitive", loc: param.loc, value: undefined };
  } else {
    place = param.place;
    value = { kind: "Primitive", loc: param.place.loc, value: undefined };
  }
  initialState.initialize(value, paramKind);
  initialState.define(place, value);
}
function mergeValues(a, b) {
  if (a === b) {
    return a;
  } else if (
    a === exports.ValueKind.MaybeFrozen ||
    b === exports.ValueKind.MaybeFrozen
  ) {
    return exports.ValueKind.MaybeFrozen;
  } else if (
    a === exports.ValueKind.Mutable ||
    b === exports.ValueKind.Mutable
  ) {
    if (a === exports.ValueKind.Frozen || b === exports.ValueKind.Frozen) {
      return exports.ValueKind.MaybeFrozen;
    } else if (
      a === exports.ValueKind.Context ||
      b === exports.ValueKind.Context
    ) {
      return exports.ValueKind.Context;
    } else {
      return exports.ValueKind.Mutable;
    }
  } else if (
    a === exports.ValueKind.Context ||
    b === exports.ValueKind.Context
  ) {
    if (a === exports.ValueKind.Frozen || b === exports.ValueKind.Frozen) {
      return exports.ValueKind.MaybeFrozen;
    } else {
      return exports.ValueKind.Context;
    }
  } else {
    return exports.ValueKind.Frozen;
  }
}
function isSuperset(a, b) {
  for (const v of b) {
    if (!a.has(v)) {
      return false;
    }
  }
  return true;
}
function mergeAbstractValues(a, b) {
  const kind = mergeValues(a.kind, b.kind);
  if (kind === a.kind && kind === b.kind && isSuperset(a.reason, b.reason)) {
    return a;
  }
  const reason = new Set(a.reason);
  for (const r of b.reason) {
    reason.add(r);
  }
  return { kind: kind, reason: reason };
}
function inferBlock(env, functionEffects, state, block) {
  var _a;
  for (const phi of block.phis) {
    state.inferPhi(phi);
  }
  for (const instr of block.instructions) {
    const instrValue = instr.value;
    let effect = null;
    let lvalueEffect = exports.Effect.ConditionallyMutate;
    let valueKind;
    switch (instrValue.kind) {
      case "BinaryExpression": {
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = { kind: exports.Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "ArrayExpression": {
        valueKind = hasContextRefOperand(state, instrValue)
          ? {
              kind: exports.ValueKind.Context,
              reason: new Set([ValueReason.Other]),
            }
          : {
              kind: exports.ValueKind.Mutable,
              reason: new Set([ValueReason.Other]),
            };
        effect = { kind: exports.Effect.Capture, reason: ValueReason.Other };
        lvalueEffect = exports.Effect.Store;
        break;
      }
      case "NewExpression": {
        valueKind = {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        };
        state.reference(
          instrValue.callee,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        for (const operand of eachCallArgument(instrValue.args)) {
          state.reference(
            operand,
            functionEffects,
            exports.Effect.ConditionallyMutate,
            ValueReason.Other,
          );
        }
        state.initialize(instrValue, valueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = lvalueEffect;
        continue;
      }
      case "ObjectExpression": {
        valueKind = hasContextRefOperand(state, instrValue)
          ? {
              kind: exports.ValueKind.Context,
              reason: new Set([ValueReason.Other]),
            }
          : {
              kind: exports.ValueKind.Mutable,
              reason: new Set([ValueReason.Other]),
            };
        for (const property of instrValue.properties) {
          switch (property.kind) {
            case "ObjectProperty": {
              if (property.key.kind === "computed") {
                state.reference(
                  property.key.name,
                  functionEffects,
                  exports.Effect.Freeze,
                  ValueReason.Other,
                );
              }
              state.reference(
                property.place,
                functionEffects,
                exports.Effect.Capture,
                ValueReason.Other,
              );
              break;
            }
            case "Spread": {
              state.reference(
                property.place,
                functionEffects,
                exports.Effect.Capture,
                ValueReason.Other,
              );
              break;
            }
            default: {
              assertExhaustive(
                property,
                `Unexpected property kind '${property.kind}'`,
              );
            }
          }
        }
        state.initialize(instrValue, valueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "UnaryExpression": {
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = { kind: exports.Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "UnsupportedNode": {
        valueKind = {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        };
        break;
      }
      case "JsxExpression": {
        valueKind = {
          kind: exports.ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
        };
        effect = {
          kind: exports.Effect.Freeze,
          reason: ValueReason.JsxCaptured,
        };
        break;
      }
      case "JsxFragment": {
        valueKind = {
          kind: exports.ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
        };
        effect = { kind: exports.Effect.Freeze, reason: ValueReason.Other };
        break;
      }
      case "TaggedTemplateExpression": {
        valueKind = {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = {
          kind: exports.Effect.ConditionallyMutate,
          reason: ValueReason.Other,
        };
        break;
      }
      case "TemplateLiteral": {
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = { kind: exports.Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "RegExpLiteral": {
        valueKind = {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = {
          kind: exports.Effect.ConditionallyMutate,
          reason: ValueReason.Other,
        };
        break;
      }
      case "LoadGlobal":
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Global]),
        };
        break;
      case "Debugger":
      case "JSXText":
      case "Primitive": {
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        break;
      }
      case "ObjectMethod":
      case "FunctionExpression": {
        let hasMutableOperand = false;
        for (const operand of eachInstructionOperand(instr)) {
          state.reference(
            operand,
            functionEffects,
            operand.effect === exports.Effect.Unknown
              ? exports.Effect.Read
              : operand.effect,
            ValueReason.Other,
          );
          hasMutableOperand ||
            (hasMutableOperand = isMutableEffect(operand.effect, operand.loc));
        }
        state.initialize(instrValue, {
          kind: hasMutableOperand
            ? exports.ValueKind.Mutable
            : exports.ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
        });
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "CallExpression": {
        const signature = getFunctionCallSignature(
          env,
          instrValue.callee.identifier.type,
        );
        const effects =
          signature !== null ? getFunctionEffects(instrValue, signature) : null;
        const returnValueKind =
          signature !== null
            ? {
                kind: signature.returnValueKind,
                reason: new Set([
                  (_a = signature.returnValueReason) !== null && _a !== void 0
                    ? _a
                    : ValueReason.KnownReturnSignature,
                ]),
              }
            : {
                kind: exports.ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
              };
        let hasCaptureArgument = false;
        let isUseEffect = isEffectHook(instrValue.callee.identifier);
        for (let i = 0; i < instrValue.args.length; i++) {
          const argumentEffects = [];
          const arg = instrValue.args[i];
          const place = arg.kind === "Identifier" ? arg : arg.place;
          if (effects !== null) {
            state.reference(
              place,
              argumentEffects,
              effects[i],
              ValueReason.Other,
            );
          } else {
            state.reference(
              place,
              argumentEffects,
              exports.Effect.ConditionallyMutate,
              ValueReason.Other,
            );
          }
          functionEffects.push(
            ...argumentEffects.filter(
              (argEffect) =>
                !isUseEffect || i !== 0 || argEffect.kind !== "GlobalMutation",
            ),
          );
          hasCaptureArgument ||
            (hasCaptureArgument = place.effect === exports.Effect.Capture);
        }
        if (signature !== null) {
          state.reference(
            instrValue.callee,
            functionEffects,
            signature.calleeEffect,
            ValueReason.Other,
          );
        } else {
          state.reference(
            instrValue.callee,
            functionEffects,
            exports.Effect.ConditionallyMutate,
            ValueReason.Other,
          );
        }
        hasCaptureArgument ||
          (hasCaptureArgument =
            instrValue.callee.effect === exports.Effect.Capture);
        state.initialize(instrValue, returnValueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = hasCaptureArgument
          ? exports.Effect.Store
          : exports.Effect.ConditionallyMutate;
        continue;
      }
      case "MethodCall": {
        CompilerError.invariant(state.isDefined(instrValue.receiver), {
          reason:
            "[InferReferenceEffects] Internal error: receiver of PropertyCall should have been defined by corresponding PropertyLoad",
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        });
        state.reference(
          instrValue.property,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        const signature = getFunctionCallSignature(
          env,
          instrValue.property.identifier.type,
        );
        const returnValueKind =
          signature !== null
            ? {
                kind: signature.returnValueKind,
                reason: new Set([ValueReason.Other]),
              }
            : {
                kind: exports.ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
              };
        if (
          signature !== null &&
          signature.mutableOnlyIfOperandsAreMutable &&
          areArgumentsImmutableAndNonMutating(state, instrValue.args)
        ) {
          for (const arg of instrValue.args) {
            const place = arg.kind === "Identifier" ? arg : arg.place;
            state.reference(
              place,
              functionEffects,
              exports.Effect.Read,
              ValueReason.Other,
            );
          }
          state.reference(
            instrValue.receiver,
            functionEffects,
            exports.Effect.Capture,
            ValueReason.Other,
          );
          state.initialize(instrValue, returnValueKind);
          state.define(instr.lvalue, instrValue);
          instr.lvalue.effect =
            instrValue.receiver.effect === exports.Effect.Capture
              ? exports.Effect.Store
              : exports.Effect.ConditionallyMutate;
          continue;
        }
        const effects =
          signature !== null ? getFunctionEffects(instrValue, signature) : null;
        let hasCaptureArgument = false;
        let isUseEffect = isEffectHook(instrValue.property.identifier);
        for (let i = 0; i < instrValue.args.length; i++) {
          const argumentEffects = [];
          const arg = instrValue.args[i];
          const place = arg.kind === "Identifier" ? arg : arg.place;
          if (effects !== null) {
            state.reference(
              place,
              argumentEffects,
              effects[i],
              ValueReason.Other,
            );
          } else {
            state.reference(
              place,
              argumentEffects,
              exports.Effect.ConditionallyMutate,
              ValueReason.Other,
            );
          }
          functionEffects.push(
            ...argumentEffects.filter(
              (argEffect) =>
                !isUseEffect || i !== 0 || argEffect.kind !== "GlobalMutation",
            ),
          );
          hasCaptureArgument ||
            (hasCaptureArgument = place.effect === exports.Effect.Capture);
        }
        if (signature !== null) {
          state.reference(
            instrValue.receiver,
            functionEffects,
            signature.calleeEffect,
            ValueReason.Other,
          );
        } else {
          state.reference(
            instrValue.receiver,
            functionEffects,
            exports.Effect.ConditionallyMutate,
            ValueReason.Other,
          );
        }
        hasCaptureArgument ||
          (hasCaptureArgument =
            instrValue.receiver.effect === exports.Effect.Capture);
        state.initialize(instrValue, returnValueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = hasCaptureArgument
          ? exports.Effect.Store
          : exports.Effect.ConditionallyMutate;
        continue;
      }
      case "PropertyStore": {
        const effect =
          state.kind(instrValue.object).kind === exports.ValueKind.Context
            ? exports.Effect.ConditionallyMutate
            : exports.Effect.Capture;
        state.reference(
          instrValue.value,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        state.reference(
          instrValue.object,
          functionEffects,
          exports.Effect.Store,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "PropertyDelete": {
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        effect = { kind: exports.Effect.Mutate, reason: ValueReason.Other };
        break;
      }
      case "PropertyLoad": {
        state.reference(
          instrValue.object,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.initialize(instrValue, state.kind(instrValue.object));
        state.define(lvalue, instrValue);
        continue;
      }
      case "ComputedStore": {
        const effect =
          state.kind(instrValue.object).kind === exports.ValueKind.Context
            ? exports.Effect.ConditionallyMutate
            : exports.Effect.Capture;
        state.reference(
          instrValue.value,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        state.reference(
          instrValue.property,
          functionEffects,
          exports.Effect.Capture,
          ValueReason.Other,
        );
        state.reference(
          instrValue.object,
          functionEffects,
          exports.Effect.Store,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "ComputedDelete": {
        state.reference(
          instrValue.object,
          functionEffects,
          exports.Effect.Mutate,
          ValueReason.Other,
        );
        state.reference(
          instrValue.property,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        state.initialize(instrValue, {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        });
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = exports.Effect.Mutate;
        continue;
      }
      case "ComputedLoad": {
        state.reference(
          instrValue.object,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        state.reference(
          instrValue.property,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.initialize(instrValue, state.kind(instrValue.object));
        state.define(lvalue, instrValue);
        continue;
      }
      case "Await": {
        state.initialize(instrValue, state.kind(instrValue.value));
        state.reference(
          instrValue.value,
          functionEffects,
          exports.Effect.ConditionallyMutate,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.value);
        continue;
      }
      case "TypeCastExpression": {
        state.initialize(instrValue, state.kind(instrValue.value));
        state.reference(
          instrValue.value,
          functionEffects,
          exports.Effect.Read,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.value);
        continue;
      }
      case "StartMemoize":
      case "FinishMemoize": {
        for (const val of eachInstructionValueOperand(instrValue)) {
          if (env.config.enablePreserveExistingMemoizationGuarantees) {
            state.reference(
              val,
              functionEffects,
              exports.Effect.Freeze,
              ValueReason.Other,
            );
          } else {
            state.reference(
              val,
              functionEffects,
              exports.Effect.Read,
              ValueReason.Other,
            );
          }
        }
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.initialize(instrValue, {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        });
        state.define(lvalue, instrValue);
        continue;
      }
      case "LoadLocal": {
        const lvalue = instr.lvalue;
        const effect =
          state.isDefined(lvalue) &&
          state.kind(lvalue).kind === exports.ValueKind.Context
            ? exports.Effect.ConditionallyMutate
            : exports.Effect.Capture;
        state.reference(
          instrValue.place,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        lvalue.effect = exports.Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.place);
        continue;
      }
      case "LoadContext": {
        state.reference(
          instrValue.place,
          functionEffects,
          exports.Effect.Capture,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        lvalue.effect = exports.Effect.ConditionallyMutate;
        const valueKind = state.kind(instrValue.place);
        CompilerError.invariant(
          valueKind.kind === exports.ValueKind.Mutable ||
            valueKind.kind === exports.ValueKind.Context,
          {
            reason:
              "[InferReferenceEffects] Context variables are always mutable.",
            description: null,
            loc: instrValue.loc,
            suggestions: null,
          },
        );
        state.initialize(instrValue, valueKind);
        state.define(lvalue, instrValue);
        continue;
      }
      case "DeclareLocal": {
        const value = UndefinedValue;
        state.initialize(
          value,
          instrValue.lvalue.kind === InstructionKind.Catch
            ? {
                kind: exports.ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
              }
            : {
                kind: exports.ValueKind.Immutable,
                reason: new Set([ValueReason.Other]),
              },
        );
        state.define(instrValue.lvalue.place, value);
        continue;
      }
      case "DeclareContext": {
        state.initialize(instrValue, {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        });
        state.define(instrValue.lvalue.place, instrValue);
        continue;
      }
      case "PostfixUpdate":
      case "PrefixUpdate": {
        const effect =
          state.isDefined(instrValue.lvalue) &&
          state.kind(instrValue.lvalue).kind === exports.ValueKind.Context
            ? exports.Effect.ConditionallyMutate
            : exports.Effect.Capture;
        state.reference(
          instrValue.value,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        state.alias(instrValue.lvalue, instrValue.value);
        instrValue.lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "StoreLocal": {
        const effect =
          state.isDefined(instrValue.lvalue.place) &&
          state.kind(instrValue.lvalue.place).kind === exports.ValueKind.Context
            ? exports.Effect.ConditionallyMutate
            : exports.Effect.Capture;
        state.reference(
          instrValue.value,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        state.alias(instrValue.lvalue.place, instrValue.value);
        instrValue.lvalue.place.effect = exports.Effect.Store;
        continue;
      }
      case "StoreContext": {
        state.reference(
          instrValue.value,
          functionEffects,
          exports.Effect.ConditionallyMutate,
          ValueReason.Other,
        );
        state.reference(
          instrValue.lvalue.place,
          functionEffects,
          exports.Effect.Mutate,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        continue;
      }
      case "Destructure": {
        let effect = exports.Effect.Capture;
        for (const place of eachPatternOperand(instrValue.lvalue.pattern)) {
          if (
            state.isDefined(place) &&
            state.kind(place).kind === exports.ValueKind.Context
          ) {
            effect = exports.Effect.ConditionallyMutate;
            break;
          }
        }
        state.reference(
          instrValue.value,
          functionEffects,
          effect,
          ValueReason.Other,
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = exports.Effect.Store;
        for (const place of eachPatternOperand(instrValue.lvalue.pattern)) {
          state.alias(place, instrValue.value);
          place.effect = exports.Effect.Store;
        }
        continue;
      }
      case "NextIterableOf": {
        effect = { kind: exports.Effect.Capture, reason: ValueReason.Other };
        lvalueEffect = exports.Effect.Store;
        valueKind = {
          kind: exports.ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
        };
        break;
      }
      case "NextPropertyOf": {
        effect = { kind: exports.Effect.Read, reason: ValueReason.Other };
        lvalueEffect = exports.Effect.Store;
        valueKind = {
          kind: exports.ValueKind.Immutable,
          reason: new Set([ValueReason.Other]),
        };
        break;
      }
      default: {
        assertExhaustive(instrValue, "Unexpected instruction kind");
      }
    }
    for (const operand of eachInstructionOperand(instr)) {
      CompilerError.invariant(effect != null, {
        reason: `effectKind must be set for instruction value \`${instrValue.kind}\``,
        description: null,
        loc: instrValue.loc,
        suggestions: null,
      });
      state.reference(operand, functionEffects, effect.kind, effect.reason);
    }
    state.initialize(instrValue, valueKind);
    state.define(instr.lvalue, instrValue);
    instr.lvalue.effect = lvalueEffect;
  }
  for (const operand of eachTerminalOperand(block.terminal)) {
    let effect;
    if (block.terminal.kind === "return" || block.terminal.kind === "throw") {
      if (
        state.isDefined(operand) &&
        state.kind(operand).kind === exports.ValueKind.Context
      ) {
        effect = exports.Effect.ConditionallyMutate;
      } else {
        effect = exports.Effect.Freeze;
      }
    } else {
      effect = exports.Effect.Read;
    }
    state.reference(operand, functionEffects, effect, ValueReason.Other);
  }
}
function hasContextRefOperand(state, instrValue) {
  for (const place of eachInstructionValueOperand(instrValue)) {
    if (
      state.isDefined(place) &&
      state.kind(place).kind === exports.ValueKind.Context
    ) {
      return true;
    }
  }
  return false;
}
function getFunctionCallSignature(env, type) {
  if (type.kind !== "Function") {
    return null;
  }
  return env.getFunctionSignature(type);
}
function getFunctionEffects(fn, sig) {
  const results = [];
  for (let i = 0; i < fn.args.length; i++) {
    const arg = fn.args[i];
    if (i < sig.positionalParams.length) {
      if (arg.kind === "Identifier") {
        results.push(sig.positionalParams[i]);
      } else {
        return null;
      }
    } else if (sig.restParam !== null) {
      results.push(sig.restParam);
    } else {
      return null;
    }
  }
  return results;
}
function areArgumentsImmutableAndNonMutating(state, args) {
  for (const arg of args) {
    const place = arg.kind === "Identifier" ? arg : arg.place;
    const kind = state.kind(place).kind;
    switch (kind) {
      case exports.ValueKind.Immutable:
      case exports.ValueKind.Frozen: {
        break;
      }
      default: {
        return false;
      }
    }
    const values = state.values(place);
    for (const value of values) {
      if (
        value.kind === "FunctionExpression" &&
        value.loweredFunc.func.params.some((param) => {
          const place = param.kind === "Identifier" ? param : param.place;
          const range = place.identifier.mutableRange;
          return range.end > range.start + 1;
        })
      ) {
        return false;
      }
    }
  }
  return true;
}
function getWriteErrorReason(abstractValue) {
  if (abstractValue.reason.has(ValueReason.Global)) {
    return "Writing to a variable defined outside a component or hook is not allowed. Consider using an effect.";
  } else if (abstractValue.reason.has(ValueReason.JsxCaptured)) {
    return "Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX.";
  } else if (abstractValue.reason.has(ValueReason.Context)) {
    return `Mutating a value returned from 'useContext()', which should not be mutated.`;
  } else if (abstractValue.reason.has(ValueReason.KnownReturnSignature)) {
    return "Mutating a value returned from a function that should not be mutated.";
  } else if (abstractValue.reason.has(ValueReason.ReactiveFunctionArgument)) {
    return "Mutating props or hook arguments is not allowed. Consider using a local variable instead.";
  } else if (abstractValue.reason.has(ValueReason.State)) {
    return "Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead.";
  } else {
    return "This mutates a variable that React considers immutable.";
  }
}
function pruneNonEscapingScopes(fn) {
  const state = new State$1(fn.env);
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      state.declare(param.identifier.id);
    } else {
      state.declare(param.place.identifier.id);
    }
  }
  visitReactiveFunction(fn, new CollectDependenciesVisitor(fn.env), state);
  const memoized = computeMemoizedIdentifiers(state);
  visitReactiveFunction(fn, new PruneScopesTransform(), memoized);
}
var MemoizationLevel;
(function (MemoizationLevel) {
  MemoizationLevel["Memoized"] = "Memoized";
  MemoizationLevel["Conditional"] = "Conditional";
  MemoizationLevel["Unmemoized"] = "Unmemoized";
  MemoizationLevel["Never"] = "Never";
})(MemoizationLevel || (MemoizationLevel = {}));
function joinAliases(kind1, kind2) {
  if (
    kind1 === MemoizationLevel.Memoized ||
    kind2 === MemoizationLevel.Memoized
  ) {
    return MemoizationLevel.Memoized;
  } else if (
    kind1 === MemoizationLevel.Conditional ||
    kind2 === MemoizationLevel.Conditional
  ) {
    return MemoizationLevel.Conditional;
  } else if (
    kind1 === MemoizationLevel.Unmemoized ||
    kind2 === MemoizationLevel.Unmemoized
  ) {
    return MemoizationLevel.Unmemoized;
  } else {
    return MemoizationLevel.Never;
  }
}
let State$1 = class State {
  constructor(env) {
    this.definitions = new Map();
    this.identifiers = new Map();
    this.scopes = new Map();
    this.escapingValues = new Set();
    this.env = env;
  }
  declare(id) {
    this.identifiers.set(id, {
      level: MemoizationLevel.Never,
      memoized: false,
      dependencies: new Set(),
      scopes: new Set(),
      seen: false,
    });
  }
  visitOperand(id, place, identifier) {
    const scope = getPlaceScope(id, place);
    if (scope !== null) {
      let node = this.scopes.get(scope.id);
      if (node === undefined) {
        node = {
          dependencies: [...scope.dependencies].map((dep) => dep.identifier.id),
          seen: false,
        };
        this.scopes.set(scope.id, node);
      }
      const identifierNode = this.identifiers.get(identifier);
      CompilerError.invariant(identifierNode !== undefined, {
        reason: "Expected identifier to be initialized",
        description: null,
        loc: place.loc,
        suggestions: null,
      });
      identifierNode.scopes.add(scope.id);
    }
  }
};
function computeMemoizedIdentifiers(state) {
  const memoized = new Set();
  function visit(id, forceMemoize = false) {
    const node = state.identifiers.get(id);
    CompilerError.invariant(node !== undefined, {
      reason: `Expected a node for all identifiers, none found for '${id}'`,
      description: null,
      loc: null,
      suggestions: null,
    });
    if (node.seen) {
      return node.memoized;
    }
    node.seen = true;
    node.memoized = false;
    let hasMemoizedDependency = false;
    for (const dep of node.dependencies) {
      const isDepMemoized = visit(dep);
      hasMemoizedDependency || (hasMemoizedDependency = isDepMemoized);
    }
    if (
      node.level === MemoizationLevel.Memoized ||
      (node.level === MemoizationLevel.Conditional &&
        (hasMemoizedDependency || forceMemoize)) ||
      (node.level === MemoizationLevel.Unmemoized && forceMemoize)
    ) {
      node.memoized = true;
      memoized.add(id);
      for (const scope of node.scopes) {
        forceMemoizeScopeDependencies(scope);
      }
    }
    return node.memoized;
  }
  function forceMemoizeScopeDependencies(id) {
    const node = state.scopes.get(id);
    CompilerError.invariant(node !== undefined, {
      reason: "Expected a node for all scopes",
      description: null,
      loc: null,
      suggestions: null,
    });
    if (node.seen) {
      return;
    }
    node.seen = true;
    for (const dep of node.dependencies) {
      visit(dep, true);
    }
    return;
  }
  for (const value of state.escapingValues) {
    visit(value);
  }
  return memoized;
}
function computeMemoizationInputs(env, value, lvalue, options) {
  switch (value.kind) {
    case "ConditionalExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [
          ...computeMemoizationInputs(env, value.consequent, null, options)
            .rvalues,
          ...computeMemoizationInputs(env, value.alternate, null, options)
            .rvalues,
        ],
      };
    }
    case "LogicalExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [
          ...computeMemoizationInputs(env, value.left, null, options).rvalues,
          ...computeMemoizationInputs(env, value.right, null, options).rvalues,
        ],
      };
    }
    case "SequenceExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: computeMemoizationInputs(env, value.value, null, options)
          .rvalues,
      };
    }
    case "JsxExpression": {
      const operands = [];
      if (value.tag.kind === "Identifier") {
        operands.push(value.tag);
      }
      for (const prop of value.props) {
        if (prop.kind === "JsxAttribute") {
          operands.push(prop.place);
        } else {
          operands.push(prop.argument);
        }
      }
      if (value.children !== null) {
        for (const child of value.children) {
          operands.push(child);
        }
      }
      const level = options.memoizeJsxElements
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Unmemoized;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: operands,
      };
    }
    case "JsxFragment": {
      const level = options.memoizeJsxElements
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Unmemoized;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: value.children,
      };
    }
    case "NextPropertyOf":
    case "StartMemoize":
    case "FinishMemoize":
    case "Debugger":
    case "ComputedDelete":
    case "PropertyDelete":
    case "LoadGlobal":
    case "TemplateLiteral":
    case "Primitive":
    case "JSXText":
    case "BinaryExpression":
    case "UnaryExpression": {
      const level = options.forceMemoizePrimitives
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Never;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: [],
      };
    }
    case "Await":
    case "TypeCastExpression":
    case "NextIterableOf": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.value],
      };
    }
    case "LoadLocal": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.place],
      };
    }
    case "LoadContext": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.place],
      };
    }
    case "DeclareContext": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Memoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
      }
      return { lvalues: lvalues, rvalues: [] };
    }
    case "DeclareLocal": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Unmemoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
      }
      return { lvalues: lvalues, rvalues: [] };
    }
    case "PrefixUpdate":
    case "PostfixUpdate": {
      const lvalues = [
        { place: value.lvalue, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "StoreLocal": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "StoreContext": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Memoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "Destructure": {
      const lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      lvalues.push(...computePatternLValues(value.lvalue.pattern));
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "ComputedLoad":
    case "PropertyLoad": {
      const level = options.forceMemoizePrimitives
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Conditional;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: [value.object],
      };
    }
    case "ComputedStore": {
      const lvalues = [
        { place: value.object, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "OptionalExpression": {
      const lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return {
        lvalues: lvalues,
        rvalues: [
          ...computeMemoizationInputs(env, value.value, null, options).rvalues,
        ],
      };
    }
    case "CallExpression": {
      const signature = getFunctionCallSignature(
        env,
        value.callee.identifier.type,
      );
      const operands = [...eachReactiveValueOperand(value)];
      let lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      if (
        (signature === null || signature === void 0
          ? void 0
          : signature.noAlias) === true
      ) {
        return { lvalues: lvalues, rvalues: [] };
      }
      lvalues.push(
        ...operands
          .filter((operand) => isMutableEffect(operand.effect, operand.loc))
          .map((place) => ({ place: place, level: MemoizationLevel.Memoized })),
      );
      return { lvalues: lvalues, rvalues: operands };
    }
    case "MethodCall": {
      const signature = getFunctionCallSignature(
        env,
        value.property.identifier.type,
      );
      const operands = [...eachReactiveValueOperand(value)];
      let lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      if (
        (signature === null || signature === void 0
          ? void 0
          : signature.noAlias) === true
      ) {
        return { lvalues: lvalues, rvalues: [] };
      }
      lvalues.push(
        ...operands
          .filter((operand) => isMutableEffect(operand.effect, operand.loc))
          .map((place) => ({ place: place, level: MemoizationLevel.Memoized })),
      );
      return { lvalues: lvalues, rvalues: operands };
    }
    case "RegExpLiteral":
    case "ObjectMethod":
    case "FunctionExpression":
    case "TaggedTemplateExpression":
    case "ArrayExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "PropertyStore": {
      const operands = [...eachReactiveValueOperand(value)];
      const lvalues = operands
        .filter((operand) => isMutableEffect(operand.effect, operand.loc))
        .map((place) => ({ place: place, level: MemoizationLevel.Memoized }));
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      return { lvalues: lvalues, rvalues: operands };
    }
    case "ReactiveFunctionValue": {
      CompilerError.invariant(false, {
        reason: `Unexpected ReactiveFunctionValue node`,
        description: null,
        loc: value.loc,
        suggestions: null,
      });
    }
    case "UnsupportedNode": {
      CompilerError.invariant(false, {
        reason: `Unexpected unsupported node`,
        description: null,
        loc: value.loc,
        suggestions: null,
      });
    }
    default: {
      assertExhaustive(value, `Unexpected value kind '${value.kind}'`);
    }
  }
}
function computePatternLValues(pattern) {
  const lvalues = [];
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          lvalues.push({ place: item, level: MemoizationLevel.Conditional });
        } else if (item.kind === "Spread") {
          lvalues.push({ place: item.place, level: MemoizationLevel.Memoized });
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          lvalues.push({
            place: property.place,
            level: MemoizationLevel.Conditional,
          });
        } else {
          lvalues.push({
            place: property.place,
            level: MemoizationLevel.Memoized,
          });
        }
      }
      break;
    }
    default: {
      assertExhaustive(pattern, `Unexpected pattern kind '${pattern.kind}'`);
    }
  }
  return lvalues;
}
class CollectDependenciesVisitor extends ReactiveFunctionVisitor {
  constructor(env) {
    super();
    this.env = env;
    this.options = {
      memoizeJsxElements: !this.env.config.enableForest,
      forceMemoizePrimitives: this.env.config.enableForest,
    };
  }
  visitInstruction(instruction, state) {
    var _a, _b, _c;
    this.traverseInstruction(instruction, state);
    const aliasing = computeMemoizationInputs(
      this.env,
      instruction.value,
      instruction.lvalue,
      this.options,
    );
    for (const operand of aliasing.rvalues) {
      const operandId =
        (_a = state.definitions.get(operand.identifier.id)) !== null &&
        _a !== void 0
          ? _a
          : operand.identifier.id;
      state.visitOperand(instruction.id, operand, operandId);
    }
    for (const { place: lvalue, level: level } of aliasing.lvalues) {
      const lvalueId =
        (_b = state.definitions.get(lvalue.identifier.id)) !== null &&
        _b !== void 0
          ? _b
          : lvalue.identifier.id;
      let node = state.identifiers.get(lvalueId);
      if (node === undefined) {
        node = {
          level: MemoizationLevel.Never,
          memoized: false,
          dependencies: new Set(),
          scopes: new Set(),
          seen: false,
        };
        state.identifiers.set(lvalueId, node);
      }
      node.level = joinAliases(node.level, level);
      for (const operand of aliasing.rvalues) {
        const operandId =
          (_c = state.definitions.get(operand.identifier.id)) !== null &&
          _c !== void 0
            ? _c
            : operand.identifier.id;
        if (operandId === lvalueId) {
          continue;
        }
        node.dependencies.add(operandId);
      }
      state.visitOperand(instruction.id, lvalue, lvalueId);
    }
    if (instruction.value.kind === "LoadLocal" && instruction.lvalue !== null) {
      state.definitions.set(
        instruction.lvalue.identifier.id,
        instruction.value.place.identifier.id,
      );
    } else if (instruction.value.kind === "CallExpression") {
      const callee = instruction.value.callee;
      if (getHookKind(state.env, callee.identifier) != null) {
        const signature = getFunctionCallSignature(
          this.env,
          instruction.value.callee.identifier.type,
        );
        if (signature && signature.noAlias === true) {
          return;
        }
        for (const operand of instruction.value.args) {
          const place = operand.kind === "Spread" ? operand.place : operand;
          state.escapingValues.add(place.identifier.id);
        }
      }
    }
  }
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    if (stmt.terminal.kind === "return") {
      state.escapingValues.add(stmt.terminal.value.identifier.id);
    }
  }
}
class PruneScopesTransform extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.prunedScopes = new Set();
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, state);
    if (
      scopeBlock.scope.declarations.size === 0 &&
      scopeBlock.scope.reassignments.size === 0
    ) {
      return { kind: "keep" };
    }
    const hasMemoizedOutput =
      Array.from(scopeBlock.scope.declarations.keys()).some((id) =>
        state.has(id),
      ) ||
      Array.from(scopeBlock.scope.reassignments).some((identifier) =>
        state.has(identifier.id),
      );
    if (hasMemoizedOutput) {
      return { kind: "keep" };
    } else {
      this.prunedScopes.add(scopeBlock.scope.id);
      return { kind: "replace-many", value: scopeBlock.instructions };
    }
  }
  transformInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (instruction.value.kind === "FinishMemoize") {
      const identifier = instruction.value.decl.identifier;
      if (
        identifier.scope !== null &&
        this.prunedScopes.has(identifier.scope.id)
      ) {
        instruction.value.pruned = true;
      }
    }
    return { kind: "keep" };
  }
}
let Visitor$5 = class Visitor extends ReactiveFunctionVisitor {
  visitLValue(id, lvalue, state) {
    this.visitPlace(id, lvalue, state);
  }
  visitPlace(_id, place, state) {
    if (place.reactive) {
      state.add(place.identifier.id);
    }
  }
};
function collectReactiveIdentifiers(fn) {
  const visitor = new Visitor$5();
  const state = new Set();
  visitReactiveFunction(fn, visitor, state);
  return state;
}
function pruneNonReactiveDependencies(fn) {
  const reactiveIdentifiers = collectReactiveIdentifiers(fn);
  visitReactiveFunction(fn, new Visitor$4(), reactiveIdentifiers);
}
let Visitor$4 = class Visitor extends ReactiveFunctionVisitor {
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    const { lvalue: lvalue, value: value } = instruction;
    switch (value.kind) {
      case "LoadLocal": {
        if (lvalue !== null && state.has(value.place.identifier.id)) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "StoreLocal": {
        if (state.has(value.value.identifier.id)) {
          state.add(value.lvalue.place.identifier.id);
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "Destructure": {
        if (state.has(value.value.identifier.id)) {
          for (const lvalue of eachPatternOperand(value.lvalue.pattern)) {
            if (isSetStateType(lvalue.identifier)) {
              continue;
            }
            state.add(lvalue.identifier.id);
          }
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "PropertyLoad": {
        if (
          lvalue !== null &&
          state.has(value.object.identifier.id) &&
          !isSetStateType(lvalue.identifier)
        ) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "ComputedLoad": {
        if (
          lvalue !== null &&
          (state.has(value.object.identifier.id) ||
            state.has(value.property.identifier.id))
        ) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    for (const dep of scopeBlock.scope.dependencies) {
      const isReactive = state.has(dep.identifier.id);
      if (!isReactive) {
        scopeBlock.scope.dependencies.delete(dep);
      }
    }
    if (scopeBlock.scope.dependencies.size !== 0) {
      for (const [, declaration] of scopeBlock.scope.declarations) {
        state.add(declaration.identifier.id);
      }
      for (const reassignment of scopeBlock.scope.reassignments) {
        state.add(reassignment.id);
      }
    }
  }
};
function pruneTemporaryLValues(fn) {
  const lvalues = new Map();
  visitReactiveFunction(fn, new Visitor$3(), lvalues);
  for (const [, instr] of lvalues) {
    instr.lvalue = null;
  }
}
let Visitor$3 = class Visitor extends ReactiveFunctionVisitor {
  visitPlace(id, place, state) {
    state.delete(place.identifier);
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (
      instruction.lvalue !== null &&
      instruction.lvalue.identifier.name === null
    ) {
      state.set(instruction.lvalue.identifier, instruction);
    }
  }
};
function pruneUnusedLabels(fn) {
  const labels = new Set();
  visitReactiveFunction(fn, new Transform$2(), labels);
}
let Transform$2 = class Transform extends ReactiveFunctionTransform {
  transformTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    const { terminal: terminal } = stmt;
    if (
      (terminal.kind === "break" || terminal.kind === "continue") &&
      terminal.targetKind === "labeled"
    ) {
      state.add(terminal.target);
    }
    const isReachableLabel = stmt.label !== null && state.has(stmt.label.id);
    if (stmt.terminal.kind === "label" && !isReachableLabel) {
      const block = [...stmt.terminal.block];
      const last = block.at(-1);
      if (
        last !== undefined &&
        last.kind === "terminal" &&
        last.terminal.kind === "break" &&
        last.terminal.target === null
      ) {
        block.pop();
      }
      return { kind: "replace-many", value: block };
    } else {
      if (!isReachableLabel && stmt.label != null) {
        stmt.label.implicit = true;
      }
      return { kind: "keep" };
    }
  }
};
function pruneUnusedScopes(fn) {
  visitReactiveFunction(fn, new Transform$1(), { hasReturnStatement: false });
}
let Transform$1 = class Transform extends ReactiveFunctionTransform {
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    if (stmt.terminal.kind === "return") {
      state.hasReturnStatement = true;
    }
  }
  transformScope(scopeBlock, _state) {
    const scopeState = { hasReturnStatement: false };
    this.visitScope(scopeBlock, scopeState);
    if (
      !scopeState.hasReturnStatement &&
      scopeBlock.scope.reassignments.size === 0 &&
      (scopeBlock.scope.declarations.size === 0 ||
        !hasOwnDeclaration(scopeBlock))
    ) {
      return { kind: "replace-many", value: scopeBlock.instructions };
    } else {
      return { kind: "keep" };
    }
  }
};
function hasOwnDeclaration(block) {
  for (const declaration of block.scope.declarations.values()) {
    if (declaration.scope.id === block.scope.id) {
      return true;
    }
  }
  return false;
}
function collectReferencedGlobals(fn) {
  const identifiers = new Set();
  visitReactiveFunction(fn, new Visitor$2(), identifiers);
  return identifiers;
}
let Visitor$2 = class Visitor extends ReactiveFunctionVisitor {
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    } else if (value.kind === "LoadGlobal") {
      state.add(value.name);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};
var _Scopes_instances,
  _Scopes_seen,
  _Scopes_stack,
  _Scopes_globals,
  _Scopes_lookup;
function renameVariables(fn) {
  const globals = collectReferencedGlobals(fn);
  const scopes = new Scopes(globals);
  renameVariablesImpl(fn, new Visitor$1(), scopes);
  return new Set([...scopes.names, ...globals]);
}
function renameVariablesImpl(fn, visitor, scopes) {
  scopes.enter(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        scopes.visit(param.identifier);
      } else {
        scopes.visit(param.place.identifier);
      }
    }
    visitReactiveFunction(fn, visitor, scopes);
  });
}
let Visitor$1 = class Visitor extends ReactiveFunctionVisitor {
  visitParam(place, state) {
    state.visit(place.identifier);
  }
  visitLValue(_id, lvalue, state) {
    state.visit(lvalue.identifier);
  }
  visitPlace(id, place, state) {
    state.visit(place.identifier);
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
  visitScope(scope, state) {
    for (const [_, declaration] of scope.scope.declarations) {
      state.visit(declaration.identifier);
    }
    this.traverseScope(scope, state);
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, _fn, _state) {
    renameVariablesImpl(_fn, this, _state);
  }
};
class Scopes {
  constructor(globals) {
    _Scopes_instances.add(this);
    _Scopes_seen.set(this, new Map());
    _Scopes_stack.set(this, [new Map()]);
    _Scopes_globals.set(this, void 0);
    this.names = new Set();
    __classPrivateFieldSet(this, _Scopes_globals, globals, "f");
  }
  visit(identifier) {
    const originalName = identifier.name;
    if (originalName === null) {
      return;
    }
    const mappedName = __classPrivateFieldGet(this, _Scopes_seen, "f").get(
      identifier.id,
    );
    if (mappedName !== undefined) {
      identifier.name = mappedName;
      return;
    }
    let name = originalName.value;
    let id = 0;
    if (isPromotedTemporary(originalName.value)) {
      name = `t${id++}`;
    } else if (isPromotedJsxTemporary(originalName.value)) {
      name = `T${id++}`;
    }
    while (
      __classPrivateFieldGet(this, _Scopes_instances, "m", _Scopes_lookup).call(
        this,
        name,
      ) !== null ||
      __classPrivateFieldGet(this, _Scopes_globals, "f").has(name)
    ) {
      if (isPromotedTemporary(originalName.value)) {
        name = `t${id++}`;
      } else if (isPromotedJsxTemporary(originalName.value)) {
        name = `T${id++}`;
      } else {
        name = `${originalName.value}$${id++}`;
      }
    }
    const identifierName = makeIdentifierName(name);
    identifier.name = identifierName;
    __classPrivateFieldGet(this, _Scopes_seen, "f").set(
      identifier.id,
      identifierName,
    );
    __classPrivateFieldGet(this, _Scopes_stack, "f")
      .at(-1)
      .set(identifierName.value, identifier.id);
    this.names.add(identifierName.value);
  }
  enter(fn) {
    const next = new Map();
    __classPrivateFieldGet(this, _Scopes_stack, "f").push(next);
    fn();
    const last = __classPrivateFieldGet(this, _Scopes_stack, "f").pop();
    CompilerError.invariant(last === next, {
      reason: "Mismatch push/pop calls",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
}
(_Scopes_seen = new WeakMap()),
  (_Scopes_stack = new WeakMap()),
  (_Scopes_globals = new WeakMap()),
  (_Scopes_instances = new WeakSet()),
  (_Scopes_lookup = function _Scopes_lookup(name) {
    for (
      let i = __classPrivateFieldGet(this, _Scopes_stack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const scope = __classPrivateFieldGet(this, _Scopes_stack, "f")[i];
      const entry = scope.get(name);
      if (entry !== undefined) {
        return entry;
      }
    }
    return null;
  });
function logDebug(step, value) {}
function logCodegenFunction(step, fn) {}
function logHIRFunction(step, fn) {}
function logReactiveFunction(step, fn) {}
const DEFAULT_SHAPES = new Map(BUILTIN_SHAPES);
const UNTYPED_GLOBALS = new Set([
  "String",
  "Object",
  "Function",
  "Number",
  "RegExp",
  "Date",
  "Error",
  "Function",
  "TypeError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "URIError",
  "EvalError",
  "Boolean",
  "DataView",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Map",
  "Set",
  "WeakMap",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "ArrayBuffer",
  "JSON",
  "parseFloat",
  "parseInt",
  "console",
  "isNaN",
  "eval",
  "isFinite",
  "encodeURI",
  "decodeURI",
  "encodeURIComponent",
  "decodeURIComponent",
]);
const TYPED_GLOBALS = [
  [
    "Array",
    addObject(DEFAULT_SHAPES, "Array", [
      [
        "isArray",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [exports.Effect.Read],
          restParam: null,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "of",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Mutable,
        }),
      ],
    ]),
  ],
  [
    "Math",
    addObject(DEFAULT_SHAPES, "Math", [
      ["PI", { kind: "Primitive" }],
      [
        "max",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
    ]),
  ],
  ["Infinity", { kind: "Primitive" }],
  ["NaN", { kind: "Primitive" }],
  [
    "console",
    addObject(DEFAULT_SHAPES, "console", [
      [
        "error",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "info",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "log",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "table",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "trace",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
      [
        "warn",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Immutable,
        }),
      ],
    ]),
  ],
  [
    "Boolean",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
  [
    "Number",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
  [
    "String",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Immutable,
    }),
  ],
];
const REACT_APIS = [
  [
    "useContext",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: exports.Effect.Read,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.Read,
      hookKind: "useContext",
      returnValueKind: exports.ValueKind.Frozen,
      returnValueReason: ValueReason.Context,
    }),
  ],
  [
    "useState",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: exports.Effect.Freeze,
      returnType: { kind: "Object", shapeId: BuiltInUseStateId },
      calleeEffect: exports.Effect.Read,
      hookKind: "useState",
      returnValueKind: exports.ValueKind.Frozen,
      returnValueReason: ValueReason.State,
    }),
  ],
  [
    "useRef",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: exports.Effect.Capture,
      returnType: { kind: "Object", shapeId: BuiltInUseRefId },
      calleeEffect: exports.Effect.Read,
      hookKind: "useRef",
      returnValueKind: exports.ValueKind.Mutable,
    }),
  ],
  [
    "useMemo",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: exports.Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.Read,
      hookKind: "useMemo",
      returnValueKind: exports.ValueKind.Frozen,
    }),
  ],
  [
    "useCallback",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: exports.Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.Read,
      hookKind: "useCallback",
      returnValueKind: exports.ValueKind.Frozen,
    }),
  ],
  [
    "useEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Primitive" },
        calleeEffect: exports.Effect.Read,
        hookKind: "useEffect",
        returnValueKind: exports.ValueKind.Frozen,
      },
      BuiltInUseEffectHookId,
    ),
  ],
  [
    "useLayoutEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: exports.Effect.Read,
        hookKind: "useLayoutEffect",
        returnValueKind: exports.ValueKind.Frozen,
      },
      BuiltInUseLayoutEffectHookId,
    ),
  ],
  [
    "useInsertionEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: exports.Effect.Read,
        hookKind: "useLayoutEffect",
        returnValueKind: exports.ValueKind.Frozen,
      },
      BuiltInUseInsertionEffectHookId,
    ),
  ],
  [
    "use",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: exports.Effect.Read,
        returnValueKind: exports.ValueKind.Frozen,
      },
      BuiltInUseOperatorId,
    ),
  ],
];
TYPED_GLOBALS.push(
  [
    "React",
    addObject(DEFAULT_SHAPES, null, [
      ...REACT_APIS,
      [
        "createElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Frozen,
        }),
      ],
      [
        "cloneElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Frozen,
        }),
      ],
      [
        "createRef",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: exports.Effect.Capture,
          returnType: { kind: "Object", shapeId: BuiltInUseRefId },
          calleeEffect: exports.Effect.Read,
          returnValueKind: exports.ValueKind.Mutable,
        }),
      ],
    ]),
  ],
  [
    "_jsx",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: exports.Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: exports.Effect.Read,
      returnValueKind: exports.ValueKind.Frozen,
    }),
  ],
);
const DEFAULT_GLOBALS = new Map(REACT_APIS);
for (const name of UNTYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, { kind: "Poly" });
}
for (const [name, type_] of TYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, type_);
}
DEFAULT_GLOBALS.set(
  "globalThis",
  addObject(DEFAULT_SHAPES, "globalThis", TYPED_GLOBALS),
);
function installReAnimatedTypes(globals, registry) {
  const frozenHooks = [
    "useFrameCallback",
    "useAnimatedStyle",
    "useAnimatedProps",
    "useAnimatedScrollHandler",
    "useAnimatedReaction",
    "useWorkletCallback",
  ];
  for (const hook of frozenHooks) {
    globals.set(
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Poly" },
        returnValueKind: exports.ValueKind.Frozen,
        noAlias: true,
        calleeEffect: exports.Effect.Read,
        hookKind: "Custom",
      }),
    );
  }
  const mutableHooks = ["useSharedValue", "useDerivedValue"];
  for (const hook of mutableHooks) {
    globals.set(
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: exports.Effect.Freeze,
        returnType: { kind: "Poly" },
        returnValueKind: exports.ValueKind.Mutable,
        noAlias: true,
        calleeEffect: exports.Effect.Read,
        hookKind: "Custom",
      }),
    );
  }
  const funcs = [
    "withTiming",
    "withSpring",
    "createAnimatedPropAdapter",
    "withDecay",
    "withRepeat",
    "runOnUI",
    "executeOnUIRuntimeSync",
  ];
  for (const fn of funcs) {
    globals.set(
      fn,
      addFunction(registry, [], {
        positionalParams: [],
        restParam: exports.Effect.Read,
        returnType: { kind: "Poly" },
        calleeEffect: exports.Effect.Read,
        returnValueKind: exports.ValueKind.Mutable,
        noAlias: true,
      }),
    );
  }
}
var _Environment_instances,
  _Environment_globals,
  _Environment_shapes,
  _Environment_nextIdentifer,
  _Environment_nextBlock,
  _Environment_nextScope,
  _Environment_contextIdentifiers,
  _Environment_hoistedIdentifiers,
  _Environment_getCustomHookType;
const ExternalFunctionSchema = z.object({
  source: z.string(),
  importSpecifierName: z.string(),
});
const InstrumentationSchema = z
  .object({
    fn: ExternalFunctionSchema,
    gating: ExternalFunctionSchema.nullish(),
    globalGating: z.string().nullish(),
  })
  .refine(
    (opts) => opts.gating != null || opts.globalGating != null,
    "Expected at least one of gating or globalGating",
  );
const HookSchema = z.object({
  effectKind: z.nativeEnum(exports.Effect),
  valueKind: z.nativeEnum(exports.ValueKind),
  noAlias: z.boolean().default(false),
  transitiveMixedData: z.boolean().default(false),
});
const EnvironmentConfigSchema = z.object({
  customHooks: z.map(z.string(), HookSchema).optional().default(new Map()),
  enablePreserveExistingMemoizationGuarantees: z.boolean().default(false),
  validatePreserveExistingMemoizationGuarantees: z.boolean().default(true),
  enableForest: z.boolean().default(false),
  enableUseTypeAnnotations: z.boolean().default(false),
  enableAlignReactiveScopesToBlockScopesHIR: z.boolean().default(true),
  validateHooksUsage: z.boolean().default(true),
  validateRefAccessDuringRender: z.boolean().default(false),
  validateNoSetStateInRender: z.boolean().default(true),
  validateMemoizedEffectDependencies: z.boolean().default(false),
  validateNoCapitalizedCalls: z.nullable(z.array(z.string())).default([]),
  enableAssumeHooksFollowRulesOfReact: z.boolean().default(true),
  enableTransitivelyFreezeFunctionExpressions: z.boolean().default(true),
  enableEmitFreeze: ExternalFunctionSchema.nullish(),
  enableEmitHookGuards: ExternalFunctionSchema.nullish(),
  enableEmitInstrumentForget: InstrumentationSchema.nullish(),
  assertValidMutableRanges: z.boolean().default(false),
  enableChangeVariableCodegen: z.boolean().default(false),
  enableMemoizationComments: z.boolean().default(false),
  throwUnknownException__testonly: z.boolean().default(false),
  enableTreatFunctionDepsAsConditional: z.boolean().default(false),
  enableCustomTypeDefinitionForReAnimated: z.boolean().default(false),
  hookPattern: z.string().nullable().default(null),
});
function parseConfigPragma(pragma) {
  const maybeConfig = {};
  const defaultConfig = EnvironmentConfigSchema.parse({});
  for (const token of pragma.split(" ")) {
    if (!token.startsWith("@")) {
      continue;
    }
    const keyVal = token.slice(1);
    let [key, val] = keyVal.split(":");
    if (key === "validateNoCapitalizedCalls") {
      maybeConfig[key] = [];
      continue;
    }
    if (typeof defaultConfig[key] !== "boolean") {
      continue;
    }
    if (val === undefined || val === "true") {
      val = true;
    } else {
      val = false;
    }
    maybeConfig[key] = val;
  }
  const config = EnvironmentConfigSchema.safeParse(maybeConfig);
  if (config.success) {
    return config.data;
  }
  CompilerError.throwInvalidConfig({
    reason: `${fromZodError(config.error)}`,
    description: "Update Forget config to fix the error",
    loc: null,
    suggestions: null,
  });
}
class Environment {
  constructor(fnType, config, contextIdentifiers, logger, filename) {
    _Environment_instances.add(this);
    _Environment_globals.set(this, void 0);
    _Environment_shapes.set(this, void 0);
    _Environment_nextIdentifer.set(this, 0);
    _Environment_nextBlock.set(this, 0);
    _Environment_nextScope.set(this, 0);
    _Environment_contextIdentifiers.set(this, void 0);
    _Environment_hoistedIdentifiers.set(this, void 0);
    this.fnType = fnType;
    this.config = config;
    this.filename = filename;
    this.logger = logger;
    __classPrivateFieldSet(
      this,
      _Environment_shapes,
      new Map(DEFAULT_SHAPES),
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Environment_globals,
      new Map(DEFAULT_GLOBALS),
      "f",
    );
    for (const [hookName, hook] of this.config.customHooks) {
      CompilerError.invariant(
        !__classPrivateFieldGet(this, _Environment_globals, "f").has(hookName),
        {
          reason: `[Globals] Found existing definition in global registry for custom hook ${hookName}`,
          description: null,
          loc: null,
          suggestions: null,
        },
      );
      __classPrivateFieldGet(this, _Environment_globals, "f").set(
        hookName,
        addHook(__classPrivateFieldGet(this, _Environment_shapes, "f"), {
          positionalParams: [],
          restParam: hook.effectKind,
          returnType: hook.transitiveMixedData
            ? { kind: "Object", shapeId: BuiltInMixedReadonlyId }
            : { kind: "Poly" },
          returnValueKind: hook.valueKind,
          calleeEffect: exports.Effect.Read,
          hookKind: "Custom",
          noAlias: hook.noAlias,
        }),
      );
    }
    if (config.enableCustomTypeDefinitionForReAnimated) {
      installReAnimatedTypes(
        __classPrivateFieldGet(this, _Environment_globals, "f"),
        __classPrivateFieldGet(this, _Environment_shapes, "f"),
      );
    }
    __classPrivateFieldSet(
      this,
      _Environment_contextIdentifiers,
      contextIdentifiers,
      "f",
    );
    __classPrivateFieldSet(
      this,
      _Environment_hoistedIdentifiers,
      new Set(),
      "f",
    );
  }
  get nextIdentifierId() {
    var _a, _b;
    return makeIdentifierId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextIdentifer,
        ((_b = __classPrivateFieldGet(this, _Environment_nextIdentifer, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a),
    );
  }
  get nextBlockId() {
    var _a, _b;
    return makeBlockId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextBlock,
        ((_b = __classPrivateFieldGet(this, _Environment_nextBlock, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a),
    );
  }
  get nextScopeId() {
    var _a, _b;
    return makeScopeId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextScope,
        ((_b = __classPrivateFieldGet(this, _Environment_nextScope, "f")),
        (_a = _b++),
        _b),
        "f",
      ),
      _a),
    );
  }
  isContextIdentifier(node) {
    return __classPrivateFieldGet(
      this,
      _Environment_contextIdentifiers,
      "f",
    ).has(node);
  }
  isHoistedIdentifier(node) {
    return __classPrivateFieldGet(
      this,
      _Environment_hoistedIdentifiers,
      "f",
    ).has(node);
  }
  getGlobalDeclaration(name) {
    var _a;
    let resolvedName = name;
    if (this.config.hookPattern != null) {
      const match = new RegExp(this.config.hookPattern).exec(name);
      if (
        match != null &&
        typeof match[1] === "string" &&
        isHookName$1(match[1])
      ) {
        resolvedName = match[1];
      }
    }
    let resolvedGlobal =
      (_a = __classPrivateFieldGet(this, _Environment_globals, "f").get(
        resolvedName,
      )) !== null && _a !== void 0
        ? _a
        : null;
    if (resolvedGlobal === null) {
      if (isHookName$1(resolvedName)) {
        return __classPrivateFieldGet(
          this,
          _Environment_instances,
          "m",
          _Environment_getCustomHookType,
        ).call(this);
      }
    }
    return resolvedGlobal;
  }
  getPropertyType(receiver, property) {
    var _a, _b;
    let shapeId = null;
    if (receiver.kind === "Object" || receiver.kind === "Function") {
      shapeId = receiver.shapeId;
    }
    if (shapeId !== null) {
      const shape = __classPrivateFieldGet(this, _Environment_shapes, "f").get(
        shapeId,
      );
      CompilerError.invariant(shape !== undefined, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      let value =
        (_b =
          (_a = shape.properties.get(property)) !== null && _a !== void 0
            ? _a
            : shape.properties.get("*")) !== null && _b !== void 0
          ? _b
          : null;
      if (value === null && isHookName$1(property)) {
        value = __classPrivateFieldGet(
          this,
          _Environment_instances,
          "m",
          _Environment_getCustomHookType,
        ).call(this);
      }
      return value;
    } else if (isHookName$1(property)) {
      return __classPrivateFieldGet(
        this,
        _Environment_instances,
        "m",
        _Environment_getCustomHookType,
      ).call(this);
    } else {
      return null;
    }
  }
  getFunctionSignature(type) {
    const { shapeId: shapeId } = type;
    if (shapeId !== null) {
      const shape = __classPrivateFieldGet(this, _Environment_shapes, "f").get(
        shapeId,
      );
      CompilerError.invariant(shape !== undefined, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      return shape.functionType;
    }
    return null;
  }
  addHoistedIdentifier(node) {
    __classPrivateFieldGet(this, _Environment_contextIdentifiers, "f").add(
      node,
    );
    __classPrivateFieldGet(this, _Environment_hoistedIdentifiers, "f").add(
      node,
    );
  }
}
(_Environment_globals = new WeakMap()),
  (_Environment_shapes = new WeakMap()),
  (_Environment_nextIdentifer = new WeakMap()),
  (_Environment_nextBlock = new WeakMap()),
  (_Environment_nextScope = new WeakMap()),
  (_Environment_contextIdentifiers = new WeakMap()),
  (_Environment_hoistedIdentifiers = new WeakMap()),
  (_Environment_instances = new WeakSet()),
  (_Environment_getCustomHookType = function _Environment_getCustomHookType() {
    if (this.config.enableAssumeHooksFollowRulesOfReact) {
      return DefaultNonmutatingHook;
    } else {
      return DefaultMutatingHook;
    }
  });
function isHookName$1(name) {
  return /^use[A-Z0-9]/.test(name);
}
function parseEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return Ok(config.data);
  } else {
    return Err(config.error);
  }
}
function validateEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return config.data;
  }
  CompilerError.throwInvalidConfig({
    reason: `${fromZodError(config.error)}`,
    description: "Update Forget config to fix the error",
    loc: null,
    suggestions: null,
  });
}
function tryParseExternalFunction(maybeExternalFunction) {
  const externalFunction = ExternalFunctionSchema.safeParse(
    maybeExternalFunction,
  );
  if (externalFunction.success) {
    return externalFunction.data;
  }
  CompilerError.throwInvalidConfig({
    reason: `${fromZodError(externalFunction.error)}`,
    description: "Update Forget config to fix the error",
    loc: null,
    suggestions: null,
  });
}
var _MergedBlocks_map;
function mergeConsecutiveBlocks(fn) {
  const merged = new MergedBlocks();
  const fallthroughBlocks = new Set();
  for (const [, block] of fn.body.blocks) {
    const fallthrough = terminalFallthrough(block.terminal);
    if (fallthrough !== null) {
      fallthroughBlocks.add(fallthrough);
    }
    for (const instr of block.instructions) {
      if (
        instr.value.kind === "FunctionExpression" ||
        instr.value.kind === "ObjectMethod"
      ) {
        mergeConsecutiveBlocks(instr.value.loweredFunc.func);
      }
    }
    if (
      block.preds.size !== 1 ||
      block.kind !== "block" ||
      fallthroughBlocks.has(block.id)
    ) {
      continue;
    }
    const originalPredecessorId = Array.from(block.preds)[0];
    const predecessorId = merged.get(originalPredecessorId);
    const predecessor = fn.body.blocks.get(predecessorId);
    CompilerError.invariant(predecessor !== undefined, {
      reason: `Expected predecessor ${predecessorId} to exist`,
      description: null,
      loc: null,
      suggestions: null,
    });
    if (predecessor.terminal.kind !== "goto" || predecessor.kind !== "block") {
      continue;
    }
    for (const phi of block.phis) {
      CompilerError.invariant(phi.operands.size === 1, {
        reason: `Found a block with a single predecessor but where a phi has multiple (${phi.operands.size}) operands`,
        description: null,
        loc: null,
        suggestions: null,
      });
      const operand = Array.from(phi.operands.values())[0];
      const instr = {
        id: predecessor.terminal.id,
        lvalue: {
          kind: "Identifier",
          identifier: phi.id,
          effect: exports.Effect.ConditionallyMutate,
          reactive: false,
          loc: GeneratedSource,
        },
        value: {
          kind: "LoadLocal",
          place: {
            kind: "Identifier",
            identifier: operand,
            effect: exports.Effect.Read,
            reactive: false,
            loc: GeneratedSource,
          },
          loc: GeneratedSource,
        },
        loc: GeneratedSource,
      };
      predecessor.instructions.push(instr);
    }
    predecessor.instructions.push(...block.instructions);
    predecessor.terminal = block.terminal;
    merged.merge(block.id, predecessorId);
    fn.body.blocks.delete(block.id);
  }
  markPredecessors(fn.body);
  for (const [, block] of fn.body.blocks) {
    mapOptionalFallthroughs(block.terminal, (blockId) => merged.get(blockId));
  }
  removeUnreachableFallthroughs(fn.body);
}
class MergedBlocks {
  constructor() {
    _MergedBlocks_map.set(this, new Map());
  }
  merge(block, into) {
    const target = this.get(into);
    __classPrivateFieldGet(this, _MergedBlocks_map, "f").set(block, target);
  }
  get(block) {
    var _a;
    let current = block;
    while (__classPrivateFieldGet(this, _MergedBlocks_map, "f").has(current)) {
      current =
        (_a = __classPrivateFieldGet(this, _MergedBlocks_map, "f").get(
          current,
        )) !== null && _a !== void 0
          ? _a
          : current;
    }
    return current;
  }
}
_MergedBlocks_map = new WeakMap();
function addImportsToProgram(path, importList) {
  const identifiers = new Set();
  const sortedImports = new Map();
  for (const {
    importSpecifierName: importSpecifierName,
    source: source,
  } of importList) {
    CompilerError.invariant(identifiers.has(importSpecifierName) === false, {
      reason: `Encountered conflicting import specifier for ${importSpecifierName} in Forget config.`,
      description: null,
      loc: GeneratedSource,
      suggestions: null,
    });
    CompilerError.invariant(
      path.scope.hasBinding(importSpecifierName) === false,
      {
        reason: `Encountered conflicting import specifiers for ${importSpecifierName} in generated program.`,
        description: null,
        loc: GeneratedSource,
        suggestions: null,
      },
    );
    identifiers.add(importSpecifierName);
    const importSpecifierNameList = getOrInsertDefault(
      sortedImports,
      source,
      [],
    );
    importSpecifierNameList.push(importSpecifierName);
  }
  const stmts = [];
  for (const [source, importSpecifierNameList] of sortedImports) {
    const importSpecifiers = importSpecifierNameList.map((name) => {
      const id = t__namespace.identifier(name);
      return t__namespace.importSpecifier(id, id);
    });
    stmts.push(
      t__namespace.importDeclaration(
        importSpecifiers,
        t__namespace.stringLiteral(source),
      ),
    );
  }
  path.unshiftContainer("body", stmts);
}
function isNonNamespacedImportOfReact(importDeclPath) {
  return (
    importDeclPath.get("source").node.value === "react" &&
    importDeclPath
      .get("specifiers")
      .every((specifier) => specifier.isImportSpecifier()) &&
    importDeclPath.node.importKind !== "type" &&
    importDeclPath.node.importKind !== "typeof"
  );
}
function findExistingImports(program) {
  let didInsertUseMemoCache = false;
  let hasExistingReactImport = false;
  program.traverse({
    CallExpression(callExprPath) {
      const callee = callExprPath.get("callee");
      const args = callExprPath.get("arguments");
      if (
        callee.isIdentifier() &&
        callee.node.name === "useMemoCache" &&
        args.length === 1 &&
        args[0].isNumericLiteral()
      ) {
        didInsertUseMemoCache = true;
      }
    },
    ImportDeclaration(importDeclPath) {
      if (isNonNamespacedImportOfReact(importDeclPath)) {
        hasExistingReactImport = true;
      }
    },
  });
  return {
    didInsertUseMemoCache: didInsertUseMemoCache,
    hasExistingReactImport: hasExistingReactImport,
  };
}
function updateExistingReactImportDeclaration(program) {
  let didInsertUseMemoCache = false;
  program.traverse({
    ImportDeclaration(importDeclPath) {
      if (
        !didInsertUseMemoCache &&
        isNonNamespacedImportOfReact(importDeclPath)
      ) {
        importDeclPath.pushContainer(
          "specifiers",
          t__namespace.importSpecifier(
            t__namespace.identifier("useMemoCache"),
            t__namespace.identifier("unstable_useMemoCache"),
          ),
        );
        didInsertUseMemoCache = true;
      }
    },
  });
  return didInsertUseMemoCache;
}
function updateUseMemoCacheImport(program, options) {
  const {
    didInsertUseMemoCache: didInsertUseMemoCache,
    hasExistingReactImport: hasExistingReactImport,
  } = findExistingImports(program);
  if (!didInsertUseMemoCache) {
    return;
  }
  if (options.enableUseMemoCachePolyfill === false) {
    if (hasExistingReactImport) {
      const didUpdateImport = updateExistingReactImportDeclaration(program);
      if (didUpdateImport === false) {
        throw new Error(
          "Expected an ImportDeclaration of react in order to update ImportSpecifiers with useMemoCache",
        );
      }
    } else {
      addUseMemoCacheImportDeclaration(program, "react");
    }
  } else {
    addUseMemoCacheImportDeclaration(program, "react-forget-runtime");
  }
}
function addUseMemoCacheImportDeclaration(program, moduleName) {
  program.unshiftContainer(
    "body",
    t__namespace.importDeclaration(
      [
        t__namespace.importSpecifier(
          t__namespace.identifier("useMemoCache"),
          t__namespace.identifier("unstable_useMemoCache"),
        ),
      ],
      t__namespace.stringLiteral(moduleName),
    ),
  );
}
z.enum(["all_errors", "critical_errors", "none"]);
z.enum(["infer", "annotation", "all"]);
const defaultOptions = {
  compilationMode: "infer",
  panicThreshold: "none",
  environment: {},
  logger: null,
  gating: null,
  noEmit: false,
  enableUseMemoCachePolyfill: false,
  eslintSuppressionRules: null,
  flowSuppressions: false,
  ignoreUseNoForget: false,
};
function parsePluginOptions(obj) {
  if (obj == null || typeof obj !== "object") {
    return defaultOptions;
  }
  const parsedOptions = Object.create(null);
  for (let [key, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      value = value.toLowerCase();
    }
    if (isCompilerFlag(key)) {
      parsedOptions[key] = value;
    }
  }
  return Object.assign(Object.assign({}, defaultOptions), parsedOptions);
}
function isCompilerFlag(s) {
  return Object.prototype.hasOwnProperty.call(defaultOptions, s);
}
const DEFAULT_IDENTIFIER_INFO = {
  reassigned: false,
  reassignedByInnerFn: false,
  referencedByInnerFn: false,
};
const withFunctionScope = {
  enter: function (path, state) {
    state.currentFn.push(path);
  },
  exit: function (_, state) {
    state.currentFn.pop();
  },
};
function findContextIdentifiers(func) {
  const state = { currentFn: [], identifiers: new Map() };
  func.traverse(
    {
      FunctionDeclaration: withFunctionScope,
      FunctionExpression: withFunctionScope,
      ArrowFunctionExpression: withFunctionScope,
      ObjectMethod: withFunctionScope,
      AssignmentExpression(path, state) {
        var _a;
        const left = path.get("left");
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        handleAssignment(currentFn, state.identifiers, left);
      },
      UpdateExpression(path, state) {
        var _a;
        const argument = path.get("argument");
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        if (argument.isLVal()) {
          handleAssignment(currentFn, state.identifiers, argument);
        }
      },
      Identifier(path, state) {
        var _a;
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        if (path.isReferencedIdentifier()) {
          handleIdentifier(currentFn, state.identifiers, path);
        }
      },
    },
    state,
  );
  const result = new Set();
  for (const [id, info] of state.identifiers.entries()) {
    if (info.reassignedByInnerFn) {
      result.add(id);
    } else if (info.reassigned && info.referencedByInnerFn) {
      result.add(id);
    }
  }
  return result;
}
function handleIdentifier(currentFn, identifiers, path) {
  const name = path.node.name;
  const binding = path.scope.getBinding(name);
  if (binding == null) {
    return;
  }
  const identifier = getOrInsertDefault(
    identifiers,
    binding.identifier,
    Object.assign({}, DEFAULT_IDENTIFIER_INFO),
  );
  if (currentFn != null) {
    const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
    if (binding === bindingAboveLambdaScope) {
      identifier.referencedByInnerFn = true;
    }
  }
}
function handleAssignment(currentFn, identifiers, lvalPath) {
  var _a, _b, _c;
  const lvalNode = lvalPath.node;
  switch (lvalNode.type) {
    case "Identifier": {
      const path = lvalPath;
      const name = path.node.name;
      const binding = path.scope.getBinding(name);
      if (binding == null) {
        break;
      }
      const state = getOrInsertDefault(
        identifiers,
        binding.identifier,
        Object.assign({}, DEFAULT_IDENTIFIER_INFO),
      );
      state.reassigned = true;
      if (currentFn != null) {
        const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
        if (binding === bindingAboveLambdaScope) {
          state.reassignedByInnerFn = true;
        }
      }
      break;
    }
    case "ArrayPattern": {
      const path = lvalPath;
      for (const element of path.get("elements")) {
        if (nonNull(element)) {
          handleAssignment(currentFn, identifiers, element);
        }
      }
      break;
    }
    case "ObjectPattern": {
      const path = lvalPath;
      for (const property of path.get("properties")) {
        if (property.isObjectProperty()) {
          const valuePath = property.get("value");
          CompilerError.invariant(valuePath.isLVal(), {
            reason: `[FindContextIdentifiers] Expected object property value to be an LVal, got: ${valuePath.type}`,
            description: null,
            loc:
              (_a = valuePath.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
            suggestions: null,
          });
          handleAssignment(currentFn, identifiers, valuePath);
        } else {
          CompilerError.invariant(property.isRestElement(), {
            reason: `[FindContextIdentifiers] Invalid assumptions for babel types.`,
            description: null,
            loc:
              (_b = property.node.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
            suggestions: null,
          });
          handleAssignment(currentFn, identifiers, property);
        }
      }
      break;
    }
    case "AssignmentPattern": {
      const path = lvalPath;
      const left = path.get("left");
      handleAssignment(currentFn, identifiers, left);
      break;
    }
    case "RestElement": {
      const path = lvalPath;
      handleAssignment(currentFn, identifiers, path.get("argument"));
      break;
    }
    case "MemberExpression": {
      break;
    }
    default: {
      CompilerError.throwTodo({
        reason: `[FindContextIdentifiers] Cannot handle Object destructuring assignment target ${lvalNode.type}`,
        description: null,
        loc:
          (_c = lvalNode.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
        suggestions: null,
      });
    }
  }
}
function nonNull(t) {
  return t.node != null;
}
function eliminateRedundantPhi(fn, sharedRewrites) {
  const ir = fn.body;
  const rewrites = sharedRewrites != null ? sharedRewrites : new Map();
  let hasBackEdge = false;
  const visited = new Set();
  let size = rewrites.size;
  do {
    size = rewrites.size;
    for (const [blockId, block] of ir.blocks) {
      if (!hasBackEdge) {
        for (const predId of block.preds) {
          if (!visited.has(predId)) {
            hasBackEdge = true;
          }
        }
      }
      visited.add(blockId);
      phis: for (const phi of block.phis) {
        phi.operands = new Map(
          Array.from(phi.operands).map(([block, id]) => {
            var _a;
            return [
              block,
              (_a = rewrites.get(id)) !== null && _a !== void 0 ? _a : id,
            ];
          }),
        );
        let same = null;
        for (const [_, operand] of phi.operands) {
          if (
            (same !== null && operand.id === same.id) ||
            operand.id === phi.id.id
          ) {
            continue;
          } else if (same !== null) {
            continue phis;
          } else {
            same = operand;
          }
        }
        CompilerError.invariant(same !== null, {
          reason: "Expected phis to be non-empty",
          description: null,
          loc: null,
          suggestions: null,
        });
        rewrites.set(phi.id, same);
        block.phis.delete(phi);
      }
      for (const instr of block.instructions) {
        for (const place of eachInstructionLValue(instr)) {
          rewritePlace$1(place, rewrites);
        }
        for (const place of eachInstructionOperand(instr)) {
          rewritePlace$1(place, rewrites);
        }
        if (
          instr.value.kind === "FunctionExpression" ||
          instr.value.kind === "ObjectMethod"
        ) {
          const { context: context } = instr.value.loweredFunc.func;
          for (const place of context) {
            rewritePlace$1(place, rewrites);
          }
          eliminateRedundantPhi(instr.value.loweredFunc.func, rewrites);
        }
      }
      const { terminal: terminal } = block;
      for (const place of eachTerminalOperand(terminal)) {
        rewritePlace$1(place, rewrites);
      }
    }
  } while (rewrites.size > size && hasBackEdge);
}
function rewritePlace$1(place, rewrites) {
  const rewrite = rewrites.get(place.identifier);
  if (rewrite != null) {
    place.identifier = rewrite;
  }
}
var _SSABuilder_states,
  _SSABuilder_current,
  _SSABuilder_blocks,
  _SSABuilder_env,
  _SSABuilder_unknown,
  _SSABuilder_context;
class SSABuilder {
  constructor(env, blocks) {
    _SSABuilder_states.set(this, new Map());
    _SSABuilder_current.set(this, null);
    this.unsealedPreds = new Map();
    _SSABuilder_blocks.set(this, void 0);
    _SSABuilder_env.set(this, void 0);
    _SSABuilder_unknown.set(this, new Set());
    _SSABuilder_context.set(this, new Set());
    __classPrivateFieldSet(this, _SSABuilder_blocks, new Map(blocks), "f");
    __classPrivateFieldSet(this, _SSABuilder_env, env, "f");
  }
  get nextSsaId() {
    return __classPrivateFieldGet(this, _SSABuilder_env, "f").nextIdentifierId;
  }
  defineFunction(func) {
    for (const [id, block] of func.body.blocks) {
      __classPrivateFieldGet(this, _SSABuilder_blocks, "f").set(id, block);
    }
  }
  enter(fn) {
    const current = __classPrivateFieldGet(this, _SSABuilder_current, "f");
    fn();
    __classPrivateFieldSet(this, _SSABuilder_current, current, "f");
  }
  state() {
    CompilerError.invariant(
      __classPrivateFieldGet(this, _SSABuilder_current, "f") !== null,
      {
        reason: "we need to be in a block to access state!",
        description: null,
        loc: null,
        suggestions: null,
      },
    );
    return __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      __classPrivateFieldGet(this, _SSABuilder_current, "f"),
    );
  }
  makeId(oldId) {
    return {
      id: this.nextSsaId,
      name: oldId.name,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      scope: null,
      type: makeType(),
    };
  }
  defineContext(oldPlace) {
    const newPlace = this.definePlace(oldPlace);
    __classPrivateFieldGet(this, _SSABuilder_context, "f").add(
      oldPlace.identifier,
    );
    return newPlace;
  }
  definePlace(oldPlace) {
    const oldId = oldPlace.identifier;
    if (__classPrivateFieldGet(this, _SSABuilder_unknown, "f").has(oldId)) {
      CompilerError.throwTodo({
        reason: `[hoisting] EnterSSA: Expected identifier to be defined before being used`,
        description: `Identifier ${printIdentifier(oldId)} is undefined`,
        loc: oldPlace.loc,
        suggestions: null,
      });
    }
    if (__classPrivateFieldGet(this, _SSABuilder_context, "f").has(oldId)) {
      return this.getPlace(oldPlace);
    }
    const newId = this.makeId(oldId);
    this.state().defs.set(oldId, newId);
    return Object.assign(Object.assign({}, oldPlace), { identifier: newId });
  }
  getPlace(oldPlace) {
    const newId = this.getIdAt(
      oldPlace.identifier,
      __classPrivateFieldGet(this, _SSABuilder_current, "f").id,
    );
    return Object.assign(Object.assign({}, oldPlace), { identifier: newId });
  }
  getIdAt(oldId, blockId) {
    const block = __classPrivateFieldGet(this, _SSABuilder_blocks, "f").get(
      blockId,
    );
    const state = __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      block,
    );
    if (state.defs.has(oldId)) {
      return state.defs.get(oldId);
    }
    if (block.preds.size == 0) {
      __classPrivateFieldGet(this, _SSABuilder_unknown, "f").add(oldId);
      return oldId;
    }
    if (this.unsealedPreds.get(block) > 0) {
      const newId = this.makeId(oldId);
      state.incompletePhis.push({ oldId: oldId, newId: newId });
      state.defs.set(oldId, newId);
      return newId;
    }
    if (block.preds.size == 1) {
      const [pred] = block.preds;
      const newId = this.getIdAt(oldId, pred);
      state.defs.set(oldId, newId);
      return newId;
    }
    const newId = this.makeId(oldId);
    state.defs.set(oldId, newId);
    return this.addPhi(block, oldId, newId);
  }
  addPhi(block, oldId, newId) {
    const predDefs = new Map();
    for (const predBlockId of block.preds) {
      const predId = this.getIdAt(oldId, predBlockId);
      predDefs.set(predBlockId, predId);
    }
    const phi = {
      kind: "Phi",
      id: newId,
      operands: predDefs,
      type: makeType(),
    };
    block.phis.add(phi);
    return newId;
  }
  fixIncompletePhis(block) {
    const state = __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      block,
    );
    for (const phi of state.incompletePhis) {
      this.addPhi(block, phi.oldId, phi.newId);
    }
  }
  startBlock(block) {
    __classPrivateFieldSet(this, _SSABuilder_current, block, "f");
    __classPrivateFieldGet(this, _SSABuilder_states, "f").set(block, {
      defs: new Map(),
      incompletePhis: [],
    });
  }
  print() {
    var _a;
    const text = [];
    for (const [block, state] of __classPrivateFieldGet(
      this,
      _SSABuilder_states,
      "f",
    )) {
      text.push(`bb${block.id}:`);
      for (const [oldId, newId] of state.defs) {
        text.push(`  $${printIdentifier(oldId)}: $${printIdentifier(newId)}`);
      }
      for (const incompletePhi of state.incompletePhis) {
        text.push(
          `  iphi $${printIdentifier(incompletePhi.newId)} = $${printIdentifier(incompletePhi.oldId)}`,
        );
      }
    }
    text.push(
      `current block: bb${(_a = __classPrivateFieldGet(this, _SSABuilder_current, "f")) === null || _a === void 0 ? void 0 : _a.id}`,
    );
    console.log(text.join("\n"));
  }
}
(_SSABuilder_states = new WeakMap()),
  (_SSABuilder_current = new WeakMap()),
  (_SSABuilder_blocks = new WeakMap()),
  (_SSABuilder_env = new WeakMap()),
  (_SSABuilder_unknown = new WeakMap()),
  (_SSABuilder_context = new WeakMap());
function enterSSA(func) {
  const builder = new SSABuilder(func.env, func.body.blocks);
  enterSSAImpl(func, builder, func.body.entry);
}
function enterSSAImpl(func, builder, rootEntry) {
  const visitedBlocks = new Set();
  for (const [blockId, block] of func.body.blocks) {
    CompilerError.invariant(!visitedBlocks.has(block), {
      reason: `found a cycle! visiting bb${block.id} again`,
      description: null,
      loc: null,
      suggestions: null,
    });
    visitedBlocks.add(block);
    builder.startBlock(block);
    if (blockId === rootEntry) {
      CompilerError.invariant(func.context.length === 0, {
        reason: `Expected function context to be empty for outer function declarations`,
        description: null,
        loc: func.loc,
        suggestions: null,
      });
      func.params = func.params.map((param) => {
        if (param.kind === "Identifier") {
          return builder.definePlace(param);
        } else {
          return { kind: "Spread", place: builder.definePlace(param.place) };
        }
      });
    }
    for (const instr of block.instructions) {
      mapInstructionOperands(instr, (place) => builder.getPlace(place));
      mapInstructionLValues(instr, (lvalue) => builder.definePlace(lvalue));
      if (
        instr.value.kind === "FunctionExpression" ||
        instr.value.kind === "ObjectMethod"
      ) {
        const loweredFunc = instr.value.loweredFunc.func;
        const entry = loweredFunc.body.blocks.get(loweredFunc.body.entry);
        CompilerError.invariant(entry.preds.size === 0, {
          reason:
            "Expected function expression entry block to have zero predecessors",
          description: null,
          loc: null,
          suggestions: null,
        });
        entry.preds.add(blockId);
        builder.defineFunction(loweredFunc);
        builder.enter(() => {
          loweredFunc.context = loweredFunc.context.map((p) =>
            builder.getPlace(p),
          );
          loweredFunc.params = loweredFunc.params.map((param) => {
            if (param.kind === "Identifier") {
              return builder.definePlace(param);
            } else {
              return {
                kind: "Spread",
                place: builder.definePlace(param.place),
              };
            }
          });
          enterSSAImpl(loweredFunc, builder, rootEntry);
        });
        entry.preds.clear();
      }
    }
    mapTerminalOperands(block.terminal, (place) => builder.getPlace(place));
    for (const outputId of eachTerminalSuccessor(block.terminal)) {
      const output = func.body.blocks.get(outputId);
      let count;
      if (builder.unsealedPreds.has(output)) {
        count = builder.unsealedPreds.get(output) - 1;
      } else {
        count = output.preds.size - 1;
      }
      builder.unsealedPreds.set(output, count);
      if (count === 0 && visitedBlocks.has(output)) {
        builder.fixIncompletePhis(output);
      }
    }
  }
}
function leaveSSA(fn) {
  var _a, _b, _c;
  const declarations = new Map();
  for (const param of fn.params) {
    let place = param.kind === "Identifier" ? param : param.place;
    if (place.identifier.name !== null) {
      declarations.set(place.identifier.name.value, {
        lvalue: { kind: InstructionKind.Let, place: place },
        place: place,
      });
    }
  }
  const rewrites = new Map();
  const seen = new Set();
  const backEdgePhis = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const [pred] of phi.operands) {
        if (!seen.has(pred)) {
          backEdgePhis.add(phi);
          break;
        }
      }
    }
    seen.add(block.id);
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue: lvalue, value: value } = instr;
      if (value.kind === "DeclareLocal") {
        const name = value.lvalue.place.identifier.name;
        if (name !== null) {
          CompilerError.invariant(!declarations.has(name.value), {
            reason: `Unexpected duplicate declaration`,
            description: `Found duplicate declaration for '${name.value}'`,
            loc: value.lvalue.place.loc,
            suggestions: null,
          });
          declarations.set(name.value, {
            lvalue: value.lvalue,
            place: value.lvalue.place,
          });
        }
      } else if (
        value.kind === "PrefixUpdate" ||
        value.kind === "PostfixUpdate"
      ) {
        CompilerError.invariant(value.lvalue.identifier.name !== null, {
          reason: `Expected update expression to be applied to a named variable`,
          description: null,
          loc: value.lvalue.loc,
          suggestions: null,
        });
        const originalLVal = declarations.get(
          value.lvalue.identifier.name.value,
        );
        CompilerError.invariant(originalLVal !== undefined, {
          reason: `Expected update expression to be applied to a previously defined variable`,
          description: null,
          loc: value.lvalue.loc,
          suggestions: null,
        });
        originalLVal.lvalue.kind = InstructionKind.Let;
      } else if (value.kind === "StoreLocal") {
        if (value.lvalue.place.identifier.name != null) {
          const originalLVal = declarations.get(
            value.lvalue.place.identifier.name.value,
          );
          if (
            originalLVal === undefined ||
            originalLVal.lvalue === value.lvalue
          ) {
            CompilerError.invariant(
              originalLVal !== undefined ||
                block.kind === "block" ||
                block.kind === "catch",
              {
                reason: `TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)`,
                description: null,
                loc: value.lvalue.place.loc,
                suggestions: null,
              },
            );
            declarations.set(value.lvalue.place.identifier.name.value, {
              lvalue: value.lvalue,
              place: value.lvalue.place,
            });
            value.lvalue.kind = InstructionKind.Const;
          } else {
            originalLVal.lvalue.kind = InstructionKind.Let;
            value.lvalue.kind = InstructionKind.Reassign;
          }
        } else if (rewrites.has(value.lvalue.place.identifier)) {
          value.lvalue.kind = InstructionKind.Const;
        }
      } else if (value.kind === "Destructure") {
        let kind = null;
        for (const place of eachPatternOperand(value.lvalue.pattern)) {
          if (place.identifier.name == null) {
            CompilerError.invariant(
              kind === null || kind === InstructionKind.Const,
              {
                reason: `Expected consistent kind for destructuring`,
                description: `other places were '${kind}' but '${printPlace(place)}' is const`,
                loc: place.loc,
                suggestions: null,
              },
            );
            kind = InstructionKind.Const;
          } else {
            const originalLVal = declarations.get(place.identifier.name.value);
            if (
              originalLVal === undefined ||
              originalLVal.lvalue === value.lvalue
            ) {
              CompilerError.invariant(
                originalLVal !== undefined || block.kind !== "value",
                {
                  reason: `TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)`,
                  description: null,
                  loc: place.loc,
                  suggestions: null,
                },
              );
              declarations.set(place.identifier.name.value, {
                lvalue: value.lvalue,
                place: place,
              });
              CompilerError.invariant(
                kind === null || kind === InstructionKind.Const,
                {
                  reason: `Expected consistent kind for destructuring`,
                  description: `Other places were '${kind}' but '${printPlace(place)}' is const`,
                  loc: place.loc,
                  suggestions: null,
                },
              );
              kind = InstructionKind.Const;
            } else {
              CompilerError.invariant(
                kind === null || kind === InstructionKind.Reassign,
                {
                  reason: `Expected consistent kind for destructuring`,
                  description: `Other places were '${kind}' but '${printPlace(place)}' is reassigned`,
                  loc: place.loc,
                  suggestions: null,
                },
              );
              kind = InstructionKind.Reassign;
              originalLVal.lvalue.kind = InstructionKind.Let;
            }
          }
        }
        CompilerError.invariant(kind !== null, {
          reason: "Expected at least one operand",
          description: null,
          loc: null,
          suggestions: null,
        });
        value.lvalue.kind = kind;
      }
      rewritePlace(lvalue, rewrites, declarations);
      for (const operand of eachInstructionLValue(instr)) {
        rewritePlace(operand, rewrites, declarations);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        rewritePlace(operand, rewrites, declarations);
      }
    }
    const terminal = block.terminal;
    for (const operand of eachTerminalOperand(terminal)) {
      rewritePlace(operand, rewrites, declarations);
    }
    const reassignmentPhis = [];
    const rewritePhis = [];
    function pushPhis(phiBlock) {
      for (const phi of phiBlock.phis) {
        if (phi.id.name === null) {
          rewritePhis.push({ phi: phi, block: phiBlock });
        } else {
          reassignmentPhis.push({ phi: phi, block: phiBlock });
        }
      }
    }
    const fallthroughId = terminalFallthrough(terminal);
    if (fallthroughId !== null) {
      const fallthrough = fn.body.blocks.get(fallthroughId);
      pushPhis(fallthrough);
    }
    if (terminal.kind === "while" || terminal.kind === "for") {
      const test = fn.body.blocks.get(terminal.test);
      pushPhis(test);
      const loop = fn.body.blocks.get(terminal.loop);
      pushPhis(loop);
    }
    if (
      terminal.kind === "for" ||
      terminal.kind === "for-of" ||
      terminal.kind === "for-in"
    ) {
      let init = fn.body.blocks.get(terminal.init);
      pushPhis(init);
      let initContinuation =
        terminal.kind === "for" ? terminal.test : terminal.loop;
      const queue = [init.id];
      while (queue.length !== 0) {
        const blockId = queue.shift();
        if (blockId === initContinuation) {
          break;
        }
        const block = fn.body.blocks.get(blockId);
        for (const instr of block.instructions) {
          if (
            instr.value.kind === "StoreLocal" &&
            instr.value.lvalue.kind !== InstructionKind.Reassign
          ) {
            const value = instr.value;
            if (value.lvalue.place.identifier.name !== null) {
              const originalLVal = declarations.get(
                value.lvalue.place.identifier.name.value,
              );
              if (originalLVal === undefined) {
                declarations.set(value.lvalue.place.identifier.name.value, {
                  lvalue: value.lvalue,
                  place: value.lvalue.place,
                });
                value.lvalue.kind = InstructionKind.Const;
              }
            }
          }
        }
        switch (block.terminal.kind) {
          case "maybe-throw": {
            queue.push(block.terminal.continuation);
            break;
          }
          case "goto": {
            queue.push(block.terminal.block);
            break;
          }
          case "branch":
          case "logical":
          case "optional":
          case "ternary":
          case "label": {
            for (const successor of eachTerminalSuccessor(block.terminal)) {
              queue.push(successor);
            }
            break;
          }
        }
      }
      if (terminal.kind === "for" && terminal.update !== null) {
        const update = fn.body.blocks.get(terminal.update);
        pushPhis(update);
      }
    }
    for (const { phi: phi, block: phiBlock } of reassignmentPhis) {
      for (const [, operand] of phi.operands) {
        if (operand.mutableRange.start < terminal.id);
      }
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = phiBlock.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : phiBlock.terminal.id);
      CompilerError.invariant(phi.id.name != null, {
        reason: "Expected reassignment phis to have a name",
        description: null,
        loc: null,
        suggestions: null,
      });
      const declaration = declarations.get(phi.id.name.value);
      CompilerError.invariant(declaration != null, {
        loc: null,
        reason: "Expected a declaration for all variables",
        description: `${printIdentifier(phi.id)} in block bb${phiBlock.id}`,
        suggestions: null,
      });
      if (isPhiMutatedAfterCreation) {
        declaration.place.identifier.mutableRange.end = phi.id.mutableRange.end;
      }
      rewrites.set(phi.id, declaration.place.identifier);
    }
    for (const { phi: phi } of rewritePhis) {
      let canonicalId = rewrites.get(phi.id);
      if (canonicalId === undefined) {
        canonicalId = phi.id;
        for (const [, operand] of phi.operands) {
          let canonicalOperand =
            (_c = rewrites.get(operand)) !== null && _c !== void 0
              ? _c
              : operand;
          if (canonicalOperand.id < canonicalId.id) {
            canonicalId = canonicalOperand;
          }
        }
        rewrites.set(phi.id, canonicalId);
        if (canonicalId.name !== null) {
          const declaration = declarations.get(canonicalId.name.value);
          if (declaration !== undefined) {
            declaration.lvalue.kind = InstructionKind.Let;
          }
        }
      }
      for (const [, operand] of phi.operands) {
        rewrites.set(operand, canonicalId);
      }
    }
  }
}
function rewritePlace(place, rewrites, declarations) {
  const prevIdentifier = place.identifier;
  const nextIdentifier = rewrites.get(prevIdentifier);
  if (nextIdentifier !== undefined) {
    if (nextIdentifier === prevIdentifier) return;
    place.identifier = nextIdentifier;
  } else if (prevIdentifier.name != null) {
    const declaration = declarations.get(prevIdentifier.name.value);
    if (declaration === undefined) return;
    const originalIdentifier = declaration.place.identifier;
    prevIdentifier.id = originalIdentifier.id;
  }
}
function constantPropagation(fn) {
  const constants = new Map();
  constantPropagationImpl(fn, constants);
}
function constantPropagationImpl(fn, constants) {
  while (true) {
    const haveTerminalsChanged = applyConstantPropagation(fn, constants);
    if (!haveTerminalsChanged) {
      break;
    }
    reversePostorderBlocks(fn.body);
    removeUnreachableFallthroughs(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            phi.operands.delete(predecessor);
          }
        }
      }
    }
    eliminateRedundantPhi(fn);
    mergeConsecutiveBlocks(fn);
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function applyConstantPropagation(fn, constants) {
  let hasChanges = false;
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let value = evaluatePhi(phi, constants);
      if (value !== null) {
        constants.set(phi.id.id, value);
      }
    }
    for (let i = 0; i < block.instructions.length; i++) {
      if (block.kind === "sequence" && i === block.instructions.length - 1) {
        continue;
      }
      const instr = block.instructions[i];
      const value = evaluateInstruction(fn.env, constants, instr);
      if (value !== null) {
        constants.set(instr.lvalue.identifier.id, value);
      }
    }
    const terminal = block.terminal;
    switch (terminal.kind) {
      case "if": {
        const testValue = read(constants, terminal.test);
        if (testValue !== null && testValue.kind === "Primitive") {
          hasChanges = true;
          const targetBlockId = testValue.value
            ? terminal.consequent
            : terminal.alternate;
          block.terminal = {
            kind: "goto",
            variant: GotoVariant.Break,
            block: targetBlockId,
            id: terminal.id,
            loc: terminal.loc,
          };
        }
        break;
      }
    }
  }
  return hasChanges;
}
function evaluatePhi(phi, constants) {
  var _a;
  let value = null;
  for (const [, operand] of phi.operands) {
    const operandValue =
      (_a = constants.get(operand.id)) !== null && _a !== void 0 ? _a : null;
    if (operandValue === null) {
      return null;
    }
    if (value === null) {
      value = operandValue;
      continue;
    }
    if (operandValue.kind !== value.kind) {
      return null;
    }
    switch (operandValue.kind) {
      case "Primitive": {
        CompilerError.invariant(value.kind === "Primitive", {
          reason: "value kind expected to be Primitive",
          loc: null,
          suggestions: null,
        });
        if (operandValue.value !== value.value) {
          return null;
        }
        break;
      }
      case "LoadGlobal": {
        CompilerError.invariant(value.kind === "LoadGlobal", {
          reason: "value kind expected to be LoadGlobal",
          loc: null,
          suggestions: null,
        });
        if (operandValue.name !== value.name) {
          return null;
        }
        break;
      }
      default:
        return null;
    }
  }
  return value;
}
function evaluateInstruction(env, constants, instr) {
  const value = instr.value;
  switch (value.kind) {
    case "Primitive": {
      return value;
    }
    case "LoadGlobal": {
      return value;
    }
    case "ComputedLoad": {
      const property = read(constants, value.property);
      if (
        property !== null &&
        property.kind === "Primitive" &&
        typeof property.value === "string" &&
        t$a.isValidIdentifier(property.value)
      ) {
        const nextValue = {
          kind: "PropertyLoad",
          loc: value.loc,
          property: property.value,
          object: value.object,
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "ComputedStore": {
      const property = read(constants, value.property);
      if (
        property !== null &&
        property.kind === "Primitive" &&
        typeof property.value === "string" &&
        t$a.isValidIdentifier(property.value)
      ) {
        const nextValue = {
          kind: "PropertyStore",
          loc: value.loc,
          property: property.value,
          object: value.object,
          value: value.value,
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "PostfixUpdate": {
      const previous = read(constants, value.value);
      if (
        previous !== null &&
        previous.kind === "Primitive" &&
        typeof previous.value === "number"
      ) {
        const next =
          value.operation === "++" ? previous.value + 1 : previous.value - 1;
        constants.set(value.lvalue.identifier.id, {
          kind: "Primitive",
          value: next,
          loc: value.loc,
        });
        return previous;
      }
      return null;
    }
    case "PrefixUpdate": {
      const previous = read(constants, value.value);
      if (
        previous !== null &&
        previous.kind === "Primitive" &&
        typeof previous.value === "number"
      ) {
        const next = {
          kind: "Primitive",
          value:
            value.operation === "++" ? previous.value + 1 : previous.value - 1,
          loc: value.loc,
        };
        constants.set(value.lvalue.identifier.id, next);
        return next;
      }
      return null;
    }
    case "BinaryExpression": {
      const lhsValue = read(constants, value.left);
      const rhsValue = read(constants, value.right);
      if (
        lhsValue !== null &&
        rhsValue !== null &&
        lhsValue.kind === "Primitive" &&
        rhsValue.kind === "Primitive"
      ) {
        const lhs = lhsValue.value;
        const rhs = rhsValue.value;
        let result = null;
        switch (value.operator) {
          case "+": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs + rhs, loc: value.loc };
            }
            break;
          }
          case "-": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs - rhs, loc: value.loc };
            }
            break;
          }
          case "*": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs * rhs, loc: value.loc };
            }
            break;
          }
          case "/": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs / rhs, loc: value.loc };
            }
            break;
          }
          case "<": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs < rhs, loc: value.loc };
            }
            break;
          }
          case "<=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs <= rhs, loc: value.loc };
            }
            break;
          }
          case ">": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs > rhs, loc: value.loc };
            }
            break;
          }
          case ">=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs >= rhs, loc: value.loc };
            }
            break;
          }
          case "==": {
            result = { kind: "Primitive", value: lhs == rhs, loc: value.loc };
            break;
          }
          case "===": {
            result = { kind: "Primitive", value: lhs === rhs, loc: value.loc };
            break;
          }
          case "!=": {
            result = { kind: "Primitive", value: lhs != rhs, loc: value.loc };
            break;
          }
          case "!==": {
            result = { kind: "Primitive", value: lhs !== rhs, loc: value.loc };
            break;
          }
        }
        if (result !== null) {
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "PropertyLoad": {
      const objectValue = read(constants, value.object);
      if (objectValue !== null) {
        if (
          objectValue.kind === "Primitive" &&
          typeof objectValue.value === "string" &&
          value.property === "length"
        ) {
          const result = {
            kind: "Primitive",
            value: objectValue.value.length,
            loc: value.loc,
          };
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "LoadLocal": {
      const placeValue = read(constants, value.place);
      if (placeValue !== null) {
        instr.value = placeValue;
      }
      return placeValue;
    }
    case "StoreLocal": {
      const placeValue = read(constants, value.value);
      if (placeValue !== null) {
        constants.set(value.lvalue.place.identifier.id, placeValue);
      }
      return placeValue;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      constantPropagationImpl(value.loweredFunc.func, constants);
      return null;
    }
    default: {
      return null;
    }
  }
}
function read(constants, place) {
  var _a;
  return (_a = constants.get(place.identifier.id)) !== null && _a !== void 0
    ? _a
    : null;
}
function deadCodeElimination(fn) {
  const state = findReferencedIdentifiers(fn);
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (!state.isIdOrNameUsed(phi.id)) {
        block.phis.delete(phi);
      }
    }
    retainWhere(block.instructions, (instr) =>
      state.isIdOrNameUsed(instr.lvalue.identifier),
    );
    for (let i = 0; i < block.instructions.length; i++) {
      const isBlockValue =
        block.kind !== "block" && i === block.instructions.length - 1;
      if (!isBlockValue) {
        rewriteInstruction(block.instructions[i], state);
      }
    }
  }
}
class State {
  constructor() {
    this.named = new Set();
    this.identifiers = new Set();
  }
  reference(identifier) {
    this.identifiers.add(identifier.id);
    if (identifier.name !== null) {
      this.named.add(identifier.name.value);
    }
  }
  isIdOrNameUsed(identifier) {
    return (
      this.identifiers.has(identifier.id) ||
      (identifier.name !== null && this.named.has(identifier.name.value))
    );
  }
  isIdUsed(identifier) {
    return this.identifiers.has(identifier.id);
  }
  get count() {
    return this.identifiers.size;
  }
}
function findReferencedIdentifiers(fn) {
  const hasLoop = hasBackEdge(fn);
  const reversedBlocks = [...fn.body.blocks.values()].reverse();
  const state = new State();
  let size = state.count;
  do {
    size = state.count;
    for (const block of reversedBlocks) {
      for (const operand of eachTerminalOperand(block.terminal)) {
        state.reference(operand.identifier);
      }
      for (let i = block.instructions.length - 1; i >= 0; i--) {
        const instr = block.instructions[i];
        const isBlockValue =
          block.kind !== "block" && i === block.instructions.length - 1;
        if (isBlockValue) {
          state.reference(instr.lvalue.identifier);
          for (const place of eachInstructionValueOperand(instr.value)) {
            state.reference(place.identifier);
          }
        } else if (
          state.isIdOrNameUsed(instr.lvalue.identifier) ||
          !pruneableValue(instr.value, state)
        ) {
          state.reference(instr.lvalue.identifier);
          if (instr.value.kind === "StoreLocal") {
            if (
              instr.value.lvalue.kind === InstructionKind.Reassign ||
              state.isIdUsed(instr.value.lvalue.place.identifier)
            ) {
              state.reference(instr.value.value.identifier);
            }
          } else {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              state.reference(operand.identifier);
            }
          }
        }
      }
      for (const phi of block.phis) {
        if (state.isIdOrNameUsed(phi.id)) {
          for (const [_pred, operand] of phi.operands) {
            state.reference(operand);
          }
        }
      }
    }
  } while (state.count > size && hasLoop);
  return state;
}
function rewriteInstruction(instr, state) {
  if (instr.value.kind === "Destructure") {
    switch (instr.value.lvalue.pattern.kind) {
      case "ArrayPattern": {
        let nextItems = null;
        const originalItems = instr.value.lvalue.pattern.items;
        for (let i = originalItems.length - 1; i >= 0; i--) {
          const item = originalItems[i];
          if (item.kind === "Identifier") {
            if (state.isIdOrNameUsed(item.identifier)) {
              nextItems = originalItems.slice(0, i + 1);
              break;
            }
          } else if (item.kind === "Spread") {
            if (state.isIdOrNameUsed(item.place.identifier)) {
              nextItems = originalItems.slice(0, i + 1);
              break;
            }
          }
        }
        if (nextItems !== null) {
          instr.value.lvalue.pattern.items = nextItems;
        }
        break;
      }
      case "ObjectPattern": {
        let nextProperties = null;
        for (const property of instr.value.lvalue.pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties !== null && nextProperties !== void 0
                ? nextProperties
                : (nextProperties = []);
              nextProperties.push(property);
            }
          } else {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties = null;
              break;
            }
          }
        }
        if (nextProperties !== null) {
          instr.value.lvalue.pattern.properties = nextProperties;
        }
        break;
      }
      default: {
        assertExhaustive(
          instr.value.lvalue.pattern,
          `Unexpected pattern kind '${instr.value.lvalue.pattern.kind}'`,
        );
      }
    }
  } else if (instr.value.kind === "StoreLocal") {
    if (
      instr.value.lvalue.kind !== InstructionKind.Reassign &&
      !state.isIdUsed(instr.value.lvalue.place.identifier)
    ) {
      instr.value = {
        kind: "DeclareLocal",
        lvalue: instr.value.lvalue,
        type: instr.value.type,
        loc: instr.value.loc,
      };
    }
  }
}
function pruneableValue(value, state) {
  switch (value.kind) {
    case "DeclareLocal": {
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "StoreLocal": {
      if (value.lvalue.kind === InstructionKind.Reassign) {
        return !state.isIdUsed(value.lvalue.place.identifier);
      }
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "Destructure": {
      let isIdOrNameUsed = false;
      let isIdUsed = false;
      for (const place of eachPatternOperand(value.lvalue.pattern)) {
        if (state.isIdUsed(place.identifier)) {
          isIdOrNameUsed = true;
          isIdUsed = true;
        } else if (state.isIdOrNameUsed(place.identifier)) {
          isIdOrNameUsed = true;
        }
      }
      if (value.lvalue.kind === InstructionKind.Reassign) {
        return !isIdUsed;
      } else {
        return !isIdOrNameUsed;
      }
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      return !state.isIdUsed(value.lvalue.identifier);
    }
    case "Debugger": {
      return false;
    }
    case "Await":
    case "CallExpression":
    case "ComputedDelete":
    case "ComputedStore":
    case "PropertyDelete":
    case "MethodCall":
    case "PropertyStore": {
      return false;
    }
    case "NewExpression":
    case "UnsupportedNode":
    case "TaggedTemplateExpression": {
      return false;
    }
    case "NextPropertyOf":
    case "NextIterableOf": {
      return false;
    }
    case "LoadContext":
    case "DeclareContext":
    case "StoreContext": {
      return false;
    }
    case "StartMemoize":
    case "FinishMemoize": {
      return false;
    }
    case "RegExpLiteral":
    case "LoadGlobal":
    case "ArrayExpression":
    case "BinaryExpression":
    case "ComputedLoad":
    case "ObjectMethod":
    case "FunctionExpression":
    case "LoadLocal":
    case "JsxExpression":
    case "JsxFragment":
    case "JSXText":
    case "ObjectExpression":
    case "Primitive":
    case "PropertyLoad":
    case "TemplateLiteral":
    case "TypeCastExpression":
    case "UnaryExpression": {
      return true;
    }
    default: {
      assertExhaustive(value, `Unexepcted value kind '${value.kind}'`);
    }
  }
}
function hasBackEdge(fn) {
  return findBlocksWithBackEdges(fn).size > 0;
}
function findBlocksWithBackEdges(fn) {
  const visited = new Set();
  const blocks = new Set();
  for (const [blockId, block] of fn.body.blocks) {
    for (const predId of block.preds) {
      if (!visited.has(predId)) {
        blocks.add(blockId);
      }
    }
    visited.add(blockId);
  }
  return blocks;
}
function pruneMaybeThrows(fn) {
  const terminalMapping = pruneMaybeThrowsImpl(fn);
  if (terminalMapping) {
    reversePostorderBlocks(fn.body);
    removeUnreachableFallthroughs(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    mergeConsecutiveBlocks(fn);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor, operand] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            const mappedTerminal = terminalMapping.get(predecessor);
            CompilerError.invariant(mappedTerminal != null, {
              reason: `Expected non-existing phi operand's predecessor to have been mapped to a new terminal`,
              loc: GeneratedSource,
              description: `Could not find mapping for predecessor bb${predecessor} in block bb${block.id} for phi ${printIdentifier(phi.id)}`,
              suggestions: null,
            });
            phi.operands.delete(predecessor);
            phi.operands.set(mappedTerminal, operand);
          }
        }
      }
    }
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function pruneMaybeThrowsImpl(fn) {
  var _a;
  const terminalMapping = new Map();
  for (const [_, block] of fn.body.blocks) {
    const terminal = block.terminal;
    if (terminal.kind !== "maybe-throw") {
      continue;
    }
    const canThrow = block.instructions.some((instr) =>
      instructionMayThrow(instr),
    );
    if (!canThrow) {
      const source =
        (_a = terminalMapping.get(block.id)) !== null && _a !== void 0
          ? _a
          : block.id;
      terminalMapping.set(terminal.continuation, source);
      block.terminal = {
        kind: "goto",
        block: terminal.continuation,
        variant: GotoVariant.Break,
        id: terminal.id,
        loc: terminal.loc,
      };
    }
  }
  return terminalMapping.size > 0 ? terminalMapping : null;
}
function instructionMayThrow(instr) {
  switch (instr.value.kind) {
    case "Primitive":
    case "ArrayExpression":
    case "ObjectExpression": {
      return false;
    }
    default: {
      return true;
    }
  }
}
function inferMutableContextVariables(fn) {
  const state = new IdentifierState();
  const knownMutatedIdentifiers = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "PropertyLoad": {
          state.declareProperty(
            instr.lvalue,
            instr.value.object,
            instr.value.property,
          );
          break;
        }
        case "ComputedLoad": {
          state.declareProperty(instr.lvalue, instr.value.object, "");
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          if (instr.lvalue.identifier.name === null) {
            state.declareTemporary(instr.lvalue, instr.value.place);
          }
          break;
        }
        default: {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            visitOperand(state, knownMutatedIdentifiers, operand);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitOperand(state, knownMutatedIdentifiers, operand);
    }
  }
  for (const operand of fn.context) {
    if (knownMutatedIdentifiers.has(operand.identifier)) {
      operand.effect = exports.Effect.Mutate;
    }
  }
}
function visitOperand(state, knownMutatedIdentifiers, operand) {
  const resolved = state.resolve(operand.identifier);
  if (
    operand.effect === exports.Effect.Mutate ||
    operand.effect === exports.Effect.Store
  ) {
    knownMutatedIdentifiers.add(resolved);
  }
}
function inferAliases(func) {
  const aliases = new DisjointSet();
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      inferInstr(instr, aliases);
    }
  }
  return aliases;
}
function inferInstr(instr, aliases) {
  const { lvalue: lvalue, value: instrValue } = instr;
  let alias = null;
  switch (instrValue.kind) {
    case "LoadLocal":
    case "LoadContext": {
      if (isPrimitiveType(instrValue.place.identifier)) {
        return;
      }
      alias = instrValue.place;
      break;
    }
    case "StoreLocal":
    case "StoreContext": {
      alias = instrValue.value;
      break;
    }
    case "Destructure": {
      alias = instrValue.value;
      break;
    }
    case "ComputedLoad":
    case "PropertyLoad": {
      alias = instrValue.object;
      break;
    }
    case "TypeCastExpression": {
      alias = instrValue.value;
      break;
    }
    default:
      return;
  }
  aliases.union([lvalue.identifier, alias.identifier]);
}
function inferAliasForPhis(func, aliases) {
  var _a, _b;
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = block.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : block.terminal.id);
      if (isPhiMutatedAfterCreation) {
        for (const [, operand] of phi.operands) {
          aliases.union([phi.id, operand]);
        }
      }
    }
  }
}
function inferAliasForStores(func, aliases) {
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      const { value: value, lvalue: lvalue } = instr;
      const isStore =
        lvalue.effect === exports.Effect.Store ||
        ![...eachInstructionValueOperand(value)].every(
          (operand) => operand.effect !== exports.Effect.Store,
        );
      if (!isStore) {
        continue;
      }
      for (const operand of eachInstructionLValue(instr)) {
        maybeAlias(aliases, lvalue, operand, instr.id);
      }
      for (const operand of eachInstructionValueOperand(value)) {
        if (
          operand.effect === exports.Effect.Capture ||
          operand.effect === exports.Effect.Store
        ) {
          maybeAlias(aliases, lvalue, operand, instr.id);
        }
      }
    }
  }
}
function maybeAlias(aliases, lvalue, rvalue, id) {
  if (
    lvalue.identifier.mutableRange.end > id + 1 ||
    rvalue.identifier.mutableRange.end > id
  ) {
    aliases.union([lvalue.identifier, rvalue.identifier]);
  }
}
function infer$1(place, instrId) {
  place.identifier.mutableRange.end = makeInstructionId(instrId + 1);
}
function inferPlace(place, instrId, inferMutableRangeForStores) {
  switch (place.effect) {
    case exports.Effect.Unknown: {
      throw new Error(`Found an unknown place ${printPlace(place)}}!`);
    }
    case exports.Effect.Capture:
    case exports.Effect.Read:
    case exports.Effect.Freeze:
      return;
    case exports.Effect.Store:
      if (inferMutableRangeForStores) {
        infer$1(place, instrId);
      }
      return;
    case exports.Effect.ConditionallyMutate:
    case exports.Effect.Mutate: {
      infer$1(place, instrId);
      return;
    }
    default:
      assertExhaustive(place.effect, `Unexpected ${printPlace(place)} effect`);
  }
}
function inferMutableLifetimes(func, inferMutableRangeForStores) {
  var _a, _b;
  const contextVariableDeclarationInstructions = new Map();
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = block.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : block.terminal.id);
      if (
        inferMutableRangeForStores &&
        isPhiMutatedAfterCreation &&
        phi.id.mutableRange.start === 0
      ) {
        for (const [, operand] of phi.operands) {
          if (phi.id.mutableRange.start === 0) {
            phi.id.mutableRange.start = operand.mutableRange.start;
          } else {
            phi.id.mutableRange.start = makeInstructionId(
              Math.min(phi.id.mutableRange.start, operand.mutableRange.start),
            );
          }
        }
      }
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        const lvalueId = operand.identifier;
        lvalueId.mutableRange.start = instr.id;
        lvalueId.mutableRange.end = makeInstructionId(instr.id + 1);
      }
      for (const operand of eachInstructionOperand(instr)) {
        inferPlace(operand, instr.id, inferMutableRangeForStores);
      }
      if (
        instr.value.kind === "DeclareContext" ||
        (instr.value.kind === "StoreContext" &&
          instr.value.lvalue.kind !== InstructionKind.Reassign)
      ) {
        contextVariableDeclarationInstructions.set(
          instr.value.lvalue.place.identifier,
          instr.id,
        );
      } else if (instr.value.kind === "StoreContext") {
        const declaration = contextVariableDeclarationInstructions.get(
          instr.value.lvalue.place.identifier,
        );
        if (declaration != null) {
          const range = instr.value.lvalue.place.identifier.mutableRange;
          if (range.start === 0) {
            range.start = declaration;
          } else {
            range.start = makeInstructionId(Math.min(range.start, declaration));
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      inferPlace(operand, block.terminal.id, inferMutableRangeForStores);
    }
  }
}
function inferMutableRangesForAlias(_fn, aliases) {
  const aliasSets = aliases.buildSets();
  for (const aliasSet of aliasSets) {
    const mutatingIdentifiers = [...aliasSet].filter(
      (id) => id.mutableRange.end - id.mutableRange.start > 1,
    );
    if (mutatingIdentifiers.length > 0) {
      let lastMutatingInstructionId = 0;
      for (const id of mutatingIdentifiers) {
        if (id.mutableRange.end > lastMutatingInstructionId) {
          lastMutatingInstructionId = id.mutableRange.end;
        }
      }
      for (const alias of aliasSet) {
        if (alias.mutableRange.end < lastMutatingInstructionId) {
          alias.mutableRange.end = lastMutatingInstructionId;
        }
      }
    }
  }
}
function inferTryCatchAliases(fn, aliases) {
  const handlerParams = new Map();
  for (const [_, block] of fn.body.blocks) {
    if (
      block.terminal.kind === "try" &&
      block.terminal.handlerBinding !== null
    ) {
      handlerParams.set(
        block.terminal.handler,
        block.terminal.handlerBinding.identifier,
      );
    } else if (block.terminal.kind === "maybe-throw") {
      const handlerParam = handlerParams.get(block.terminal.handler);
      if (handlerParam === undefined) {
        continue;
      }
      for (const instr of block.instructions) {
        aliases.union([handlerParam, instr.lvalue.identifier]);
      }
    }
  }
}
function inferMutableRanges(ir) {
  inferMutableLifetimes(ir, false);
  const aliases = inferAliases(ir);
  inferTryCatchAliases(ir, aliases);
  let prevAliases = aliases.canonicalize();
  while (true) {
    inferMutableRangesForAlias(ir, aliases);
    inferAliasForStores(ir, aliases);
    inferAliasForPhis(ir, aliases);
    const nextAliases = aliases.canonicalize();
    if (areEqualMaps(prevAliases, nextAliases)) {
      break;
    }
    prevAliases = nextAliases;
  }
  inferMutableLifetimes(ir, true);
  inferMutableRangesForAlias(ir, aliases);
}
function areEqualMaps(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (!b.has(key)) {
      return false;
    }
    if (b.get(key) !== value) {
      return false;
    }
  }
  return true;
}
class IdentifierState {
  constructor() {
    this.properties = new Map();
  }
  resolve(identifier) {
    const resolved = this.properties.get(identifier);
    if (resolved !== undefined) {
      return resolved.identifier;
    }
    return identifier;
  }
  declareProperty(lvalue, object, property) {
    const objectDependency = this.properties.get(object.identifier);
    let nextDependency;
    if (objectDependency === undefined) {
      nextDependency = { identifier: object.identifier, path: [property] };
    } else {
      nextDependency = {
        identifier: objectDependency.identifier,
        path: [...objectDependency.path, property],
      };
    }
    this.properties.set(lvalue.identifier, nextDependency);
  }
  declareTemporary(lvalue, value) {
    var _a;
    const resolved =
      (_a = this.properties.get(value.identifier)) !== null && _a !== void 0
        ? _a
        : { identifier: value.identifier, path: [] };
    this.properties.set(lvalue.identifier, resolved);
  }
}
function analyseFunctions(func) {
  const state = new IdentifierState();
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          lower(instr.value.loweredFunc.func);
          infer(instr.value.loweredFunc, state, func.context);
          break;
        }
        case "PropertyLoad": {
          state.declareProperty(
            instr.lvalue,
            instr.value.object,
            instr.value.property,
          );
          break;
        }
        case "ComputedLoad": {
          state.declareProperty(instr.lvalue, instr.value.object, "");
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          if (instr.lvalue.identifier.name === null) {
            state.declareTemporary(instr.lvalue, instr.value.place);
          }
          break;
        }
      }
    }
  }
}
function lower(func) {
  analyseFunctions(func);
  inferReferenceEffects(func, { isFunctionExpression: true });
  deadCodeElimination(func);
  inferMutableRanges(func);
  leaveSSA(func);
  inferReactiveScopeVariables(func);
  inferMutableContextVariables(func);
}
function infer(loweredFunc, state, context) {
  const mutations = new Map();
  for (const operand of loweredFunc.func.context) {
    if (
      isMutatedOrReassigned(operand.identifier) &&
      operand.identifier.name !== null
    ) {
      mutations.set(operand.identifier.name.value, operand.effect);
    }
  }
  for (const dep of loweredFunc.dependencies) {
    let name = null;
    if (state.properties.has(dep.identifier)) {
      const receiver = state.properties.get(dep.identifier);
      name = receiver.identifier.name;
    } else {
      name = dep.identifier.name;
    }
    if (isUseRefType(dep.identifier) || isRefValueType(dep.identifier)) {
      dep.effect = exports.Effect.Capture;
    } else if (name !== null) {
      const effect = mutations.get(name.value);
      if (effect !== undefined) {
        dep.effect =
          effect === exports.Effect.Unknown ? exports.Effect.Capture : effect;
      }
    }
  }
  for (const place of context) {
    CompilerError.invariant(place.identifier.name !== null, {
      reason: "context refs should always have a name",
      description: null,
      loc: place.loc,
      suggestions: null,
    });
    const effect = mutations.get(place.identifier.name.value);
    if (effect !== undefined) {
      place.effect =
        effect === exports.Effect.Unknown ? exports.Effect.Capture : effect;
      loweredFunc.dependencies.push(place);
    }
  }
  for (const operand of loweredFunc.func.context) {
    operand.identifier.mutableRange.start = makeInstructionId(0);
    operand.identifier.mutableRange.end = makeInstructionId(0);
    operand.identifier.scope = null;
  }
}
function isMutatedOrReassigned(id) {
  return id.mutableRange.end > id.mutableRange.start;
}
function collectMaybeMemoDependencies(value, maybeDeps) {
  var _a;
  switch (value.kind) {
    case "LoadGlobal": {
      return { root: { kind: "Global", identifierName: value.name }, path: [] };
    }
    case "PropertyLoad": {
      const object = maybeDeps.get(value.object.identifier.id);
      if (object != null) {
        return { root: object.root, path: [...object.path, value.property] };
      }
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      const source = maybeDeps.get(value.place.identifier.id);
      if (source != null) {
        return source;
      } else if (
        value.place.identifier.name != null &&
        value.place.identifier.name.kind === "named"
      ) {
        return {
          root: { kind: "NamedLocal", value: Object.assign({}, value.place) },
          path: [],
        };
      }
      break;
    }
    case "StoreLocal": {
      const lvalue = value.lvalue.place.identifier;
      const rvalue = value.value.identifier.id;
      const aliased = maybeDeps.get(rvalue);
      if (
        aliased != null &&
        ((_a = lvalue.name) === null || _a === void 0 ? void 0 : _a.kind) !==
          "named"
      ) {
        maybeDeps.set(lvalue.id, aliased);
        return aliased;
      }
      break;
    }
  }
  return null;
}
function collectTemporaries(instr, env, sidemap) {
  const { value: value, lvalue: lvalue } = instr;
  switch (value.kind) {
    case "FunctionExpression": {
      sidemap.functions.set(instr.lvalue.identifier.id, instr);
      break;
    }
    case "LoadGlobal": {
      const global = env.getGlobalDeclaration(value.name);
      const hookKind = global !== null ? getHookKindForType(env, global) : null;
      const lvalId = instr.lvalue.identifier.id;
      if (hookKind === "useMemo" || hookKind === "useCallback") {
        sidemap.manualMemos.set(lvalId, { kind: hookKind, loadInstr: instr });
      } else if (value.name === "React") {
        sidemap.react.add(lvalId);
      }
      break;
    }
    case "PropertyLoad": {
      if (sidemap.react.has(value.object.identifier.id)) {
        if (value.property === "useMemo" || value.property === "useCallback") {
          sidemap.manualMemos.set(instr.lvalue.identifier.id, {
            kind: value.property,
            loadInstr: instr,
          });
        }
      }
      break;
    }
    case "ArrayExpression": {
      if (value.elements.every((e) => e.kind === "Identifier")) {
        sidemap.maybeDepsLists.set(instr.lvalue.identifier.id, value.elements);
      }
      break;
    }
  }
  const maybeDep = collectMaybeMemoDependencies(value, sidemap.maybeDeps);
  if (maybeDep != null) {
    sidemap.maybeDeps.set(lvalue.identifier.id, maybeDep);
  }
}
function makeManualMemoizationMarkers(
  fnExpr,
  env,
  depsList,
  memoDecl,
  manualMemoId,
) {
  return [
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env),
      value: {
        kind: "StartMemoize",
        manualMemoId: manualMemoId,
        deps: depsList,
        loc: fnExpr.loc,
      },
      loc: fnExpr.loc,
    },
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env),
      value: {
        kind: "FinishMemoize",
        manualMemoId: manualMemoId,
        decl: Object.assign({}, memoDecl),
        loc: fnExpr.loc,
      },
      loc: fnExpr.loc,
    },
  ];
}
function getManualMemoizationReplacement(fn, loc, kind) {
  if (kind === "useMemo") {
    return { kind: "CallExpression", callee: fn, args: [], loc: loc };
  } else {
    return {
      kind: "LoadLocal",
      place: {
        kind: "Identifier",
        identifier: fn.identifier,
        effect: exports.Effect.Unknown,
        reactive: false,
        loc: loc,
      },
      loc: loc,
    };
  }
}
function extractManualMemoizationArgs(instr, kind, sidemap) {
  const [fnPlace, depsListPlace] = instr.value.args;
  if (fnPlace == null) {
    CompilerError.throwInvalidReact({
      reason: `Expected ${kind} call to pass a callback function`,
      loc: instr.value.loc,
      suggestions: null,
    });
  }
  if (
    (fnPlace === null || fnPlace === void 0 ? void 0 : fnPlace.kind) !==
      "Identifier" ||
    (depsListPlace === null || depsListPlace === void 0
      ? void 0
      : depsListPlace.kind) === "Spread"
  ) {
    CompilerError.throwInvalidReact({
      reason: `Unexpected arguments to ${kind} call`,
      loc: instr.value.loc,
      suggestions: null,
    });
  }
  let depsList = null;
  if (depsListPlace != null) {
    const maybeDepsList = sidemap.maybeDepsLists.get(
      depsListPlace.identifier.id,
    );
    if (maybeDepsList == null) {
      CompilerError.throwInvalidReact({
        reason: `Expected the dependency list for ${kind} to be an array literal without rest spreads`,
        suggestions: null,
        loc: depsListPlace.loc,
      });
    }
    depsList = maybeDepsList.map((dep) => {
      const maybeDep = sidemap.maybeDeps.get(dep.identifier.id);
      if (maybeDep == null) {
        CompilerError.throwInvalidReact({
          reason: `Expected the dependency list for ${kind} to be an array of simple expressions`,
          suggestions: null,
          loc: dep.loc,
        });
      }
      return maybeDep;
    });
  }
  return { fnPlace: fnPlace, depsList: depsList };
}
function dropManualMemoization(func) {
  const isValidationEnabled =
    func.env.config.validatePreserveExistingMemoizationGuarantees ||
    func.env.config.enablePreserveExistingMemoizationGuarantees;
  const sidemap = {
    functions: new Map(),
    manualMemos: new Map(),
    react: new Set(),
    maybeDeps: new Map(),
    maybeDepsLists: new Map(),
  };
  let nextManualMemoId = 0;
  const queuedInserts = new Map();
  for (const [_, block] of func.body.blocks) {
    for (let i = 0; i < block.instructions.length; i++) {
      const instr = block.instructions[i];
      if (
        instr.value.kind === "CallExpression" ||
        instr.value.kind === "MethodCall"
      ) {
        const id =
          instr.value.kind === "CallExpression"
            ? instr.value.callee.identifier.id
            : instr.value.property.identifier.id;
        const manualMemo = sidemap.manualMemos.get(id);
        if (manualMemo != null) {
          const { fnPlace: fnPlace, depsList: depsList } =
            extractManualMemoizationArgs(instr, manualMemo.kind, sidemap);
          instr.value = getManualMemoizationReplacement(
            fnPlace,
            instr.value.loc,
            manualMemo.kind,
          );
          if (isValidationEnabled) {
            if (!sidemap.functions.has(fnPlace.identifier.id)) {
              CompilerError.throwInvalidReact({
                reason: `Expected the first argument of ${manualMemo.kind} to be an inline function expression`,
                suggestions: [],
                loc: fnPlace.loc,
              });
            }
            const memoDecl =
              manualMemo.kind === "useMemo"
                ? instr.lvalue
                : {
                    kind: "Identifier",
                    identifier: fnPlace.identifier,
                    effect: exports.Effect.Unknown,
                    reactive: false,
                    loc: fnPlace.loc,
                  };
            const [startMarker, finishMarker] = makeManualMemoizationMarkers(
              fnPlace,
              func.env,
              depsList,
              memoDecl,
              nextManualMemoId++,
            );
            queuedInserts.set(manualMemo.loadInstr.id, startMarker);
            queuedInserts.set(instr.id, finishMarker);
          }
        }
      } else {
        collectTemporaries(instr, func.env, sidemap);
      }
    }
  }
  if (queuedInserts.size > 0) {
    let hasChanges = false;
    for (const [_, block] of func.body.blocks) {
      let nextInstructions = null;
      for (let i = 0; i < block.instructions.length; i++) {
        const instr = block.instructions[i];
        const insertInstr = queuedInserts.get(instr.id);
        if (insertInstr != null) {
          nextInstructions =
            nextInstructions !== null && nextInstructions !== void 0
              ? nextInstructions
              : block.instructions.slice(0, i);
          nextInstructions.push(instr);
          nextInstructions.push(insertInstr);
        } else if (nextInstructions != null) {
          nextInstructions.push(instr);
        }
      }
      if (nextInstructions !== null) {
        block.instructions = nextInstructions;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      markInstructionIds(func.body);
    }
  }
}
function inferReactivePlaces(fn) {
  var _a;
  const reactiveIdentifiers = new ReactivityMap(findDisjointMutableValues(fn));
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    reactiveIdentifiers.markReactive(place);
  }
  const postDominators = computePostDominatorTree(fn, {
    includeThrowsAsExitNode: false,
  });
  const postDominatorFrontierCache = new Map();
  function isReactiveControlledBlock(id) {
    let controlBlocks = postDominatorFrontierCache.get(id);
    if (controlBlocks === undefined) {
      controlBlocks = postDominatorFrontier(fn, postDominators, id);
      postDominatorFrontierCache.set(id, controlBlocks);
    }
    for (const blockId of controlBlocks) {
      const controlBlock = fn.body.blocks.get(blockId);
      switch (controlBlock.terminal.kind) {
        case "if":
        case "branch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          break;
        }
        case "switch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          for (const case_ of controlBlock.terminal.cases) {
            if (
              case_.test !== null &&
              reactiveIdentifiers.isReactive(case_.test)
            ) {
              return true;
            }
          }
          break;
        }
      }
    }
    return false;
  }
  do {
    const identifierMapping = new Map();
    for (const [, block] of fn.body.blocks) {
      let hasReactiveControl = isReactiveControlledBlock(block.id);
      for (const phi of block.phis) {
        if (reactiveIdentifiers.isReactiveIdentifier(phi.id)) {
          continue;
        }
        let isPhiReactive = false;
        for (const [, operand] of phi.operands) {
          if (reactiveIdentifiers.isReactiveIdentifier(operand)) {
            isPhiReactive = true;
            break;
          }
        }
        if (isPhiReactive) {
          reactiveIdentifiers.markReactiveIdentifier(phi.id);
        } else {
          for (const [pred] of phi.operands) {
            if (isReactiveControlledBlock(pred)) {
              reactiveIdentifiers.markReactiveIdentifier(phi.id);
              break;
            }
          }
        }
      }
      for (const instruction of block.instructions) {
        const { value: value } = instruction;
        let hasReactiveInput = false;
        for (const operand of eachInstructionValueOperand(value)) {
          const reactive = reactiveIdentifiers.isReactive(operand);
          hasReactiveInput || (hasReactiveInput = reactive);
        }
        if (
          value.kind === "CallExpression" &&
          (getHookKind(fn.env, value.callee.identifier) != null ||
            isUseOperator(value.callee.identifier))
        ) {
          hasReactiveInput = true;
        } else if (
          value.kind === "MethodCall" &&
          (getHookKind(fn.env, value.property.identifier) != null ||
            isUseOperator(value.property.identifier))
        ) {
          hasReactiveInput = true;
        }
        if (hasReactiveInput) {
          for (const lvalue of eachInstructionLValue(instruction)) {
            if (isSetStateType(lvalue.identifier)) {
              continue;
            }
            reactiveIdentifiers.markReactive(lvalue);
          }
        }
        if (hasReactiveInput || hasReactiveControl) {
          for (const operand of eachInstructionValueOperand(value)) {
            switch (operand.effect) {
              case exports.Effect.Capture:
              case exports.Effect.Store:
              case exports.Effect.ConditionallyMutate:
              case exports.Effect.Mutate: {
                if (isMutable(instruction, operand)) {
                  const resolvedId = identifierMapping.get(operand.identifier);
                  if (resolvedId !== undefined) {
                    reactiveIdentifiers.markReactiveIdentifier(resolvedId);
                  }
                  reactiveIdentifiers.markReactive(operand);
                }
                break;
              }
              case exports.Effect.Freeze:
              case exports.Effect.Read: {
                break;
              }
              case exports.Effect.Unknown: {
                CompilerError.invariant(false, {
                  reason: "Unexpected unknown effect",
                  description: null,
                  loc: operand.loc,
                  suggestions: null,
                });
              }
              default: {
                assertExhaustive(
                  operand.effect,
                  `Unexpected effect kind '${operand.effect}'`,
                );
              }
            }
          }
        }
        switch (value.kind) {
          case "LoadLocal": {
            identifierMapping.set(
              instruction.lvalue.identifier,
              value.place.identifier,
            );
            break;
          }
          case "PropertyLoad":
          case "ComputedLoad": {
            const resolvedId =
              (_a = identifierMapping.get(value.object.identifier)) !== null &&
              _a !== void 0
                ? _a
                : value.object.identifier;
            identifierMapping.set(instruction.lvalue.identifier, resolvedId);
            break;
          }
          case "LoadContext": {
            identifierMapping.set(
              instruction.lvalue.identifier,
              value.place.identifier,
            );
            break;
          }
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        reactiveIdentifiers.isReactive(operand);
      }
    }
  } while (reactiveIdentifiers.snapshot());
}
function postDominatorFrontier(fn, postDominators, targetId) {
  const visited = new Set();
  const frontier = new Set();
  const targetPostDominators = postDominatorsOf(fn, postDominators, targetId);
  for (const blockId of [...targetPostDominators, targetId]) {
    if (visited.has(blockId)) {
      continue;
    }
    visited.add(blockId);
    const block = fn.body.blocks.get(blockId);
    for (const pred of block.preds) {
      if (!targetPostDominators.has(pred)) {
        frontier.add(pred);
      }
    }
  }
  return frontier;
}
function postDominatorsOf(fn, postDominators, targetId) {
  var _a;
  const result = new Set();
  const visited = new Set();
  const queue = [targetId];
  while (queue.length) {
    const currentId = queue.shift();
    if (visited.has(currentId)) {
      continue;
    }
    visited.add(currentId);
    const current = fn.body.blocks.get(currentId);
    for (const pred of current.preds) {
      const predPostDominator =
        (_a = postDominators.get(pred)) !== null && _a !== void 0 ? _a : pred;
      if (predPostDominator === targetId || result.has(predPostDominator)) {
        result.add(pred);
      }
      queue.push(pred);
    }
  }
  return result;
}
class ReactivityMap {
  constructor(aliasedIdentifiers) {
    this.hasChanges = false;
    this.reactive = new Set();
    this.aliasedIdentifiers = aliasedIdentifiers;
  }
  isReactive(place) {
    const reactive = this.isReactiveIdentifier(place.identifier);
    if (reactive) {
      place.reactive = true;
    }
    return reactive;
  }
  isReactiveIdentifier(inputIdentifier) {
    var _a;
    const identifier =
      (_a = this.aliasedIdentifiers.find(inputIdentifier)) !== null &&
      _a !== void 0
        ? _a
        : inputIdentifier;
    return this.reactive.has(identifier.id);
  }
  markReactive(place) {
    place.reactive = true;
    this.markReactiveIdentifier(place.identifier);
  }
  markReactiveIdentifier(inputIdentifier) {
    var _a;
    const identifier =
      (_a = this.aliasedIdentifiers.find(inputIdentifier)) !== null &&
      _a !== void 0
        ? _a
        : inputIdentifier;
    if (!this.reactive.has(identifier.id)) {
      this.hasChanges = true;
      this.reactive.add(identifier.id);
    }
  }
  snapshot() {
    const hasChanges = this.hasChanges;
    this.hasChanges = false;
    return hasChanges;
  }
}
function inlineImmediatelyInvokedFunctionExpressions(fn) {
  const functions = new Map();
  const inlinedFunctions = new Set();
  const queue = Array.from(fn.body.blocks.values());
  queue: for (const block of queue) {
    for (let ii = 0; ii < block.instructions.length; ii++) {
      const instr = block.instructions[ii];
      switch (instr.value.kind) {
        case "FunctionExpression": {
          if (instr.lvalue.identifier.name === null) {
            functions.set(instr.lvalue.identifier.id, instr.value);
          }
          break;
        }
        case "CallExpression": {
          if (instr.value.args.length !== 0) {
            continue;
          }
          const body = functions.get(instr.value.callee.identifier.id);
          if (body === undefined) {
            continue;
          }
          if (
            body.loweredFunc.func.params.length > 0 ||
            body.loweredFunc.func.async ||
            body.loweredFunc.func.generator
          ) {
            continue;
          }
          inlinedFunctions.add(instr.value.callee.identifier.id);
          const continuationBlockId = fn.env.nextBlockId;
          const continuationBlock = {
            id: continuationBlockId,
            instructions: block.instructions.slice(ii + 1),
            kind: block.kind,
            phis: new Set(),
            preds: new Set(),
            terminal: block.terminal,
          };
          fn.body.blocks.set(continuationBlockId, continuationBlock);
          block.instructions.length = ii;
          const newTerminal = {
            block: body.loweredFunc.func.body.entry,
            id: makeInstructionId(0),
            kind: "label",
            fallthrough: continuationBlockId,
            loc: block.terminal.loc,
          };
          block.terminal = newTerminal;
          const result = instr.lvalue;
          declareTemporary(fn.env, block, result);
          promoteTemporary(result.identifier);
          for (const [id, block] of body.loweredFunc.func.body.blocks) {
            block.preds.clear();
            rewriteBlock(fn.env, block, continuationBlockId, result);
            fn.body.blocks.set(id, block);
          }
          queue.push(continuationBlock);
          continue queue;
        }
        default: {
          for (const place of eachInstructionValueOperand(instr.value)) {
            functions.delete(place.identifier.id);
          }
        }
      }
    }
  }
  if (inlinedFunctions.size !== 0) {
    for (const [, block] of fn.body.blocks) {
      retainWhere(
        block.instructions,
        (instr) => !inlinedFunctions.has(instr.lvalue.identifier.id),
      );
    }
    reversePostorderBlocks(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
  }
}
function rewriteBlock(env, block, returnTarget, returnValue) {
  const { terminal: terminal } = block;
  if (terminal.kind !== "return") {
    return;
  }
  block.instructions.push({
    id: makeInstructionId(0),
    loc: terminal.loc,
    lvalue: {
      effect: exports.Effect.Unknown,
      identifier: {
        id: env.nextIdentifierId,
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0),
        },
        name: null,
        scope: null,
        type: makeType(),
      },
      kind: "Identifier",
      reactive: false,
      loc: terminal.loc,
    },
    value: {
      kind: "StoreLocal",
      lvalue: {
        kind: InstructionKind.Reassign,
        place: Object.assign({}, returnValue),
      },
      value: terminal.value,
      type: null,
      loc: terminal.loc,
    },
  });
  block.terminal = {
    kind: "goto",
    block: returnTarget,
    id: makeInstructionId(0),
    variant: GotoVariant.Break,
    loc: block.terminal.loc,
  };
}
function declareTemporary(env, block, result) {
  block.instructions.push({
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: {
      effect: exports.Effect.Unknown,
      identifier: {
        id: env.nextIdentifierId,
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0),
        },
        name: null,
        scope: null,
        type: makeType(),
      },
      kind: "Identifier",
      reactive: false,
      loc: GeneratedSource,
    },
    value: {
      kind: "DeclareLocal",
      lvalue: { place: result, kind: InstructionKind.Let },
      type: null,
      loc: result.loc,
    },
  });
}
function alignMethodCallScopes(fn) {
  const scopeMapping = new Map();
  const mergedScopes = new DisjointSet();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue: lvalue, value: value } = instr;
      if (value.kind === "MethodCall") {
        const lvalueScope = lvalue.identifier.scope;
        const propertyScope = value.property.identifier.scope;
        if (lvalueScope !== null) {
          if (propertyScope !== null) {
            mergedScopes.union([lvalueScope, propertyScope]);
          } else {
            scopeMapping.set(value.property.identifier.id, lvalueScope);
          }
        } else if (propertyScope !== null) {
          scopeMapping.set(value.property.identifier.id, null);
        }
      } else if (
        value.kind === "FunctionExpression" ||
        value.kind === "ObjectMethod"
      ) {
        alignMethodCallScopes(value.loweredFunc.func);
      }
    }
  }
  mergedScopes.forEach((scope, root) => {
    if (scope === root) {
      return;
    }
    root.range.start = makeInstructionId(
      Math.min(scope.range.start, root.range.start),
    );
    root.range.end = makeInstructionId(
      Math.max(scope.range.end, root.range.end),
    );
  });
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const mappedScope = scopeMapping.get(instr.lvalue.identifier.id);
      if (mappedScope !== undefined) {
        instr.lvalue.identifier.scope = mappedScope;
      } else if (instr.lvalue.identifier.scope !== null) {
        const mergedScope = mergedScopes.find(instr.lvalue.identifier.scope);
        if (mergedScope != null) {
          instr.lvalue.identifier.scope = mergedScope;
        }
      }
    }
  }
}
function alignReactiveScopesToBlockScopesHIR(fn) {
  var _a, _b, _c, _d;
  const blockNodes = new Map();
  const rootNode = {
    kind: "node",
    valueRange: null,
    children: [],
    id: makeInstructionId(0),
  };
  blockNodes.set(fn.body.entry, rootNode);
  const seen = new Set();
  const placeScopes = new Map();
  function recordPlace(id, place, node) {
    if (place.identifier.scope !== null) {
      placeScopes.set(place, place.identifier.scope);
    }
    const scope = getPlaceScope(id, place);
    if (scope == null) {
      return;
    }
    node.children.push({ kind: "scope", scope: scope, id: id });
    if (seen.has(scope)) {
      return;
    }
    seen.add(scope);
    if (node.valueRange !== null) {
      scope.range.start = makeInstructionId(
        Math.min(node.valueRange.start, scope.range.start),
      );
      scope.range.end = makeInstructionId(
        Math.max(node.valueRange.end, scope.range.end),
      );
    }
  }
  for (const [, block] of fn.body.blocks) {
    const { instructions: instructions, terminal: terminal } = block;
    const node = blockNodes.get(block.id);
    if (node === undefined) {
      CompilerError.invariant(false, {
        reason: `Expected a node to be initialized for block`,
        loc:
          (_b =
            (_a = instructions[0]) === null || _a === void 0
              ? void 0
              : _a.loc) !== null && _b !== void 0
            ? _b
            : terminal.loc,
        description: `No node for block bb${block.id} (${block.kind})`,
      });
    }
    for (const instr of instructions) {
      for (const lvalue of eachInstructionLValue(instr)) {
        recordPlace(instr.id, lvalue, node);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        recordPlace(instr.id, operand, node);
      }
    }
    for (const operand of eachTerminalOperand(terminal)) {
      recordPlace(terminal.id, operand, node);
    }
    const fallthrough = terminalFallthrough(terminal);
    if (fallthrough !== null && !blockNodes.has(fallthrough)) {
      const fallthroughBlock = fn.body.blocks.get(fallthrough);
      const nextId =
        (_d =
          (_c = fallthroughBlock.instructions[0]) === null || _c === void 0
            ? void 0
            : _c.id) !== null && _d !== void 0
          ? _d
          : fallthroughBlock.terminal.id;
      for (const child of node.children) {
        if (child.kind !== "scope") {
          continue;
        }
        const scope = child.scope;
        if (scope.range.end > terminal.id) {
          scope.range.end = makeInstructionId(
            Math.max(scope.range.end, nextId),
          );
        }
      }
      blockNodes.set(fallthrough, node);
    }
    mapTerminalSuccessors(terminal, (successor) => {
      var _a, _b;
      if (blockNodes.has(successor)) {
        return successor;
      }
      const successorBlock = fn.body.blocks.get(successor);
      if (successorBlock.kind === "block" || successorBlock.kind === "catch") {
        const childNode = {
          kind: "node",
          id: terminal.id,
          children: [],
          valueRange: null,
        };
        node.children.push(childNode);
        blockNodes.set(successor, childNode);
      } else if (
        node.valueRange === null ||
        terminal.kind === "ternary" ||
        terminal.kind === "logical" ||
        terminal.kind === "optional"
      ) {
        const childNode = {
          kind: "node",
          id: terminal.id,
          children: [],
          valueRange: null,
        };
        if (node.valueRange === null) {
          CompilerError.invariant(fallthrough !== null, {
            reason: `Expected a fallthrough for value block`,
            loc: terminal.loc,
          });
          const fallthroughBlock = fn.body.blocks.get(fallthrough);
          const nextId =
            (_b =
              (_a = fallthroughBlock.instructions[0]) === null || _a === void 0
                ? void 0
                : _a.id) !== null && _b !== void 0
              ? _b
              : fallthroughBlock.terminal.id;
          childNode.valueRange = { start: terminal.id, end: nextId };
        } else {
          childNode.valueRange = node.valueRange;
        }
        node.children.push(childNode);
        blockNodes.set(successor, childNode);
      } else {
        blockNodes.set(successor, node);
      }
      return successor;
    });
  }
  const joinedScopes = mergeOverlappingScopes(rootNode);
  joinedScopes.forEach((scope, groupScope) => {
    if (scope !== groupScope) {
      groupScope.range.start = makeInstructionId(
        Math.min(groupScope.range.start, scope.range.start),
      );
      groupScope.range.end = makeInstructionId(
        Math.max(groupScope.range.end, scope.range.end),
      );
    }
  });
  for (const [place, originalScope] of placeScopes) {
    const nextScope = joinedScopes.find(originalScope);
    if (nextScope !== null && nextScope !== originalScope) {
      place.identifier.scope = nextScope;
    }
  }
}
class BlockItem {
  constructor() {
    this.seen = new Set();
    this.scopes = [];
  }
}
function mergeOverlappingScopes(root) {
  const seen = new Set();
  const joined = new DisjointSet();
  function visit(node, stack) {
    const currentBlock = stack.at(-1);
    child: for (const child of node.children) {
      retainWhere(currentBlock.scopes, (item) => {
        if (item.scope.range.end > child.id) {
          return true;
        } else {
          currentBlock.seen.delete(item.scope);
          return false;
        }
      });
      if (child.kind === "node") {
        visit(child, [...stack, new BlockItem()]);
      } else {
        const scope = child.scope;
        if (!seen.has(scope)) {
          seen.add(scope);
          currentBlock.seen.add(scope);
          currentBlock.scopes.push({ shadowedBy: null, scope: scope });
          continue;
        }
        let index = stack.length - 1;
        let nextBlock = currentBlock;
        while (!nextBlock.seen.has(scope)) {
          joined.union([scope, ...nextBlock.scopes.map((s) => s.scope)]);
          index--;
          if (index < 0) {
            currentBlock.seen.add(scope);
            currentBlock.scopes.push({ shadowedBy: null, scope: scope });
            continue child;
          }
          nextBlock = stack[index];
        }
        let found = false;
        for (let i = 0; i < nextBlock.scopes.length; i++) {
          const current = nextBlock.scopes[i];
          if (current.scope.id === scope.id) {
            found = true;
            if (current.shadowedBy !== null) {
              joined.union([current.shadowedBy, current.scope]);
            }
          } else if (found && current.shadowedBy === null) {
            current.shadowedBy = scope;
            if (current.scope.range.end > scope.range.end) {
              const end = makeInstructionId(
                Math.max(current.scope.range.end, scope.range.end),
              );
              current.scope.range.end = end;
              scope.range.end = end;
              joined.union([current.scope, scope]);
            }
          }
        }
        if (!currentBlock.seen.has(scope)) {
          currentBlock.seen.add(scope);
          currentBlock.scopes.push({ shadowedBy: null, scope: scope });
        }
      }
    }
  }
  visit(root, [new BlockItem()]);
  return joined;
}
function pruneAlwaysInvalidatingScopes(fn) {
  visitReactiveFunction(fn, new Transform(), false);
}
class Transform extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.alwaysInvalidatingValues = new Set();
    this.unmemoizedValues = new Set();
  }
  transformInstruction(instruction, withinScope) {
    this.visitInstruction(instruction, withinScope);
    const { lvalue: lvalue, value: value } = instruction;
    switch (value.kind) {
      case "ArrayExpression":
      case "ObjectExpression":
      case "JsxExpression":
      case "JsxFragment":
      case "NewExpression": {
        if (lvalue !== null) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
          if (!withinScope) {
            this.unmemoizedValues.add(lvalue.identifier);
          }
        }
        break;
      }
      case "StoreLocal": {
        if (this.alwaysInvalidatingValues.has(value.value.identifier)) {
          this.alwaysInvalidatingValues.add(value.lvalue.place.identifier);
        }
        if (this.unmemoizedValues.has(value.value.identifier)) {
          this.unmemoizedValues.add(value.lvalue.place.identifier);
        }
        break;
      }
      case "LoadLocal": {
        if (
          lvalue !== null &&
          this.alwaysInvalidatingValues.has(value.place.identifier)
        ) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
        }
        if (
          lvalue !== null &&
          this.unmemoizedValues.has(value.place.identifier)
        ) {
          this.unmemoizedValues.add(lvalue.identifier);
        }
        break;
      }
    }
    return { kind: "keep" };
  }
  transformScope(scopeBlock, _withinScope) {
    this.visitScope(scopeBlock, true);
    for (const dep of scopeBlock.scope.dependencies) {
      if (this.unmemoizedValues.has(dep.identifier)) {
        for (const [_, decl] of scopeBlock.scope.declarations) {
          if (this.alwaysInvalidatingValues.has(decl.identifier)) {
            this.unmemoizedValues.add(decl.identifier);
          }
        }
        for (const identifier of scopeBlock.scope.reassignments) {
          if (this.alwaysInvalidatingValues.has(identifier)) {
            this.unmemoizedValues.add(identifier);
          }
        }
        return { kind: "replace-many", value: scopeBlock.instructions };
      }
    }
    return { kind: "keep" };
  }
}
function isPrimitiveBinaryOp(op) {
  switch (op) {
    case "+":
    case "-":
    case "/":
    case "%":
    case "*":
    case "**":
    case "&":
    case "|":
    case ">>":
    case "<<":
    case "^":
    case ">":
    case "<":
    case ">=":
    case "<=":
    case "|>":
      return true;
    default:
      return false;
  }
}
function inferTypes(func) {
  const unifier = new Unifier(func.env);
  for (const e of generate(func)) {
    unifier.unify(e.left, e.right);
  }
  apply(func, unifier);
}
function apply(func, unifier) {
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      phi.type = unifier.get(phi.type);
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        operand.identifier.type = unifier.get(operand.identifier.type);
      }
      for (const place of eachInstructionOperand(instr)) {
        place.identifier.type = unifier.get(place.identifier.type);
      }
      const { lvalue: lvalue, value: value } = instr;
      lvalue.identifier.type = unifier.get(lvalue.identifier.type);
      if (
        value.kind === "FunctionExpression" ||
        value.kind === "ObjectMethod"
      ) {
        apply(value.loweredFunc.func, unifier);
      }
    }
  }
}
function equation(left, right) {
  return { left: left, right: right };
}
function* generate(func) {
  if (func.env.fnType === "Component") {
    const [_, ref] = func.params;
    if (ref && ref.kind === "Identifier") {
      yield equation(ref.identifier.type, {
        kind: "Object",
        shapeId: BuiltInUseRefId,
      });
    }
  }
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      yield equation(phi.type, {
        kind: "Phi",
        operands: [...phi.operands.values()].map((id) => id.type),
      });
    }
    for (const instr of block.instructions) {
      yield* generateInstructionTypes(func.env, instr);
    }
  }
}
function* generateInstructionTypes(env, instr) {
  const { lvalue: lvalue, value: value } = instr;
  const left = lvalue.identifier.type;
  switch (value.kind) {
    case "TemplateLiteral":
    case "JSXText":
    case "Primitive": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "UnaryExpression": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadLocal": {
      yield equation(left, value.place.identifier.type);
      break;
    }
    case "DeclareContext":
    case "StoreContext":
    case "LoadContext": {
      break;
    }
    case "StoreLocal": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type,
        );
        const valueType =
          value.type === null ? makeType() : lowerType(value.type);
        yield equation(valueType, value.lvalue.place.identifier.type);
        yield equation(left, valueType);
      } else {
        yield equation(left, value.value.identifier.type);
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type,
        );
      }
      break;
    }
    case "BinaryExpression": {
      if (isPrimitiveBinaryOp(value.operator)) {
        yield equation(value.left.identifier.type, { kind: "Primitive" });
        yield equation(value.right.identifier.type, { kind: "Primitive" });
      }
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield equation(value.value.identifier.type, { kind: "Primitive" });
      yield equation(value.lvalue.identifier.type, { kind: "Primitive" });
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadGlobal": {
      const globalType = env.getGlobalDeclaration(value.name);
      if (globalType) {
        yield equation(left, globalType);
      }
      break;
    }
    case "CallExpression": {
      yield equation(value.callee.identifier.type, {
        kind: "Function",
        shapeId: null,
        return: left,
      });
      break;
    }
    case "ObjectExpression": {
      for (const property of value.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          yield equation(property.key.name.identifier.type, {
            kind: "Primitive",
          });
        }
      }
      yield equation(left, { kind: "Object", shapeId: BuiltInObjectId });
      break;
    }
    case "ArrayExpression": {
      yield equation(left, { kind: "Object", shapeId: BuiltInArrayId });
      break;
    }
    case "PropertyLoad": {
      yield equation(left, {
        kind: "Property",
        object: value.object.identifier.type,
        propertyName: value.property,
      });
      break;
    }
    case "MethodCall": {
      const returnType = makeType();
      yield equation(value.property.identifier.type, {
        kind: "Function",
        return: returnType,
        shapeId: null,
      });
      yield equation(left, returnType);
      break;
    }
    case "Destructure": {
      const pattern = value.lvalue.pattern;
      if (pattern.kind === "ArrayPattern") {
        for (let i = 0; i < pattern.items.length; i++) {
          const item = pattern.items[i];
          if (item.kind === "Identifier") {
            const propertyName = String(i);
            yield equation(item.identifier.type, {
              kind: "Property",
              object: value.value.identifier.type,
              propertyName: propertyName,
            });
          } else {
            break;
          }
        }
      } else {
        for (const property of pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (
              property.key.kind === "identifier" ||
              property.key.kind === "string"
            ) {
              yield equation(property.place.identifier.type, {
                kind: "Property",
                object: value.value.identifier.type,
                propertyName: property.key.name,
              });
            }
          }
        }
      }
      break;
    }
    case "TypeCastExpression": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(value.type, value.value.identifier.type);
        yield equation(left, value.type);
      } else {
        yield equation(left, value.value.identifier.type);
      }
      break;
    }
    case "PropertyDelete":
    case "ComputedDelete": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "FunctionExpression": {
      yield* generate(value.loweredFunc.func);
      break;
    }
    case "NextPropertyOf": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "ObjectMethod": {
      yield* generate(value.loweredFunc.func);
      yield equation(left, { kind: "ObjectMethod" });
      break;
    }
    case "DeclareLocal":
    case "NewExpression":
    case "JsxExpression":
    case "JsxFragment":
    case "RegExpLiteral":
    case "PropertyStore":
    case "ComputedStore":
    case "ComputedLoad":
    case "TaggedTemplateExpression":
    case "Await":
    case "NextIterableOf":
    case "UnsupportedNode":
    case "Debugger":
    case "FinishMemoize":
    case "StartMemoize": {
      break;
    }
    default:
      assertExhaustive(value, `Unhandled instruction value kind: ${value}`);
  }
}
class Unifier {
  constructor(env) {
    this.substitutions = new Map();
    this.env = env;
  }
  unify(tA, tB) {
    if (tB.kind === "Property") {
      const objectType = this.get(tB.object);
      const propertyType = this.env.getPropertyType(
        objectType,
        tB.propertyName,
      );
      if (propertyType !== null) {
        this.unify(tA, propertyType);
      }
      return;
    }
    if (typeEquals(tA, tB)) {
      return;
    }
    if (tA.kind === "Type") {
      this.bindVariableTo(tA, tB);
      return;
    }
    if (tB.kind === "Type") {
      this.bindVariableTo(tB, tA);
      return;
    }
    if (tB.kind === "Function" && tA.kind === "Function") {
      this.unify(tA.return, tB.return);
      return;
    }
  }
  bindVariableTo(v, type) {
    if (type.kind === "Poly") {
      return;
    }
    if (this.substitutions.has(v.id)) {
      this.unify(this.substitutions.get(v.id), type);
      return;
    }
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      this.unify(v, this.substitutions.get(type.id));
      return;
    }
    if (type.kind === "Phi") {
      const operands = new Set(type.operands.map((i) => this.get(i).kind));
      CompilerError.invariant(operands.size > 0, {
        reason: "there should be at least one operand",
        description: null,
        loc: null,
        suggestions: null,
      });
      const kind = operands.values().next().value;
      if (operands.size === 1 && kind !== "Type") {
        this.unify(v, type.operands[0]);
        return;
      }
    }
    if (this.occursCheck(v, type)) {
      throw new Error("cycle detected");
    }
    this.substitutions.set(v.id, type);
  }
  occursCheck(v, type) {
    if (typeEquals(v, type)) return true;
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      return this.occursCheck(v, this.substitutions.get(type.id));
    }
    if (type.kind === "Phi") {
      return type.operands.some((o) => this.occursCheck(v, o));
    }
    if (type.kind === "Function") {
      return this.occursCheck(v, type.return);
    }
    return false;
  }
  get(type) {
    if (type.kind === "Type") {
      if (this.substitutions.has(type.id)) {
        return this.get(this.substitutions.get(type.id));
      }
    }
    if (type.kind === "Phi") {
      return { kind: "Phi", operands: type.operands.map((o) => this.get(o)) };
    }
    return type;
  }
}
function validateContextVariableLValues(fn) {
  const identifierKinds = new Map();
  validateContextVariableLValuesImpl(fn, identifierKinds);
}
function validateContextVariableLValuesImpl(fn, identifierKinds) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value: value } = instr;
      switch (value.kind) {
        case "DeclareContext":
        case "StoreContext": {
          visit(identifierKinds, value.lvalue.place, "context");
          break;
        }
        case "LoadContext": {
          visit(identifierKinds, value.place, "context");
          break;
        }
        case "StoreLocal":
        case "DeclareLocal": {
          visit(identifierKinds, value.lvalue.place, "local");
          break;
        }
        case "LoadLocal": {
          visit(identifierKinds, value.place, "local");
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          visit(identifierKinds, value.lvalue, "local");
          break;
        }
        case "Destructure": {
          for (const lvalue of eachPatternOperand(value.lvalue.pattern)) {
            visit(identifierKinds, lvalue, "destructure");
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          validateContextVariableLValuesImpl(
            value.loweredFunc.func,
            identifierKinds,
          );
          break;
        }
        default: {
          for (const _ of eachInstructionValueLValue(value)) {
            CompilerError.throwTodo({
              reason:
                "ValidateContextVariableLValues: unhandled instruction variant",
              loc: value.loc,
              description: `Handle '${value.kind} lvalues`,
              suggestions: null,
            });
          }
        }
      }
    }
  }
}
function visit(identifiers, place, kind) {
  const prev = identifiers.get(place.identifier.id);
  if (prev !== undefined) {
    const wasContext = prev.kind === "context";
    const isContext = kind === "context";
    if (wasContext !== isContext) {
      if (prev.kind === "destructure" || kind === "destructure") {
        CompilerError.throwTodo({
          reason: `Support destructuring of context variables`,
          loc: kind === "destructure" ? place.loc : prev.place.loc,
          description: null,
          suggestions: null,
        });
      }
      CompilerError.invariant(false, {
        reason: `Expected all references to a variable to be consistently local or context references`,
        loc: place.loc,
        description: `Identifier ${printPlace(place)} is referenced as a ${kind} variable, but was previously referenced as a ${prev} variable`,
        suggestions: null,
      });
    }
  }
  identifiers.set(place.identifier.id, { place: place, kind: kind });
}
function computeUnconditionalBlocks(fn) {
  const unconditionalBlocks = new Set();
  const dominators = computePostDominatorTree(fn, {
    includeThrowsAsExitNode: false,
  });
  const exit = dominators.exit;
  let current = fn.body.entry;
  while (current !== null && current !== exit) {
    CompilerError.invariant(!unconditionalBlocks.has(current), {
      reason:
        "Internal error: non-terminating loop in ComputeUnconditionalBlocks",
      loc: null,
      suggestions: null,
    });
    unconditionalBlocks.add(current);
    current = dominators.get(current);
  }
  return unconditionalBlocks;
}
var Kind;
(function (Kind) {
  Kind["Error"] = "Error";
  Kind["KnownHook"] = "KnownHook";
  Kind["PotentialHook"] = "PotentialHook";
  Kind["Global"] = "Global";
  Kind["Local"] = "Local";
})(Kind || (Kind = {}));
function joinKinds(a, b) {
  if (a === Kind.Error || b === Kind.Error) {
    return Kind.Error;
  } else if (a === Kind.KnownHook || b === Kind.KnownHook) {
    return Kind.KnownHook;
  } else if (a === Kind.PotentialHook || b === Kind.PotentialHook) {
    return Kind.PotentialHook;
  } else if (a === Kind.Global || b === Kind.Global) {
    return Kind.Global;
  } else {
    return Kind.Local;
  }
}
function validateHooksUsage(fn) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  const errors = new CompilerError();
  const errorsByPlace = new Map();
  function recordError(loc, errorDetail) {
    if (typeof loc === "symbol") {
      errors.pushErrorDetail(errorDetail);
    } else {
      errorsByPlace.set(loc, errorDetail);
    }
  }
  function recordConditionalHookError(place) {
    setKind(place, Kind.Error);
    const reason =
      "Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)";
    const previousError =
      typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : undefined;
    if (previousError === undefined || previousError.reason !== reason) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          description: null,
          reason:
            "Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
          loc: place.loc,
          severity: exports.ErrorSeverity.InvalidReact,
          suggestions: null,
        }),
      );
    }
  }
  function recordInvalidHookUsageError(place) {
    const previousError =
      typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : undefined;
    if (previousError === undefined) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          description: null,
          reason:
            "Hooks may not be referenced as normal values, they must be called. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
          loc: place.loc,
          severity: exports.ErrorSeverity.InvalidReact,
          suggestions: null,
        }),
      );
    }
  }
  const valueKinds = new Map();
  function getKindForPlace(place) {
    const knownKind = valueKinds.get(place.identifier.id);
    if (
      place.identifier.name !== null &&
      isHookName$1(place.identifier.name.value)
    ) {
      return joinKinds(
        knownKind !== null && knownKind !== void 0 ? knownKind : Kind.Local,
        Kind.PotentialHook,
      );
    } else {
      return knownKind !== null && knownKind !== void 0
        ? knownKind
        : Kind.Local;
    }
  }
  function visitPlace(place) {
    const kind = valueKinds.get(place.identifier.id);
    if (kind === Kind.KnownHook) {
      recordInvalidHookUsageError(place);
    }
  }
  function setKind(place, kind) {
    valueKinds.set(place.identifier.id, kind);
  }
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    const kind = getKindForPlace(place);
    setKind(place, kind);
  }
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let kind =
        phi.id.name !== null && isHookName$1(phi.id.name.value)
          ? Kind.PotentialHook
          : Kind.Local;
      for (const [, operand] of phi.operands) {
        const operandKind = valueKinds.get(operand.id);
        if (operandKind !== undefined) {
          kind = joinKinds(kind, operandKind);
        }
      }
      valueKinds.set(phi.id.id, kind);
    }
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadGlobal": {
          if (getHookKind(fn.env, instr.lvalue.identifier) != null) {
            setKind(instr.lvalue, Kind.KnownHook);
          } else {
            setKind(instr.lvalue, Kind.Global);
          }
          break;
        }
        case "LoadContext":
        case "LoadLocal": {
          visitPlace(instr.value.place);
          const kind = getKindForPlace(instr.value.place);
          setKind(instr.lvalue, kind);
          break;
        }
        case "StoreLocal":
        case "StoreContext": {
          visitPlace(instr.value.value);
          const kind = getKindForPlace(instr.value.value);
          setKind(instr.value.lvalue.place, kind);
          setKind(instr.lvalue, kind);
          break;
        }
        case "ComputedLoad": {
          visitPlace(instr.value.object);
          const kind = getKindForPlace(instr.value.object);
          setKind(instr.lvalue, joinKinds(getKindForPlace(instr.lvalue), kind));
          break;
        }
        case "PropertyLoad": {
          const objectKind = getKindForPlace(instr.value.object);
          const isHookProperty = isHookName$1(instr.value.property);
          let kind;
          switch (objectKind) {
            case Kind.Error: {
              kind = Kind.Error;
              break;
            }
            case Kind.KnownHook: {
              kind = isHookProperty ? Kind.KnownHook : Kind.Local;
              break;
            }
            case Kind.PotentialHook: {
              kind = Kind.PotentialHook;
              break;
            }
            case Kind.Global: {
              kind = isHookProperty ? Kind.KnownHook : Kind.Global;
              break;
            }
            case Kind.Local: {
              kind = isHookProperty ? Kind.PotentialHook : Kind.Local;
              break;
            }
            default: {
              assertExhaustive(objectKind, `Unexpected kind '${objectKind}'`);
            }
          }
          setKind(instr.lvalue, kind);
          break;
        }
        case "CallExpression": {
          const calleeKind = getKindForPlace(instr.value.callee);
          const isHookCallee =
            calleeKind === Kind.KnownHook || calleeKind === Kind.PotentialHook;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.callee);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.callee) {
              continue;
            }
            visitPlace(operand);
          }
          break;
        }
        case "MethodCall": {
          const calleeKind = getKindForPlace(instr.value.property);
          const isHookCallee =
            calleeKind === Kind.KnownHook || calleeKind === Kind.PotentialHook;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.property);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.property) {
              continue;
            }
            visitPlace(operand);
          }
          break;
        }
        case "Destructure": {
          visitPlace(instr.value.value);
          const objectKind = getKindForPlace(instr.value.value);
          for (const lvalue of eachInstructionLValue(instr)) {
            const isHookProperty =
              lvalue.identifier.name !== null &&
              isHookName$1(lvalue.identifier.name.value);
            let kind;
            switch (objectKind) {
              case Kind.Error: {
                kind = Kind.Error;
                break;
              }
              case Kind.KnownHook: {
                kind = Kind.KnownHook;
                break;
              }
              case Kind.PotentialHook: {
                kind = Kind.PotentialHook;
                break;
              }
              case Kind.Global: {
                kind = isHookProperty ? Kind.KnownHook : Kind.Global;
                break;
              }
              case Kind.Local: {
                kind = isHookProperty ? Kind.PotentialHook : Kind.Local;
                break;
              }
              default: {
                assertExhaustive(objectKind, `Unexpected kind '${objectKind}'`);
              }
            }
            setKind(lvalue, kind);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        default: {
          for (const operand of eachInstructionOperand(instr)) {
            visitPlace(operand);
          }
          for (const lvalue of eachInstructionLValue(instr)) {
            const kind = getKindForPlace(lvalue);
            setKind(lvalue, kind);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitPlace(operand);
    }
  }
  for (const [, error] of errorsByPlace) {
    errors.push(error);
  }
  if (errors.hasErrors()) {
    throw errors;
  }
}
function visitFunctionExpression(errors, fn) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee =
            instr.value.kind === "CallExpression"
              ? instr.value.callee
              : instr.value.property;
          const hookKind = getHookKind(fn.env, callee.identifier);
          if (hookKind != null) {
            errors.pushErrorDetail(
              new CompilerErrorDetail({
                severity: exports.ErrorSeverity.InvalidReact,
                reason:
                  "Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
                loc: callee.loc,
                description: `Cannot call ${hookKind} within a function component`,
                suggestions: null,
              }),
            );
          }
          break;
        }
      }
    }
  }
}
function validateNoCapitalizedCalls(fn) {
  var _a;
  const envConfig = fn.env.config;
  const ALLOW_LIST = new Set([
    ...DEFAULT_GLOBALS.keys(),
    ...((_a = envConfig.validateNoCapitalizedCalls) !== null && _a !== void 0
      ? _a
      : []),
  ]);
  const hookPattern =
    envConfig.hookPattern != null ? new RegExp(envConfig.hookPattern) : null;
  const isAllowed = (name) =>
    ALLOW_LIST.has(name) || (hookPattern != null && hookPattern.test(name));
  const capitalLoadGlobals = new Map();
  const capitalizedProperties = new Map();
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (
            value.name != "" &&
            /^[A-Z]/.test(value.name) &&
            !(value.name.toUpperCase() === value.name) &&
            !isAllowed(value.name)
          ) {
            capitalLoadGlobals.set(lvalue.identifier.id, value.name);
          }
          break;
        }
        case "CallExpression": {
          const calleeIdentifier = value.callee.identifier.id;
          const calleeName = capitalLoadGlobals.get(calleeIdentifier);
          if (calleeName != null) {
            CompilerError.throwInvalidReact({
              reason: `Capitalized function calls may be calling components that use hooks, which make them dangerous to memoize. Ensure there are no hook calls in the function and rename it to begin with a lowercase letter to fix this error`,
              description: `${calleeName} may be a component.`,
              loc: value.loc,
              suggestions: null,
            });
          }
          break;
        }
        case "PropertyLoad": {
          if (/^[A-Z]/.test(value.property)) {
            capitalizedProperties.set(lvalue.identifier.id, value.property);
          }
          break;
        }
        case "MethodCall": {
          const propertyIdentifier = value.property.identifier.id;
          const propertyName = capitalizedProperties.get(propertyIdentifier);
          if (propertyName != null) {
            CompilerError.throwInvalidReact({
              reason: `Capitalized method calls may be calling components that use hooks, which make them dangerous to memoize. Ensure there are no hook calls in the function and rename it to begin with a lowercase letter to fix this error`,
              description: `${propertyName} may be a component.`,
              loc: value.loc,
              suggestions: null,
            });
          }
          break;
        }
      }
    }
  }
}
function validateNoRefAccessInRender(fn) {
  const refAccessingFunctions = new Set();
  validateNoRefAccessInRenderImpl(fn, refAccessingFunctions).unwrap();
}
function validateNoRefAccessInRenderImpl(fn, refAccessingFunctions) {
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "JsxExpression":
        case "JsxFragment": {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            if (isRefValueType(operand.identifier)) {
              errors.push({
                severity: exports.ErrorSeverity.InvalidReact,
                reason:
                  "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
                loc: operand.loc,
                description: `Cannot access ref value at ${printPlace(operand)}`,
                suggestions: null,
              });
            }
          }
          break;
        }
        case "PropertyLoad": {
          break;
        }
        case "LoadLocal": {
          if (refAccessingFunctions.has(instr.value.place.identifier.id)) {
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "StoreLocal": {
          if (refAccessingFunctions.has(instr.value.value.identifier.id)) {
            refAccessingFunctions.add(instr.value.lvalue.place.identifier.id);
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          if (
            [...eachInstructionValueOperand(instr.value)].some(
              (operand) =>
                isRefValueType(operand.identifier) ||
                refAccessingFunctions.has(operand.identifier.id),
            ) ||
            ([...eachInstructionValueOperand(instr.value)].some((operand) =>
              isUseRefType(operand.identifier),
            ) &&
              validateNoRefAccessInRenderImpl(
                instr.value.loweredFunc.func,
                refAccessingFunctions,
              ).isErr())
          ) {
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "CallExpression": {
          const callee = instr.value.callee;
          if (refAccessingFunctions.has(callee.identifier.id)) {
            errors.push({
              severity: exports.ErrorSeverity.InvalidReact,
              reason:
                "This function accesses a ref, which not be accessed during render. (https://react.dev/reference/react/useRef)",
              loc: callee.loc,
              description: `Function ${printPlace(callee)} accesses a ref`,
              suggestions: null,
            });
          }
          for (const operand of eachInstructionValueOperand(instr.value)) {
            validateNoRefAccess(errors, refAccessingFunctions, operand);
          }
          break;
        }
        case "ObjectExpression":
        case "ArrayExpression":
        case "MethodCall": {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            validateNoRefAccess(errors, refAccessingFunctions, operand);
          }
          break;
        }
        default: {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            validateNoRefValueAccess(errors, refAccessingFunctions, operand);
          }
          break;
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      validateNoRefValueAccess(errors, refAccessingFunctions, operand);
    }
  }
  if (errors.hasErrors()) {
    return Err(errors);
  } else {
    return Ok(undefined);
  }
}
function validateNoRefValueAccess(
  errors,
  unconditionalSetStateFunctions,
  operand,
) {
  if (
    isRefValueType(operand.identifier) ||
    unconditionalSetStateFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      severity: exports.ErrorSeverity.InvalidReact,
      reason:
        "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
      loc: operand.loc,
      description: `Cannot access ref value at ${printPlace(operand)}`,
      suggestions: null,
    });
  }
}
function validateNoRefAccess(errors, unconditionalSetStateFunctions, operand) {
  if (
    isRefValueType(operand.identifier) ||
    isUseRefType(operand.identifier) ||
    unconditionalSetStateFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      severity: exports.ErrorSeverity.InvalidReact,
      reason:
        "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
      loc: operand.loc,
      description: `Cannot access ref value at ${printPlace(operand)}`,
      suggestions: null,
    });
  }
}
function validateNoSetStateInRender(fn) {
  const unconditionalSetStateFunctions = new Set();
  validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions).unwrap();
}
function validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    if (unconditionalBlocks.has(block.id)) {
      for (const instr of block.instructions) {
        switch (instr.value.kind) {
          case "LoadLocal": {
            if (
              unconditionalSetStateFunctions.has(
                instr.value.place.identifier.id,
              )
            ) {
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "StoreLocal": {
            if (
              unconditionalSetStateFunctions.has(
                instr.value.value.identifier.id,
              )
            ) {
              unconditionalSetStateFunctions.add(
                instr.value.lvalue.place.identifier.id,
              );
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "ObjectMethod":
          case "FunctionExpression": {
            if (
              [...eachInstructionValueOperand(instr.value)].some(
                (operand) =>
                  isSetStateType(operand.identifier) ||
                  unconditionalSetStateFunctions.has(operand.identifier.id),
              ) &&
              validateNoSetStateInRenderImpl(
                instr.value.loweredFunc.func,
                unconditionalSetStateFunctions,
              ).isErr()
            ) {
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "CallExpression": {
            validateNonSetState(
              errors,
              unconditionalSetStateFunctions,
              instr.value.callee,
            );
            break;
          }
        }
      }
    }
  }
  if (errors.hasErrors()) {
    return Err(errors);
  } else {
    return Ok(undefined);
  }
}
function validateNonSetState(errors, unconditionalSetStateFunctions, operand) {
  if (
    isSetStateType(operand.identifier) ||
    unconditionalSetStateFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      reason:
        "This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState)",
      description: null,
      severity: exports.ErrorSeverity.InvalidReact,
      loc: typeof operand.loc !== "symbol" ? operand.loc : null,
      suggestions: null,
    });
  }
}
function validatePreservedManualMemoization(fn) {
  const state = { errors: new CompilerError(), manualMemoState: null };
  visitReactiveFunction(fn, new Visitor(), state);
  if (state.errors.hasErrors()) {
    throw state.errors;
  }
}
function prettyPrintScopeDependency(val) {
  var _a;
  let rootStr;
  if (
    ((_a = val.identifier.name) === null || _a === void 0
      ? void 0
      : _a.kind) === "named"
  ) {
    rootStr = val.identifier.name.value;
  } else {
    rootStr = "[unnamed]";
  }
  return `${rootStr}${val.path.length > 0 ? "." : ""}${val.path.join(".")}`;
}
var CompareDependencyResult;
(function (CompareDependencyResult) {
  CompareDependencyResult[(CompareDependencyResult["Ok"] = 0)] = "Ok";
  CompareDependencyResult[(CompareDependencyResult["RootDifference"] = 1)] =
    "RootDifference";
  CompareDependencyResult[(CompareDependencyResult["PathDifference"] = 2)] =
    "PathDifference";
  CompareDependencyResult[(CompareDependencyResult["Subpath"] = 3)] = "Subpath";
  CompareDependencyResult[
    (CompareDependencyResult["RefAccessDifference"] = 4)
  ] = "RefAccessDifference";
})(CompareDependencyResult || (CompareDependencyResult = {}));
function merge(a, b) {
  return Math.max(a, b);
}
function getCompareDependencyResultDescription(result) {
  switch (result) {
    case CompareDependencyResult.Ok:
      return "dependencies equal";
    case CompareDependencyResult.RootDifference:
    case CompareDependencyResult.PathDifference:
      return "inferred different dependency than source";
    case CompareDependencyResult.RefAccessDifference:
      return "differences in ref.current access";
    case CompareDependencyResult.Subpath:
      return "inferred less specific property than source";
  }
}
function compareDeps(inferred, source) {
  const rootsEqual =
    (inferred.root.kind === "Global" &&
      source.root.kind === "Global" &&
      inferred.root.identifierName === source.root.identifierName) ||
    (inferred.root.kind === "NamedLocal" &&
      source.root.kind === "NamedLocal" &&
      inferred.root.value.identifier.id === source.root.value.identifier.id);
  if (!rootsEqual) {
    return CompareDependencyResult.RootDifference;
  }
  let isSubpath = true;
  for (let i = 0; i < Math.min(inferred.path.length, source.path.length); i++) {
    if (inferred.path[i] !== source.path[i]) {
      isSubpath = false;
      break;
    }
  }
  if (
    isSubpath &&
    (source.path.length === inferred.path.length ||
      (inferred.path.length >= source.path.length &&
        !inferred.path.includes("current")))
  ) {
    return CompareDependencyResult.Ok;
  } else {
    if (isSubpath) {
      if (
        source.path.includes("current") ||
        inferred.path.includes("current")
      ) {
        return CompareDependencyResult.RefAccessDifference;
      } else {
        return CompareDependencyResult.Subpath;
      }
    } else {
      return CompareDependencyResult.PathDifference;
    }
  }
}
function validateInferredDep(
  dep,
  temporaries,
  declsWithinMemoBlock,
  validDepsInMemoBlock,
  errorState,
) {
  var _a;
  let normalizedDep;
  const maybeNormalizedRoot = temporaries.get(dep.identifier.id);
  if (maybeNormalizedRoot != null) {
    normalizedDep = {
      root: maybeNormalizedRoot.root,
      path: [...maybeNormalizedRoot.path, ...dep.path],
    };
  } else {
    CompilerError.invariant(
      ((_a = dep.identifier.name) === null || _a === void 0
        ? void 0
        : _a.kind) === "named",
      {
        reason:
          "ValidatePreservedManualMemoization: expected scope dependency to be named",
        loc: GeneratedSource,
        suggestions: null,
      },
    );
    normalizedDep = {
      root: {
        kind: "NamedLocal",
        value: {
          kind: "Identifier",
          identifier: dep.identifier,
          loc: GeneratedSource,
          effect: exports.Effect.Read,
          reactive: false,
        },
      },
      path: [...dep.path],
    };
  }
  for (const decl of declsWithinMemoBlock) {
    if (
      normalizedDep.root.kind === "NamedLocal" &&
      decl === normalizedDep.root.value.identifier.id
    ) {
      return;
    }
  }
  let errorDiagnostic = null;
  for (const originalDep of validDepsInMemoBlock) {
    const compareResult = compareDeps(normalizedDep, originalDep);
    if (compareResult === CompareDependencyResult.Ok) {
      return;
    } else {
      errorDiagnostic = merge(
        errorDiagnostic !== null && errorDiagnostic !== void 0
          ? errorDiagnostic
          : compareResult,
        compareResult,
      );
    }
  }
  errorState.push({
    severity: exports.ErrorSeverity.Todo,
    reason:
      "Could not preserve manual memoization because an inferred dependency does not match the dependency list in source",
    description: `The inferred dependency was \`${prettyPrintScopeDependency(dep)}\`, but the source dependencies were [${validDepsInMemoBlock.map((dep) => printManualMemoDependency(dep, true)).join(", ")}]. Detail: ${errorDiagnostic ? getCompareDependencyResultDescription(errorDiagnostic) : "none"}`,
    loc: GeneratedSource,
    suggestions: null,
  });
}
class Visitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = new Set();
    this.scopeMapping = new Map();
    this.temporaries = new Map();
  }
  collectMaybeMemoDependencies(value, state) {
    var _a, _b;
    switch (value.kind) {
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const result = this.collectMaybeMemoDependencies(value.value, state);
        return result;
      }
      case "OptionalExpression": {
        return this.collectMaybeMemoDependencies(value.value, state);
      }
      case "ReactiveFunctionValue":
      case "ConditionalExpression":
      case "LogicalExpression": {
        return null;
      }
      default: {
        const dep = collectMaybeMemoDependencies(value, this.temporaries);
        if (value.kind === "StoreLocal" || value.kind === "StoreContext") {
          const storeTarget = value.lvalue.place;
          (_a = state.manualMemoState) === null || _a === void 0
            ? void 0
            : _a.decls.add(storeTarget.identifier.id);
          if (
            ((_b = storeTarget.identifier.name) === null || _b === void 0
              ? void 0
              : _b.kind) === "named" &&
            dep == null
          ) {
            const dep = {
              root: { kind: "NamedLocal", value: storeTarget },
              path: [],
            };
            this.temporaries.set(storeTarget.identifier.id, dep);
            return dep;
          }
        }
        return dep;
      }
    }
  }
  recordTemporaries(instr, state) {
    var _a, _b, _c;
    const temporaries = this.temporaries;
    const { value: value } = instr;
    const lvalId =
      (_a = instr.lvalue) === null || _a === void 0 ? void 0 : _a.identifier.id;
    if (lvalId != null && temporaries.has(lvalId)) {
      return;
    }
    const isNamedLocal =
      lvalId != null &&
      ((_c =
        (_b = instr.lvalue) === null || _b === void 0
          ? void 0
          : _b.identifier.name) === null || _c === void 0
        ? void 0
        : _c.kind) === "named";
    if (isNamedLocal && state.manualMemoState != null) {
      state.manualMemoState.decls.add(lvalId);
    }
    const maybeDep = this.collectMaybeMemoDependencies(value, state);
    if (lvalId != null) {
      if (maybeDep != null) {
        temporaries.set(lvalId, maybeDep);
      } else if (isNamedLocal) {
        temporaries.set(lvalId, {
          root: { kind: "NamedLocal", value: Object.assign({}, instr.lvalue) },
          path: [],
        });
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    if (
      state.manualMemoState != null &&
      state.manualMemoState.depsFromSource != null
    ) {
      for (const dep of scopeBlock.scope.dependencies) {
        validateInferredDep(
          dep,
          this.temporaries,
          state.manualMemoState.decls,
          state.manualMemoState.depsFromSource,
          state.errors,
        );
      }
    }
    let areDependenciesMemoized = true;
    for (const dep of scopeBlock.scope.dependencies) {
      if (isUnmemoized(dep.identifier, this.scopes)) {
        areDependenciesMemoized = false;
        break;
      }
    }
    if (areDependenciesMemoized) {
      this.scopes.add(scopeBlock.scope.id);
      for (const id of scopeBlock.scope.merged) {
        this.scopes.add(id);
      }
    }
  }
  visitInstruction(instruction, state) {
    var _a, _b;
    this.traverseInstruction(instruction, state);
    this.recordTemporaries(instruction, state);
    if (instruction.value.kind === "StartMemoize") {
      let depsFromSource = null;
      if (instruction.value.deps != null) {
        depsFromSource = instruction.value.deps;
      }
      CompilerError.invariant(state.manualMemoState == null, {
        reason: "Unexpected nested StartMemoize instructions",
        description: `Bad manual memoization ids: ${(_a = state.manualMemoState) === null || _a === void 0 ? void 0 : _a.manualMemoId}, ${instruction.value.manualMemoId}`,
        loc: instruction.value.loc,
        suggestions: null,
      });
      state.manualMemoState = {
        decls: new Set(),
        depsFromSource: depsFromSource,
        manualMemoId: instruction.value.manualMemoId,
      };
    }
    if (instruction.value.kind === "FinishMemoize") {
      CompilerError.invariant(
        state.manualMemoState != null &&
          state.manualMemoState.manualMemoId === instruction.value.manualMemoId,
        {
          reason: "Unexpected mismatch between StartMemoize and FinishMemoize",
          description: `Encountered StartMemoize id=${(_b = state.manualMemoState) === null || _b === void 0 ? void 0 : _b.manualMemoId} followed by FinishMemoize id=${instruction.value.manualMemoId}`,
          loc: instruction.value.loc,
          suggestions: null,
        },
      );
      state.manualMemoState = null;
    }
    const isDep = instruction.value.kind === "StartMemoize";
    const isDecl =
      instruction.value.kind === "FinishMemoize" && !instruction.value.pruned;
    if (isDep || isDecl) {
      for (const value of eachInstructionValueOperand(instruction.value)) {
        if (
          isMutable(instruction, value) ||
          (isDecl && isUnmemoized(value.identifier, this.scopes))
        ) {
          state.errors.push({
            reason:
              "This value was manually memoized, but cannot be memoized under Forget because it may be mutated after it is memoized",
            description: null,
            severity: exports.ErrorSeverity.CannotPreserveMemoization,
            loc: typeof instruction.loc !== "symbol" ? instruction.loc : null,
            suggestions: null,
          });
        }
      }
    }
  }
}
function isUnmemoized(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}
function validateUseMemo(fn) {
  const useMemos = new Set();
  const react = new Set();
  const functions = new Map();
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (value.name === "useMemo") {
            useMemos.add(lvalue.identifier.id);
          } else if (value.name === "React") {
            react.add(lvalue.identifier.id);
          }
          break;
        }
        case "PropertyLoad": {
          if (react.has(value.object.identifier.id)) {
            if (value.property === "useMemo") {
              useMemos.add(lvalue.identifier.id);
            }
          }
          break;
        }
        case "FunctionExpression": {
          functions.set(lvalue.identifier.id, value);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee =
            value.kind === "CallExpression"
              ? value.callee.identifier.id
              : value.property.identifier.id;
          const isUseMemo = useMemos.has(callee);
          if (!isUseMemo || value.args.length === 0) {
            continue;
          }
          const [arg] = value.args;
          if (arg.kind !== "Identifier") {
            continue;
          }
          const body = functions.get(arg.identifier.id);
          if (body === undefined) {
            continue;
          }
          if (body.loweredFunc.func.params.length > 0) {
            CompilerError.throwInvalidReact({
              reason: "useMemo callbacks may not accept any arguments",
              description: null,
              loc: body.loc,
              suggestions: null,
            });
          }
          if (body.loweredFunc.func.async || body.loweredFunc.func.generator) {
            CompilerError.throwInvalidReact({
              reason:
                "useMemo callbacks may not be async or generator functions",
              description: null,
              loc: body.loc,
              suggestions: null,
            });
          }
          break;
        }
      }
    }
  }
}
function* run(func, config, fnType, logger, filename) {
  const contextIdentifiers = findContextIdentifiers(func);
  const env = new Environment(
    fnType,
    config,
    contextIdentifiers,
    logger,
    filename,
  );
  yield {
    kind: "debug",
    name: "EnvironmentConfig",
    value: prettyFormat$1(env.config),
  };
  const ast = yield* runWithEnvironment(func, env);
  return ast;
}
function* runWithEnvironment(func, env) {
  const hir = lower$1(func, env).unwrap();
  yield log({ kind: "hir", name: "HIR", value: hir });
  pruneMaybeThrows(hir);
  yield log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  validateContextVariableLValues(hir);
  validateUseMemo(hir);
  dropManualMemoization(hir);
  yield log({ kind: "hir", name: "DropManualMemoization", value: hir });
  inlineImmediatelyInvokedFunctionExpressions(hir);
  yield log({
    kind: "hir",
    name: "InlineImmediatelyInvokedFunctionExpressions",
    value: hir,
  });
  mergeConsecutiveBlocks(hir);
  yield log({ kind: "hir", name: "MergeConsecutiveBlocks", value: hir });
  assertConsistentIdentifiers(hir);
  assertTerminalSuccessorsExist(hir);
  enterSSA(hir);
  yield log({ kind: "hir", name: "SSA", value: hir });
  eliminateRedundantPhi(hir);
  yield log({ kind: "hir", name: "EliminateRedundantPhi", value: hir });
  assertConsistentIdentifiers(hir);
  constantPropagation(hir);
  yield log({ kind: "hir", name: "ConstantPropagation", value: hir });
  inferTypes(hir);
  yield log({ kind: "hir", name: "InferTypes", value: hir });
  if (env.config.validateHooksUsage) {
    validateHooksUsage(hir);
  }
  if (env.config.validateNoCapitalizedCalls) {
    validateNoCapitalizedCalls(hir);
  }
  analyseFunctions(hir);
  yield log({ kind: "hir", name: "AnalyseFunctions", value: hir });
  inferReferenceEffects(hir);
  yield log({ kind: "hir", name: "InferReferenceEffects", value: hir });
  deadCodeElimination(hir);
  yield log({ kind: "hir", name: "DeadCodeElimination", value: hir });
  pruneMaybeThrows(hir);
  yield log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  inferMutableRanges(hir);
  yield log({ kind: "hir", name: "InferMutableRanges", value: hir });
  if (env.config.assertValidMutableRanges) {
    assertValidMutableRanges(hir);
  }
  if (env.config.validateRefAccessDuringRender) {
    validateNoRefAccessInRender(hir);
  }
  if (env.config.validateNoSetStateInRender) {
    validateNoSetStateInRender(hir);
  }
  inferReactivePlaces(hir);
  yield log({ kind: "hir", name: "InferReactivePlaces", value: hir });
  leaveSSA(hir);
  yield log({ kind: "hir", name: "LeaveSSA", value: hir });
  inferReactiveScopeVariables(hir);
  yield log({ kind: "hir", name: "InferReactiveScopeVariables", value: hir });
  alignMethodCallScopes(hir);
  yield log({ kind: "hir", name: "AlignMethodCallScopes", value: hir });
  alignObjectMethodScopes(hir);
  yield log({ kind: "hir", name: "AlignObjectMethodScopes", value: hir });
  memoizeFbtOperandsInSameScope(hir);
  yield log({ kind: "hir", name: "MemoizeFbtOperandsInSameScope", value: hir });
  if (env.config.enableAlignReactiveScopesToBlockScopesHIR) {
    alignReactiveScopesToBlockScopesHIR(hir);
    yield log({
      kind: "hir",
      name: "AlignReactiveScopesToBlockScopesHIR",
      value: hir,
    });
  }
  const reactiveFunction = buildReactiveFunction(hir);
  yield log({
    kind: "reactive",
    name: "BuildReactiveFunction",
    value: reactiveFunction,
  });
  pruneUnusedLabels(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedLabels",
    value: reactiveFunction,
  });
  if (!env.config.enableAlignReactiveScopesToBlockScopesHIR) {
    alignReactiveScopesToBlockScopes(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "AlignReactiveScopesToBlockScopes",
      value: reactiveFunction,
    });
    mergeOverlappingReactiveScopes(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "MergeOverlappingReactiveScopes",
      value: reactiveFunction,
    });
  }
  buildReactiveBlocks(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "BuildReactiveBlocks",
    value: reactiveFunction,
  });
  flattenReactiveLoops(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "FlattenReactiveLoops",
    value: reactiveFunction,
  });
  assertScopeInstructionsWithinScopes(reactiveFunction);
  flattenScopesWithHooksOrUse(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "FlattenScopesWithHooks",
    value: reactiveFunction,
  });
  propagateScopeDependencies(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PropagateScopeDependencies",
    value: reactiveFunction,
  });
  pruneNonEscapingScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneNonEscapingScopes",
    value: reactiveFunction,
  });
  pruneNonReactiveDependencies(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneNonReactiveDependencies",
    value: reactiveFunction,
  });
  pruneUnusedScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedScopes",
    value: reactiveFunction,
  });
  mergeReactiveScopesThatInvalidateTogether(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "MergeReactiveScopesThatInvalidateTogether",
    value: reactiveFunction,
  });
  pruneAlwaysInvalidatingScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneAlwaysInvalidatingScopes",
    value: reactiveFunction,
  });
  propagateEarlyReturns(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PropagateEarlyReturns",
    value: reactiveFunction,
  });
  promoteUsedTemporaries(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PromoteUsedTemporaries",
    value: reactiveFunction,
  });
  pruneTemporaryLValues(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedLValues",
    value: reactiveFunction,
  });
  extractScopeDeclarationsFromDestructuring(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "ExtractScopeDeclarationsFromDestructuring",
    value: reactiveFunction,
  });
  const uniqueIdentifiers = renameVariables(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "RenameVariables",
    value: reactiveFunction,
  });
  pruneHoistedContexts(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneHoistedContexts",
    value: reactiveFunction,
  });
  if (env.config.validateMemoizedEffectDependencies) {
    validateMemoizedEffectDependencies(reactiveFunction);
  }
  if (
    env.config.enablePreserveExistingMemoizationGuarantees ||
    env.config.validatePreserveExistingMemoizationGuarantees
  ) {
    validatePreservedManualMemoization(reactiveFunction);
  }
  const ast = codegenFunction(reactiveFunction, uniqueIdentifiers).unwrap();
  yield log({ kind: "ast", name: "Codegen", value: ast });
  if (env.config.throwUnknownException__testonly) {
    throw new Error("unexpected error");
  }
  return ast;
}
function compileFn(func, config, fnType, logger, filename) {
  let generator = run(func, config, fnType, logger, filename);
  while (true) {
    const next = generator.next();
    if (next.done) {
      return next.value;
    }
  }
}
function log(value) {
  switch (value.kind) {
    case "ast": {
      logCodegenFunction(value.name, value.value);
      break;
    }
    case "hir": {
      logHIRFunction(value.name, value.value);
      break;
    }
    case "reactive": {
      logReactiveFunction(value.name, value.value);
      break;
    }
    case "debug": {
      logDebug(value.name, value.value);
      break;
    }
    default: {
      assertExhaustive(value, "Unexpected compilation kind");
    }
  }
  return value;
}
function isComponentDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__componentDeclaration");
}
function isHookDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__hookDeclaration");
}
function filterSuppressionsThatAffectFunction(suppressionRanges, fn) {
  const suppressionsInScope = [];
  const fnNode = fn.node;
  for (const suppressionRange of suppressionRanges) {
    if (
      suppressionRange.disableComment.start == null ||
      fnNode.start == null ||
      fnNode.end == null
    ) {
      continue;
    }
    if (
      suppressionRange.disableComment.start > fnNode.start &&
      (suppressionRange.enableComment === null ||
        (suppressionRange.enableComment.end != null &&
          suppressionRange.enableComment.end < fnNode.end))
    ) {
      suppressionsInScope.push(suppressionRange);
    }
    if (
      suppressionRange.disableComment.start < fnNode.start &&
      (suppressionRange.enableComment === null ||
        (suppressionRange.enableComment.end != null &&
          suppressionRange.enableComment.end > fnNode.end))
    ) {
      suppressionsInScope.push(suppressionRange);
    }
  }
  return suppressionsInScope;
}
function findProgramSuppressions(programComments, ruleNames, flowSuppressions) {
  const suppressionRanges = [];
  let disableComment = null;
  let enableComment = null;
  let source = null;
  const rulePattern = `(${ruleNames.join("|")})`;
  const disableNextLinePattern = new RegExp(
    `eslint-disable-next-line ${rulePattern}`,
  );
  const disablePattern = new RegExp(`eslint-disable ${rulePattern}`);
  const enablePattern = new RegExp(`eslint-enable ${rulePattern}`);
  const flowSuppressionPattern = new RegExp(
    "\\$(FlowFixMe\\w*|FlowExpectedError|FlowIssue)\\[react\\-rule",
  );
  for (const comment of programComments) {
    if (comment.start == null || comment.end == null) {
      continue;
    }
    if (disableComment == null && disableNextLinePattern.test(comment.value)) {
      disableComment = comment;
      enableComment = comment;
      source = "Eslint";
    }
    if (
      flowSuppressions &&
      disableComment == null &&
      flowSuppressionPattern.test(comment.value)
    ) {
      disableComment = comment;
      enableComment = comment;
      source = "Flow";
    }
    if (disablePattern.test(comment.value)) {
      disableComment = comment;
      source = "Eslint";
    }
    if (enablePattern.test(comment.value) && source === "Eslint") {
      enableComment = comment;
    }
    if (disableComment != null && source != null) {
      suppressionRanges.push({
        disableComment: disableComment,
        enableComment: enableComment,
        source: source,
      });
      disableComment = null;
      enableComment = null;
      source = null;
    }
  }
  return suppressionRanges;
}
function suppressionsToCompilerError(suppressionRanges) {
  var _a;
  if (suppressionRanges.length === 0) {
    return null;
  }
  const error = new CompilerError();
  for (const suppressionRange of suppressionRanges) {
    if (
      suppressionRange.disableComment.start == null ||
      suppressionRange.disableComment.end == null
    ) {
      continue;
    }
    let reason, suggestion;
    switch (suppressionRange.source) {
      case "Eslint":
        reason =
          "React Compiler has bailed out of optimizing this component as one or more React eslint rules were disabled";
        suggestion = "Remove the eslint disable";
        break;
      case "Flow":
        reason =
          "React Compiler has bailed out of optimizing this component as one or more React rule violations were reported by Flow";
        suggestion = "Remove the Flow suppression and address the React error";
        break;
      default:
        assertExhaustive(
          suppressionRange.source,
          "Unhandled suppression source",
        );
    }
    error.pushErrorDetail(
      new CompilerErrorDetail({
        reason: `${reason}. React Compiler only works when your components follow all the rules of React, disabling them may result in undefined behavior`,
        description: suppressionRange.disableComment.value.trim(),
        severity: exports.ErrorSeverity.InvalidReact,
        loc:
          (_a = suppressionRange.disableComment.loc) !== null && _a !== void 0
            ? _a
            : null,
        suggestions: [
          {
            description: suggestion,
            range: [
              suppressionRange.disableComment.start,
              suppressionRange.disableComment.end,
            ],
            op: exports.CompilerSuggestionOperation.Remove,
          },
        ],
      }),
    );
  }
  return error;
}
function findDirectiveEnablingMemoization(directives) {
  for (const directive of directives) {
    const directiveValue = directive.value.value;
    if (directiveValue === "use forget" || directiveValue === "use memo") {
      return directive;
    }
  }
  return null;
}
function findDirectiveDisablingMemoization(directives, options) {
  for (const directive of directives) {
    const directiveValue = directive.value.value;
    if (
      (directiveValue === "use no forget" ||
        directiveValue === "use no memo") &&
      !options.ignoreUseNoForget
    ) {
      return directive;
    }
  }
  return null;
}
function isCriticalError(err) {
  return !(err instanceof CompilerError) || err.isCritical();
}
function isConfigError(err) {
  if (err instanceof CompilerError) {
    return err.details.some(
      (detail) => detail.severity === exports.ErrorSeverity.InvalidConfig,
    );
  }
  return false;
}
function handleError(err, pass, fnLoc) {
  var _a, _b;
  if (pass.opts.logger) {
    if (err instanceof CompilerError) {
      for (const detail of err.details) {
        pass.opts.logger.logEvent(pass.filename, {
          kind: "CompileError",
          fnLoc: fnLoc,
          detail: detail.options,
        });
      }
    } else {
      let stringifiedError;
      if (err instanceof Error) {
        stringifiedError =
          (_a = err.stack) !== null && _a !== void 0 ? _a : err.message;
      } else {
        stringifiedError =
          (_b = err === null || err === void 0 ? void 0 : err.toString()) !==
            null && _b !== void 0
            ? _b
            : "[ null ]";
      }
      pass.opts.logger.logEvent(pass.filename, {
        kind: "PipelineError",
        fnLoc: fnLoc,
        data: stringifiedError,
      });
    }
  }
  if (
    pass.opts.panicThreshold === "all_errors" ||
    (pass.opts.panicThreshold === "critical_errors" && isCriticalError(err)) ||
    isConfigError(err)
  ) {
    throw err;
  }
}
function createNewFunctionNode(originalFn, compiledFn) {
  var _a, _b, _c;
  let transformedFn;
  switch (originalFn.node.type) {
    case "FunctionDeclaration": {
      const fn = {
        type: "FunctionDeclaration",
        id: compiledFn.id,
        loc: (_a = originalFn.node.loc) !== null && _a !== void 0 ? _a : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
    case "ArrowFunctionExpression": {
      const fn = {
        type: "ArrowFunctionExpression",
        loc: (_b = originalFn.node.loc) !== null && _b !== void 0 ? _b : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        expression: originalFn.node.expression,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
    case "FunctionExpression": {
      const fn = {
        type: "FunctionExpression",
        id: compiledFn.id,
        loc: (_c = originalFn.node.loc) !== null && _c !== void 0 ? _c : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
  }
  ALREADY_COMPILED.add(transformedFn);
  return transformedFn;
}
const ALREADY_COMPILED = new (
  WeakSet !== null && WeakSet !== void 0 ? WeakSet : Set
)();
const DEFAULT_ESLINT_SUPPRESSIONS = [
  "react-hooks/exhaustive-deps",
  "react-hooks/rules-of-hooks",
];
function compileProgram(program, pass) {
  var _a, _b, _c, _d, _e, _f;
  const options = parsePluginOptions(pass.opts);
  if (
    findDirectiveDisablingMemoization(program.node.directives, options) != null
  ) {
    return;
  }
  const environment = parseEnvironmentConfig(
    (_a = pass.opts.environment) !== null && _a !== void 0 ? _a : {},
  );
  const suppressions = findProgramSuppressions(
    pass.comments,
    (_b = options.eslintSuppressionRules) !== null && _b !== void 0
      ? _b
      : DEFAULT_ESLINT_SUPPRESSIONS,
    options.flowSuppressions,
  );
  const lintError = suppressionsToCompilerError(suppressions);
  let hasCriticalError = lintError != null;
  const compiledFns = [];
  const traverseFunction = (fn, pass) => {
    var _a, _b, _c, _d, _e, _f;
    const fnType = getReactFunctionType(fn, pass);
    if (fnType === null || ALREADY_COMPILED.has(fn.node)) {
      return;
    }
    ALREADY_COMPILED.add(fn.node);
    fn.skip();
    if (lintError != null) {
      const suppressionsInFunction = filterSuppressionsThatAffectFunction(
        suppressions,
        fn,
      );
      if (suppressionsInFunction.length > 0) {
        handleError(
          lintError,
          pass,
          (_a = fn.node.loc) !== null && _a !== void 0 ? _a : null,
        );
      }
    }
    let compiledFn;
    try {
      if (environment.isErr()) {
        CompilerError.throwInvalidConfig({
          reason: "Error in validating environment config",
          description: environment.unwrapErr().toString(),
          suggestions: null,
          loc: null,
        });
      }
      const config = environment.unwrap();
      compiledFn = compileFn(fn, config, fnType, options.logger, pass.filename);
      (_b = options.logger) === null || _b === void 0
        ? void 0
        : _b.logEvent(pass.filename, {
            kind: "CompileSuccess",
            fnLoc: (_c = fn.node.loc) !== null && _c !== void 0 ? _c : null,
            fnName:
              (_e =
                (_d = compiledFn.id) === null || _d === void 0
                  ? void 0
                  : _d.name) !== null && _e !== void 0
                ? _e
                : null,
            memoSlots: compiledFn.memoSlotsUsed,
            memoBlocks: compiledFn.memoBlocks,
          });
    } catch (err) {
      hasCriticalError || (hasCriticalError = isCriticalError(err));
      handleError(
        err,
        pass,
        (_f = fn.node.loc) !== null && _f !== void 0 ? _f : null,
      );
      return;
    }
    if (!pass.opts.noEmit && !hasCriticalError) {
      compiledFns.push({ originalFn: fn, compiledFn: compiledFn });
    }
  };
  program.traverse(
    {
      ClassDeclaration(node) {
        node.skip();
        return;
      },
      ClassExpression(node) {
        node.skip();
        return;
      },
      FunctionDeclaration: traverseFunction,
      FunctionExpression: traverseFunction,
      ArrowFunctionExpression: traverseFunction,
    },
    Object.assign(Object.assign({}, pass), {
      opts: Object.assign(Object.assign({}, pass.opts), options),
      filename: (_c = pass.filename) !== null && _c !== void 0 ? _c : null,
    }),
  );
  if (options.gating != null) {
    const error = checkFunctionReferencedBeforeDeclarationAtTopLevel(
      program,
      compiledFns.map(({ originalFn: originalFn }) => originalFn),
    );
    if (error) {
      handleError(error, pass, null);
      return;
    }
  }
  const externalFunctions = [];
  let gating = null;
  try {
    if (options.gating != null) {
      gating = tryParseExternalFunction(options.gating);
      externalFunctions.push(gating);
    }
    const enableEmitInstrumentForget =
      (_d = options.environment) === null || _d === void 0
        ? void 0
        : _d.enableEmitInstrumentForget;
    if (enableEmitInstrumentForget != null) {
      externalFunctions.push(
        tryParseExternalFunction(enableEmitInstrumentForget.fn),
      );
      if (enableEmitInstrumentForget.gating != null) {
        externalFunctions.push(
          tryParseExternalFunction(enableEmitInstrumentForget.gating),
        );
      }
    }
    if (
      ((_e = options.environment) === null || _e === void 0
        ? void 0
        : _e.enableEmitFreeze) != null
    ) {
      const enableEmitFreeze = tryParseExternalFunction(
        options.environment.enableEmitFreeze,
      );
      externalFunctions.push(enableEmitFreeze);
    }
    if (
      ((_f = options.environment) === null || _f === void 0
        ? void 0
        : _f.enableEmitHookGuards) != null
    ) {
      const enableEmitHookGuards = tryParseExternalFunction(
        options.environment.enableEmitHookGuards,
      );
      externalFunctions.push(enableEmitHookGuards);
    }
  } catch (err) {
    handleError(err, pass, null);
    return;
  }
  for (const {
    originalFn: originalFn,
    compiledFn: compiledFn,
  } of compiledFns) {
    const transformedFn = createNewFunctionNode(originalFn, compiledFn);
    if (gating != null) {
      insertGatedFunctionDeclaration(originalFn, transformedFn, gating);
    } else {
      originalFn.replaceWith(transformedFn);
    }
  }
  if (compiledFns.length > 0) {
    updateUseMemoCacheImport(program, options);
    addImportsToProgram(program, externalFunctions);
  }
}
function getReactFunctionType(fn, pass) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (hasUseMemoCacheCall(fn)) {
    return null;
  }
  const hookPattern =
    (_b =
      (_a = pass.opts.environment) === null || _a === void 0
        ? void 0
        : _a.hookPattern) !== null && _b !== void 0
      ? _b
      : null;
  if (fn.node.body.type === "BlockStatement") {
    const useNoForget = findDirectiveDisablingMemoization(
      fn.node.body.directives,
      pass.opts,
    );
    if (useNoForget != null) {
      (_c = pass.opts.logger) === null || _c === void 0
        ? void 0
        : _c.logEvent(pass.filename, {
            kind: "CompileError",
            fnLoc:
              (_d = fn.node.body.loc) !== null && _d !== void 0 ? _d : null,
            detail: {
              severity: exports.ErrorSeverity.Todo,
              reason: 'Skipped due to "use no forget" directive.',
              loc: (_e = useNoForget.loc) !== null && _e !== void 0 ? _e : null,
              suggestions: null,
            },
          });
      return null;
    }
    if (findDirectiveEnablingMemoization(fn.node.body.directives) != null) {
      return (_f = getComponentOrHookLike(fn, hookPattern)) !== null &&
        _f !== void 0
        ? _f
        : "Other";
    }
  }
  switch (pass.opts.compilationMode) {
    case "annotation": {
      return null;
    }
    case "infer": {
      if (fn.isFunctionDeclaration()) {
        if (isComponentDeclaration(fn.node)) {
          return "Component";
        } else if (isHookDeclaration(fn.node)) {
          return "Hook";
        }
      }
      return getComponentOrHookLike(fn, hookPattern);
    }
    case "all": {
      if (fn.scope.getProgramParent() !== fn.scope.parent) {
        return null;
      }
      return (_g = getComponentOrHookLike(fn, hookPattern)) !== null &&
        _g !== void 0
        ? _g
        : "Other";
    }
    default: {
      assertExhaustive(
        pass.opts.compilationMode,
        `Unexpected compilationMode '${pass.opts.compilationMode}'`,
      );
    }
  }
}
function hasUseMemoCacheCall(fn) {
  let hasUseMemoCache = false;
  fn.traverse({
    Identifier(path) {
      if (
        path.node.name === "useMemoCache" ||
        path.node.name === "unstable_useMemoCache"
      ) {
        hasUseMemoCache = true;
      }
    },
  });
  return hasUseMemoCache;
}
function isHookName(s, hookPattern) {
  if (hookPattern !== null) {
    return new RegExp(hookPattern).test(s);
  }
  return /^use[A-Z0-9]/.test(s);
}
function isHook(path, hookPattern) {
  if (path.isIdentifier()) {
    return isHookName(path.node.name, hookPattern);
  } else if (
    path.isMemberExpression() &&
    !path.node.computed &&
    isHook(path.get("property"), hookPattern)
  ) {
    const obj = path.get("object").node;
    const isPascalCaseNameSpace = /^[A-Z].*/;
    return obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name);
  } else {
    return false;
  }
}
function isComponentName(path) {
  return path.isIdentifier() && /^[A-Z]/.test(path.node.name);
}
function isReactAPI(path, functionName) {
  const node = path.node;
  return (
    (node.type === "Identifier" && node.name === functionName) ||
    (node.type === "MemberExpression" &&
      node.object.type === "Identifier" &&
      node.object.name === "React" &&
      node.property.type === "Identifier" &&
      node.property.name === functionName)
  );
}
function isForwardRefCallback(path) {
  return !!(
    path.parentPath.isCallExpression() &&
    path.parentPath.get("callee").isExpression() &&
    isReactAPI(path.parentPath.get("callee"), "forwardRef")
  );
}
function isMemoCallback(path) {
  return (
    path.parentPath.isCallExpression() &&
    path.parentPath.get("callee").isExpression() &&
    isReactAPI(path.parentPath.get("callee"), "memo")
  );
}
function isValidComponentParams(params) {
  if (params.length === 0) {
    return true;
  } else if (params.length === 1) {
    return !params[0].isRestElement();
  } else if (params.length === 2) {
    if (params[1].isIdentifier()) {
      const { name: name } = params[1].node;
      return name.includes("ref") || name.includes("Ref");
    }
  }
  return false;
}
function getComponentOrHookLike(node, hookPattern) {
  const functionName = getFunctionName(node);
  if (functionName !== null && isComponentName(functionName)) {
    let isComponent =
      callsHooksOrCreatesJsx(node, hookPattern) &&
      isValidComponentParams(node.get("params"));
    return isComponent ? "Component" : null;
  } else if (functionName !== null && isHook(functionName, hookPattern)) {
    return callsHooksOrCreatesJsx(node, hookPattern) ? "Hook" : null;
  }
  if (node.isFunctionExpression() || node.isArrowFunctionExpression()) {
    if (isForwardRefCallback(node) || isMemoCallback(node)) {
      return callsHooksOrCreatesJsx(node, hookPattern) ? "Component" : null;
    }
  }
  return null;
}
function callsHooksOrCreatesJsx(node, hookPattern) {
  let invokesHooks = false;
  let createsJsx = false;
  node.traverse({
    JSX() {
      createsJsx = true;
    },
    CallExpression(call) {
      const callee = call.get("callee");
      if (callee.isExpression() && isHook(callee, hookPattern)) {
        invokesHooks = true;
      }
    },
  });
  return invokesHooks || createsJsx;
}
function getFunctionName(path) {
  if (path.isFunctionDeclaration()) {
    const id = path.get("id");
    if (id.isIdentifier()) {
      return id;
    }
    return null;
  }
  let id = null;
  const parent = path.parentPath;
  if (parent.isVariableDeclarator() && parent.get("init").node === path.node) {
    id = parent.get("id");
  } else if (
    parent.isAssignmentExpression() &&
    parent.get("right").node === path.node &&
    parent.get("operator") === "="
  ) {
    id = parent.get("left");
  } else if (
    parent.isProperty() &&
    parent.get("value").node === path.node &&
    !parent.get("computed") &&
    parent.get("key").isLVal()
  ) {
    id = parent.get("key");
  } else if (
    parent.isAssignmentPattern() &&
    parent.get("right").node === path.node &&
    !parent.get("computed")
  ) {
    id = parent.get("left");
  }
  if (id !== null && (id.isIdentifier() || id.isMemberExpression())) {
    return id;
  } else {
    return null;
  }
}
function checkFunctionReferencedBeforeDeclarationAtTopLevel(program, fns) {
  const fnIds = new Set(
    fns
      .map((fn) => getFunctionName(fn))
      .filter((name) => !!name && name.isIdentifier())
      .map((name) => name.node),
  );
  const fnNames = new Map([...fnIds].map((id) => [id.name, id]));
  const errors = new CompilerError();
  program.traverse({
    Identifier(id) {
      var _a;
      const fn = fnNames.get(id.node.name);
      if (!fn) {
        return;
      }
      if (fnIds.has(id.node)) {
        fnIds.delete(id.node);
        fnNames.delete(id.node.name);
        return;
      }
      const scope = id.scope.getFunctionParent();
      if (scope === null) {
        errors.pushErrorDetail(
          new CompilerErrorDetail({
            reason: `Encountered a function used before its declaration, which breaks Forget's gating codegen due to hoisting`,
            description: `Rewrite the reference to ${fn.name} to not rely on hoisting to fix this issue`,
            loc: (_a = fn.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
            severity: exports.ErrorSeverity.Invariant,
          }),
        );
      }
    },
  });
  return errors.details.length > 0 ? errors : null;
}
function ReactForgetBabelPlugin(_babel) {
  return {
    name: "react-forget",
    visitor: {
      Program(prog, pass) {
        var _a, _b;
        compileProgram(prog, {
          opts: parsePluginOptions(pass.opts),
          filename: (_a = pass.filename) !== null && _a !== void 0 ? _a : null,
          comments:
            (_b = pass.file.ast.comments) !== null && _b !== void 0 ? _b : [],
        });
      },
    },
  };
}
exports.CompilerError = CompilerError;
exports.CompilerErrorDetail = CompilerErrorDetail;
exports.compile = compileFn;
exports.compileProgram = compileProgram;
exports.default = ReactForgetBabelPlugin;
exports.parseConfigPragma = parseConfigPragma;
exports.parsePluginOptions = parsePluginOptions;
exports.printHIR = printHIR;
exports.printReactiveFunction = printReactiveFunction;
exports.run = run;
exports.validateEnvironmentConfig = validateEnvironmentConfig;
