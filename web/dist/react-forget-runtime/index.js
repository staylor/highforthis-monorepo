/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */

"use no memo";"use strict";function e(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var t,r=e(require("react"));const{useRef:n,useEffect:o}=r,c=null!==(t=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE)&&void 0!==t?t:r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,u=Symbol.for("react.memo_cache_sentinel");const a={};["readContext","useCallback","useContext","useEffect","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","useDebugValue","useDeferredValue","useTransition","useMutableSource","useSyncExternalStore","useId","unstable_isNewReconciler","getCacheSignal","getCacheForType","useCacheRefresh"].forEach((e=>{a[e]=()=>{throw new Error(`[React] Unexpected React hook call (${e}) from a React Forget compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `)}}));let l=null;var s;function i(e){return c.ReactCurrentDispatcher.current=e,c.ReactCurrentDispatcher.current}a.useMemoCache=e=>{if(null==l)throw new Error("React Forget internal invariant violation: unexpected null dispatcher");return l.useMemoCache(e)},function(e){e[e.PushGuardContext=0]="PushGuardContext",e[e.PopGuardContext=1]="PopGuardContext",e[e.PushExpectHook=2]="PushExpectHook",e[e.PopExpectHook=3]="PopExpectHook"}(s||(s={}));const f=[];const d=new Map;exports.$dispatcherGuard=function(e){const t=c.ReactCurrentDispatcher.current;if(e===s.PushGuardContext){if(f.push(t),1===f.length&&(l=t),t===a)throw new Error("[React] Unexpected call to custom hook or component from a React Forget compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.");i(a)}else if(e===s.PopGuardContext){const e=f.pop();if(null==e)throw new Error("React Forget internal error: unexpected null in guard stack");0===f.length&&(l=null),i(e)}else if(e===s.PushExpectHook)f.push(t),i(l);else{if(e!==s.PopExpectHook)throw new Error("Forget internal error: unreachable block"+e);{const e=f.pop();if(null==e)throw new Error("React Forget internal error: unexpected null in guard stack");i(e)}}},exports.$makeReadOnly=function(){throw new Error("TODO: implement $makeReadOnly in react-forget-runtime")},exports.$read=function(e,t){const r=e[t];if(r===u)throw new Error("useMemoCache: read before write");return r},exports.$reset=function(e){for(let t=0;t<e.length;t++)e[t]=u},exports.clearRenderCounterRegistry=function(){for(const e of d.values())e.forEach((e=>{e.count=0}))},exports.renderCounterRegistry=d,exports.unstable_useMemoCache=function(e){return r.useState((()=>{const t=new Array(e);for(let r=0;r<e;r++)t[r]=u;return t[u]=!0,t}))[0]},exports.useRenderCounter=function(e){const t=n(null);null!=t.current&&(t.current.count+=1),o((()=>{if(null==t.current){const r={count:0};!function(e,t){let r=d.get(e);null==r&&(r=new Set,d.set(e,r)),r.add(t)}(e,r),t.current=r}return()=>{null!==t.current&&function(e,t){const r=d.get(e);null!=r&&r.delete(t)}(e,t.current)}}))};
//# sourceMappingURL=index.js.map
